[{"id":"5b9485aa95f0d129","type":"tab","label":"Master","disabled":false,"info":"","env":[]},{"id":"43457bccef542a7d","type":"group","z":"5b9485aa95f0d129","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ff31217e40ad4b05","7c87b0ddef19c485","830ae29ab82e7324","e169760164875f0d","475e1c236aeba4d1","e2d1060d7f9a6441","9626681e71699287","8fe9c92afc561145","9967ec5e0edd8865","51e259473c842217","7972042b37655b19","1f613600601fde7a","cbd6c91073fd88a5","43d31f16658453c9","4760488940785c7b","47e4915877639ef5","10e3067fe685efa7","cfef77bffb098c25","21dd9af34945132e","64cb926c237c0102","ef62895c84290225","3523f89ec9c2c676","544a86e20ad408b7"],"x":28,"y":13,"w":1388,"h":734},{"id":"3523f89ec9c2c676","type":"group","z":"5b9485aa95f0d129","g":"43457bccef542a7d","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["f918483e39cca146","002d11c9c357103a","2ab6344485625dcd","6fe72eaf1d2902f0","d5304206f52a55b7","d55ff9409b336801","6bcddff9e4459ebe","9243695e03284f5a","689b21de2004713b","637ca5a8c9caff38","df0c7ce07867e0a6","d2b18836de168ff3","3fb0e90d008a49cb","fba4373e4922558f","2f145079d4c19792"],"x":54,"y":519,"w":1332,"h":202},{"id":"ef62895c84290225","type":"group","z":"5b9485aa95f0d129","g":"43457bccef542a7d","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ec276734748d6829","04f5f1cb8930332f","46fe411f25a067ab","40afa2a7ef46e38a","a57af3a5f16d2223"],"x":54,"y":39,"w":572,"h":162},{"id":"64cb926c237c0102","type":"junction","z":"5b9485aa95f0d129","g":"43457bccef542a7d","x":500,"y":320,"wires":[["51e259473c842217","7c87b0ddef19c485"]]},{"id":"a57af3a5f16d2223","type":"junction","z":"5b9485aa95f0d129","g":"ef62895c84290225","x":340,"y":140,"wires":[["40afa2a7ef46e38a"]]},{"id":"7c87b0ddef19c485","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"areas","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/area_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"areas","propertyType":"msg","value":"","valueType":"results"},{"property":"topic","propertyType":"msg","value":"areas","valueType":"str"}],"x":570,"y":280,"wires":[["43d31f16658453c9","4760488940785c7b"]]},{"id":"544a86e20ad408b7","type":"inject","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Manual Update","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":"15","topic":"","payload":"","payloadType":"date","x":160,"y":240,"wires":[["64cb926c237c0102"]]},{"id":"830ae29ab82e7324","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"entities","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/entity_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"entities","propertyType":"msg","value":"","valueType":"results"}],"x":1020,"y":320,"wires":[["cbd6c91073fd88a5"]]},{"id":"e169760164875f0d","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"On Connect","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"home_assistant_client","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":190,"y":460,"wires":[["475e1c236aeba4d1"]]},{"id":"475e1c236aeba4d1","type":"switch","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"con","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"connected","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":370,"y":460,"wires":[["64cb926c237c0102"]]},{"id":"e2d1060d7f9a6441","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"entity_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"entity_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":160,"y":280,"wires":[["9967ec5e0edd8865"]]},{"id":"9626681e71699287","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"device_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"device_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":190,"y":340,"wires":[["9967ec5e0edd8865"]]},{"id":"8fe9c92afc561145","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"area_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"area_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":200,"y":400,"wires":[["9967ec5e0edd8865"]]},{"id":"9967ec5e0edd8865","type":"trigger","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Update","op1":"","op2":"","op1type":"nul","op2type":"payl","duration":"1","extend":false,"overrideDelay":false,"units":"min","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":400,"y":340,"wires":[["64cb926c237c0102"]]},{"id":"51e259473c842217","type":"ha-get-entities","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Get All Entities","server":"home-assistant-server","version":1,"rules":[],"outputType":"array","outputEmptyResults":false,"outputLocationType":"msg","outputLocation":"payload","x":580,"y":400,"wires":[["7972042b37655b19"]]},{"id":"7972042b37655b19","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"AllData","func":"msg.topic=\"AllData\"\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":740,"y":400,"wires":[["ff31217e40ad4b05"]]},{"id":"1f613600601fde7a","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"GroupFilledRoom","func":"let data = msg.payload;\nlet allData = data.AllData;\ndelete data.AllData;\n\n// Erstelle ein Mapping von entity_id zu state aus dem AllData-Array\nlet entityIdToStateMap = {};\nallData.forEach(item => {\n    entityIdToStateMap[item.entity_id] = item.state;\n});\n\n// Erstelle ein neues Objekt zur Gruppierung der Daten, das die gleiche Struktur wie das Ursprungsobjekt beibehält\nlet groupedData = {};\n\n// Iteriere über die Hauptgruppen in data (z.B., flowertent, vegittent, dryingtent, ambient)\nfor (let group in data) {\n    if (data.hasOwnProperty(group)) {\n        groupedData[group] = {}; // Behalte den Gruppennamen wie flowertent\n\n        // Iteriere über die Untergruppen in der Hauptgruppe (z.B., light, plant, co2, ...)\n        for (let subGroup in data[group]) {\n            if (data[group].hasOwnProperty(subGroup)) {\n                groupedData[group][subGroup] = {};\n\n                // Iteriere über die Sensoren in der Untergruppe\n                for (let sensor in data[group][subGroup]) {\n                    if (data[group][subGroup].hasOwnProperty(sensor)) {\n                        // Hole den Wert aus entityIdToStateMap, falls vorhanden, andernfalls behalte den bestehenden Wert\n                        let value = entityIdToStateMap[sensor] !== undefined ? entityIdToStateMap[sensor] : data[group][subGroup][sensor];\n\n                        // Speichere den Sensor-Schlüssel mit dem gefüllten Wert in groupedData\n                        groupedData[group][subGroup][sensor] = value;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Setze das gefüllte Objekt als msg.payload\nmsg.payload = groupedData;\nmsg.tentData = true\n// Entferne nicht benötigte Eigenschaften aus msg\ndelete msg.devices;\ndelete msg.entities;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1250,"y":400,"wires":[["47e4915877639ef5"]]},{"id":"cbd6c91073fd88a5","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DynamicRoomData","func":"// Erster Teil: Erstellen des `entities`-Objekts mit `area_id` und `name`\nconst entities = {};\n\nmsg.entities.forEach(e => {\n    // Überprüfe, ob entweder `device_id` gefüllt ist oder `area_id` gefüllt ist, aber `device_id` null ist\n    if (!e.device_id && e.area_id) {\n        const area = msg.areas.find(a => a.area_id === e.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    } else if (e.device_id) {\n        const device = msg.devices.find(d => d.id === e.device_id);\n        const area = msg.areas.find(a => a.area_id === device.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    }\n});\n\n// Erzeuge die nicht gruppierte Nachricht für den zweiten Output\nlet ungroupedOutput = { payload: entities, update: true };\n\n// Zweiter Teil: Gruppierung von `entities` nach `area_id` und `name`\nlet output = {};\n\nfor (let key in entities) {\n    let area_id = entities[key].area_id;\n    let entityName = entities[key].name;\n\n    // Falls der `area_id`-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id]) {\n        output[area_id] = {};\n    }\n\n    // Teile den Sensor-String in `name` und `type` auf\n    let [prefix, suffix] = key.split('.'); // Trenne bei Punkt, z.B. \"sensor.light_ip\"\n    let [name, type] = suffix.split('_'); // Trenne bei Unterstrich, z.B. \"light_ip\"\n\n    // Falls der Name-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id][name]) {\n        output[area_id][name] = {};\n    }\n\n    // Speichere den vollständigen Sensor-Schlüssel mit `null` als Wert\n    output[area_id][name][key] = null;\n}\n\n// Erzeugung von Nachrichten für jeden `area_id`-Bereich (erster Output)\nlet messages = [];\n\nfor (let area_id in output) {\n    if (output.hasOwnProperty(area_id)) {\n        // Erzeuge eine Nachricht für jede Gruppe mit `area_id` als `topic`\n        messages.push({\n            topic: area_id,\n            payload: output[area_id]\n        });\n    }\n}\n\n// Rückgabe der beiden Outputs: erster Output für die gruppierten Daten, zweiter für die ungruppierten\nreturn [messages, ungroupedOutput];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1250,"y":320,"wires":[["cfef77bffb098c25"],["10e3067fe685efa7"]]},{"id":"f918483e39cca146","type":"server-events","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"newEvent","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"state_changed","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":140,"y":600,"wires":[["002d11c9c357103a"]]},{"id":"ff31217e40ad4b05","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DynamicCombinedRoomData","func":"// Überprüfe, ob die Nachricht `AllData` ist und speichere sie im Kontext\nif (msg.topic === \"AllData\") {\n    context.set(\"AllData\", msg.payload);\n    node.status({ fill: \"green\", shape: \"dot\", text: \"AllData Loaded\", })\n    return null; // `AllData` wird nur gespeichert und nicht sofort ausgegeben\n}\n\n// Hole `AllData` aus dem Kontext\nlet allData = context.get(\"AllData\");\n\n// Wenn `AllData` noch nicht geladen ist, warte auf weitere Nachrichten\nif (!allData) {\n    node.warn(\"AllData noch nicht im Kontext vorhanden. Warte auf AllData.\");\n    node.status({fill:\"red\", shape: \"ring\", text: \"No Data Available\", })\n    return null;\n}\n\n// Kombiniere `AllData` mit der aktuellen Nachricht\nlet combinedData = {\n    AllData: allData,\n    [msg.topic]: msg.payload\n};\n\n// Setze das kombinierte Objekt als `msg.payload`\nmsg.payload = combinedData;\n\n// Gib die kombinierte Nachricht zurück\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1010,"y":400,"wires":[["1f613600601fde7a"]]},{"id":"002d11c9c357103a","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"SetArea","func":"if (msg.update) {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Area Data Loaded\" });\n    context.set(\"data\", msg.payload);\n    return;\n}\n\nconst data = context.get(\"data\");\n\nif (!data) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"No Area Data\" });\n    return;\n}\n\nconst area = data[msg.payload.entity_id];\nif (!area) return;\n\nmsg.area = area.name.toLowerCase();\n\n// Extrahiere `entity_id`, z.B. \"sensor.h5179_485d_temperature\"\nconst entity_id = msg.payload.entity_id;\n\n// Zerlege den `entity_id`-String, um den Gerätetyp zu extrahieren\nconst parts = entity_id.split('.')[1]; // Entfernt den Präfix (z.B., \"sensor.\")\nconst device = parts.split('_')[0]; // Entfernt den Suffix nach dem ersten Unterstrich\n\n// Extrahiere alten und neuen Zustand\nconst oldState = msg.payload.event.old_state?.state || null;\nconst newState = msg.payload.event.new_state?.state || null;\n\n// Überprüfe, ob alte und neue Zustände ignoriert werden sollen\n//const invalidStates = [\"NaN\",\"undefined\", \"unbekannt\",\"unavailable\", null];\nconst invalidStates = [\"NaN\",\"undefined\", null];\nif (invalidStates.includes(oldState) || invalidStates.includes(newState)) {\n    node.status({ fill: \"yellow\", shape: \"ring\", text: \"Invalid state, ignored\" });\n    return;\n}\n\n// Erstelle ein Objekt `updateData` für das Update\nconst updateData = {\n    room: msg.area,\n    device: device,\n    entity_id: entity_id,\n    oldState: oldState,\n    newState: newState\n};\n\nnode.status({ text: `Update for: ${msg.area}` });\nmsg.payload = updateData;\nmsg.update = true;\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":380,"y":600,"wires":[["2ab6344485625dcd","6bcddff9e4459ebe"]]},{"id":"43d31f16658453c9","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"devices","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/device_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"devices","propertyType":"msg","value":"","valueType":"results"}],"x":800,"y":320,"wires":[["830ae29ab82e7324"]]},{"id":"ec276734748d6829","type":"inject","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":290,"y":80,"wires":[["04f5f1cb8930332f"]]},{"id":"04f5f1cb8930332f","type":"function","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"ClearGlobals","func":"// Alle globalen Schlüssel abrufen\nconst keys = global.keys();\n\nif (keys.length === 0) {\n    node.warn(\"Keine globalen Variablen vorhanden, nichts zu löschen.\");\n    return null; // Keine Variablen zum Löschen\n}\n\n// Alle globalen Schlüssel löschen\nkeys.forEach(key => {\n    global.set(key, undefined); // Setzt den Schlüssel auf undefined, was ihn effektiv löscht\n    node.warn(`Globale Variable gelöscht: ${key}`);\n});\n\nnode.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: `Alle ${keys.length} globalen Variablen gelöscht`\n});\nmsg.topic = \"Init\"\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":430,"y":80,"wires":[["a57af3a5f16d2223"]]},{"id":"2ab6344485625dcd","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"CombinedUpdated_RoomData","func":"// Hole die gespeicherten Basisdaten aus dem globalen Speicher\nlet tentsData = global.get(\"tentsData\") || {};\n\n// Prüfen, ob die Nachricht ein Update enthält (msg.update = true)\nif (msg.update === true) {\n    const { room, device, entity_id, newState } = msg.payload;\n\n    // Validierung: Prüfen, ob alle benötigten Felder vorhanden sind\n    if (!room || !device || !entity_id || newState === undefined) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid update payload\" });\n        return null;\n    }\n\n    // Sicherstellen, dass der Raum in den Daten existiert\n    if (tentsData[room]?.[device]?.[entity_id] !== undefined) {\n        const oldValue = tentsData[room][device][entity_id];\n\n        // Aktualisieren, wenn der Wert unterschiedlich ist\n        if (oldValue !== newState) {\n            tentsData[room][device][entity_id] = newState;\n            node.status({ fill: \"green\", shape: \"dot\", text: `Updated: ${room} -> ${device} -> ${entity_id}` });\n        } else {\n            node.status({ fill: \"blue\", shape: \"ring\", text: `No change: ${room} -> ${device} -> ${entity_id}` });\n        }\n    } else {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: `Entity not found: ${room} -> ${device} -> ${entity_id}` });\n    }\n\n    // Setze den msg.topic auf den Raum-Namen\n    msg.topic = room;\n\n    // Gib nur den aktualisierten Raum zurück\n    msg.payload = { [room]: tentsData[room] };\n} else {\n    // Basisdaten speichern\n    const newTentsData = msg.payload;\n\n    // Räume in die globale Datenstruktur hinzufügen oder aktualisieren\n    Object.keys(newTentsData).forEach(room => {\n        if (!tentsData[room]) {\n            tentsData[room] = {};\n        }\n        Object.keys(newTentsData[room]).forEach(device => {\n            tentsData[room][device] = {\n                ...tentsData[room][device],\n                ...newTentsData[room][device]\n            };\n        });\n    });\n\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Base data updated\" });\n\n    // Setze den msg.topic auf \"all_rooms\"\n    msg.topic = \"all_rooms\";\n\n    // Gib die gesamte Struktur zurück\n    msg.payload = tentsData;\n}\n\n// Speichere die aktualisierten Daten im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":670,"y":600,"wires":[["3fb0e90d008a49cb"]]},{"id":"46fe411f25a067ab","type":"inject","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":150,"y":140,"wires":[["a57af3a5f16d2223"]]},{"id":"6fe72eaf1d2902f0","type":"link out","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"MasterLink","mode":"link","links":["02701e85ddace028","e9fc73b86d447581"],"x":1345,"y":600,"wires":[]},{"id":"4760488940785c7b","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"R-Manager","func":"// Hole aktuelle Räume aus Home Assistant\nconst currentAreas = msg.areas; // Räume von Home Assistant\nconst currentAreaIds = currentAreas.map(area => area.area_id.toLowerCase()); // IDs der aktuellen Räume\n\n// Hole gespeicherte Räume aus tentsData\nlet tentsData = global.get(\"tentsData\") || {};\nlet removedRooms = [];\n\n// Iteriere über gespeicherte Räume und entferne verwaiste\nfor (let roomName in tentsData) {\n    if (!currentAreaIds.includes(roomName)) {\n        // Raum aus tentsData entfernen\n        delete tentsData[roomName];\n        removedRooms.push(roomName);\n\n        // Globale Rauminstanz entfernen\n        global.set(roomName, null);\n    }\n}\n\n// Aktualisiere tentsData im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\n// Logge die entfernten Räume\nif (removedRooms.length > 0) {\n    node.warn(`Removed orphaned rooms: ${removedRooms.join(', ')}`);\n} else {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"No orphaned rooms found\" });\n}\n\n// Rückgabe der aktualisierten Daten\nmsg.payload = { removedRooms, remainingRooms: Object.keys(tentsData) };\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":750,"y":260,"wires":[[]]},{"id":"47e4915877639ef5","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"GroupFilledRoom","mode":"link","links":["d5304206f52a55b7"],"x":1375,"y":400,"wires":[]},{"id":"d5304206f52a55b7","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"link in 87","links":["47e4915877639ef5"],"x":505,"y":580,"wires":[["2ab6344485625dcd"]]},{"id":"10e3067fe685efa7","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"CollectedRooms","mode":"link","links":["d55ff9409b336801"],"x":1375,"y":340,"wires":[]},{"id":"d55ff9409b336801","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"link in 88","links":["10e3067fe685efa7"],"x":275,"y":580,"wires":[["002d11c9c357103a"]]},{"id":"cfef77bffb098c25","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DataNeededRoom","mode":"link","links":["21dd9af34945132e"],"x":1375,"y":300,"wires":[]},{"id":"21dd9af34945132e","type":"link in","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DataNeededRoom","links":["cfef77bffb098c25"],"x":855,"y":420,"wires":[["ff31217e40ad4b05"]]},{"id":"40afa2a7ef46e38a","type":"function","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"OpenGrowBox","func":"class OpenGrowBox {\n    constructor(tentName = \"\", plantStage = \"\", tentMode = \"\", perfectionTolerance = 0.025) {\n\n        // Tent Environment        \n        this.tentName = tentName;\n        this.tentMode = tentMode;\n        this.plantStage = plantStage;\n        this.controlSet = \"\";\n\n        this.devices = [];\n        this.ownDeviceList = []\n        \n        this.needchange = false\n        this.previousActions = [];\n        this.previousPIDActions = [];\n        \n        this.controls = {\n            pidControl: false,\n            ownWeights: false,\n            weights: {\n                temp: null,\n                hum: null,\n                defaultValue:1,\n            },\n            co2Control: false,\n            co2ppm: {\n                minPPM: 400,\n                maxPPM: 1200,\n            },\n            ownDeviceSetup: false,\n            experimental: false,\n            modes: {\n                vpdPerfection: \"VPD Perfection\",\n                inRangeVPD: \"IN-VPD-Range\",\n                targetedVDP: \"Targeted VPD\",\n                drying: \"Drying\",\n                experimentel: \"Experimentel\",\n                disabled: \"Disabled\"\n            }\n        }\n\n        this.expMods = {\n            current: \"\",\n            plantType: \"\",\n        }\n\n        this.isPlantDay = {\n            nightVPDHold: false,\n            lightOn: false,\n            lightOnTime: \"\",\n            lightOffTime: \"\",\n            lightbyOGBControl: false,\n            sunRiseTimes: \"\",\n            sunSetTimes: \"\",\n        }\n\n        this.enviorment = {\n            ambientTemp: 0.0,\n            ambientHumidity: 0.0,\n            ambientDewpoint: 0.0,\n            outsiteTemp: 0.0,\n            outsiteHumidity: 0.0,\n            outsiteDewpoint: 0.0,\n        };\n\n        this.tentData = {\n            temperature: null,\n            humidity: null,\n            leafTempOffset: 0,\n            dewpoint: 0.0,\n            maxTemp: 0,\n            minTemp: 0,\n            maxHumidity: 0,\n            minHumidity: 0,\n            co2Level: 400,\n        };\n\n        this.plantStages = {\n            Germination: { vpdRange: [0.412, 0.7], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            Clones: { vpdRange: [0.42, 0.75], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            EarlyVeg: { vpdRange: [0.7, 0.85], minTemp: 20, maxTemp: 28, minHumidity: 55, maxHumidity: 70 },\n            MidVeg: { vpdRange: [0.85, 1.1], minTemp: 20, maxTemp: 30, minHumidity: 50, maxHumidity: 65 },\n            LateVeg: { vpdRange: [0.933, 1.2], minTemp: 20, maxTemp: 30, minHumidity: 50, maxHumidity: 60 },\n            EarlyFlower: { vpdRange: [1.0, 1.25], minTemp: 22, maxTemp: 28, minHumidity: 45, maxHumidity: 60 },\n            MidFlower: { vpdRange: [1.1, 1.4], minTemp: 22, maxTemp: 26, minHumidity: 40, maxHumidity: 55 },\n            LateFlower: { vpdRange: [1.3, 1.7], minTemp: 20, maxTemp: 24, minHumidity: 40, maxHumidity: 50 }\n        };\n\n        this.vpd = {\n            current: null,\n            // RANGE VPD\n            range: [],\n            rangeTolerance: 0.0,\n            diffRange: null,\n            // VPD PERFECTION\n            perfection: 0.0,\n            perfectMin: 0.0,\n            perfectMax: 0.0,\n            perfectTolerance: perfectionTolerance,\n            diffPerfection: null,\n            // TARGETED VPD\n            targeted: 0.0,\n            targetedTolerance: 0.0,\n            diffTargeted: null,\n            ecotarget: [0.55, 0.88],\n            lightControl:false,\n        };\n\n        this.watering = {\n            autoWatering: false,\n            isRunning: false,\n            pumpInvervall: \"\",\n            pumpTime: \"\",\n            nextPumpAction: \"\",\n            waterTemp: 0,\n            nutrients: {\n                PH: 0,\n                PPM: 0,\n                EC: 0,\n                Temp: 0,\n                N: 0,\n                P: 0,\n                K: 0,\n            }\n        }\n\n        this.dryStartTime = null;\n        this.drying = {\n            currentDryMode: \"\",\n            isEnabled: false,\n            isRunning: false,\n            waterActivity: 0.0,\n            dewpointVPD: 0.0,\n            vaporPressureActual: 0.0,\n            vaporPressureSaturation: 0.0,\n            sharkMouseVPD: 0.0,\n            modes: {\n                elClassico: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetHumidity: 62, durationHours: 72\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetHumidity: 60, durationHours: 72\n                        },\n                        endTime: {\n                            targetTemp: 20, targetHumidity: 58, durationHours: 72\n                        }\n                    }\n                },\n                SharkMouse: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 22.2, targetHumidity: 55, targetVPD: 1.2, durationHours: 48\n                        },\n                        halfTime: {\n                            maxTemp: 23.3, targetHumidity: 52, targetVPD: 1.39, durationHours: 24\n                        },\n                        endTime: {\n                            maxTemp: 23.9, targetHumidity: 50, targetVPD: 1.5, durationHours: 48\n                        }\n                    }\n                },\n                dewBased: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetDewPoint: 12.25, durationHours: 96\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 96\n                        },\n                        endTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 48\n                        }\n                    }\n                }\n            }\n\n        }\n\n        this.addons = {\n            GasLanternRoutine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnPhase: 8,\n                        LightOffPhase: 16,\n                    },\n                    Indica: {\n                        LightOnPhase: 6,\n                        LightOffPhase: 18,\n                    }\n                }\n            },\n            GLR_NaturalSunshine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 8,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    },\n                    Indica: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 6,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    }\n                }\n            }\n        }\n\n        //Actions\n        this.actions = {\n            Increased: {\n                exhaust: \"increased\",\n                humidifier: \"reduced\",\n                dehumidifier: \"increased\",\n                heater: \"increased\",\n                cooler: \"reduced\",\n                ventilation: \"increased\",\n                light: this.vpd.lightControl ? \"increased\" : \"unchanged\",\n                co2: \"increased\",\n                climate: {\n                    cool: \"reduced\",\n                    dry: \"increased\",\n                    heat: \"unchanged\",\n                }\n            },\n            Reduced: {\n                exhaust: \"reduced\",\n                humidifier: \"increased\",\n                dehumidifier: \"reduced\",\n                heater: \"reduced\",\n                cooler: \"increased\",\n                ventilation: \"reduced\",\n                light: this.vpd.lightControl ? \"reduced\" : \"unchanged\",\n                co2: \"reduced\",\n                climate: {\n                    cool: \"increased\",\n                    dry: \"reduced\",\n                    heat: \"reduced\",\n                }\n            },\n            Unchanged: {\n                exhaust: \"unchanged\",\n                humidifier: \"unchanged\",\n                dehumidifier: \"unchanged\",\n                heater: \"unchanged\",\n                cooler: \"unchanged\",\n                ventilation: \"unchanged\",\n                light: \"unchanged\",\n                climate: {\n                    cool: \"unchanged\",\n                    dry: \"unchanged\",\n                    heat: \"unchanged\"\n                }\n            },\n        }\n        this.PIDAdjustments = {}\n        this.pid = {\n            temp:{\n                proportionalFaktor: 0.1,\n                integralFaktor: 0.01,\n                derivativFaktor: 0.1,\n            },\n            hum:{\n                proportionalFaktor: 5.0,\n                integralFaktor: 0.02,\n                derivativFaktor: 0.1,\n            },\n            vpd:{\n                proportionalFaktor: 5.0,\n                integralFaktor: 0.05,\n                derivativFaktor: 0.5,\n            },\n            co2:{\n                proportionalFaktor: 10.0,\n                integralFaktor: 0.1,\n                derivativFaktor: 0.1,\n            }\n\n        }\n\n        this.init();\n    }\n\n    init() {\n        this.initPIDControllers()\n    }\n\n    initPIDControllers() {\n        console.log(\"Initialisiere PID-Controller mit Werten:\");\n        console.log(`Temp Min: ${this.tentData.minTemp}, Temp Max: ${this.tentData.maxTemp}`);\n        console.log(`VPD Min: ${this.getVPDRangeForMode().minVPD}, VPD Max: ${this.getVPDRangeForMode().maxVPD}`);\n\n        this.tempPID = new OGBPIDController(\n            \"tempPID\",\n            parseFloat(this.pid.temp.proportionalFaktor),\n            parseFloat(this.pid.temp.integralFaktor),\n            parseFloat(this.pid.temp.derivativFaktor),\n            parseFloat(this.tentData.minTemp),\n            parseFloat(this.tentData.maxTemp),            \n        );\n\n        this.humPID = new OGBPIDController(\n            \"humPID\",\n            parseFloat(this.pid.hum.proportionalFaktor),\n            parseFloat(this.pid.hum.integralFaktor),\n            parseFloat(this.pid.hum.derivativFaktor),\n            parseFloat(this.tentData.minHumidity),\n            parseFloat(this.tentData.maxHumidity),\n        );\n\n        const { minVPD, maxVPD } = this.getVPDRangeForMode();\n\n        this.vpdPID = new OGBPIDController(\n            \"vpdPID\",\n            parseFloat(this.pid.vpd.proportionalFaktor),\n            parseFloat(this.pid.vpd.integralFaktor),\n            parseFloat(this.pid.vpd.derivativFaktor),\n            parseFloat(minVPD),\n            parseFloat(maxVPD),\n        );\n        this.co2PID = new OGBPIDController(\n            \"co2PID\",\n            parseFloat(this.pid.co2.proportionalFaktor),\n            parseFloat(this.pid.co2.integralFaktor),\n            parseFloat(this.pid.co2.derivativFaktor),\n            parseFloat(this.controls.co2ppm.minPPM),\n            parseFloat(this.controls.co2ppm.maxPPM),  \n        )\n\n        console.log(\"PID-Controller erfolgreich initialisiert.\");\n    }\n\n    updatePIDControllers() {\n        // Dynamische Min- und Max-Werte für VPD basierend auf dem Modus\n        const { minVPD, maxVPD } = this.getVPDRangeForMode();\n\n        // Temperatur-PID aktualisieren\n        this.tempPID.minValue = this.tentData.minTemp;\n        this.tempPID.maxValue = this.tentData.maxTemp;\n        this.tempPID.integral = 0; // Reset Integral\n        this.tempPID.prevError = 0; // Reset Fehler\n\n        // Feuchtigkeits-PID aktualisieren\n        this.humPID.minValue = this.tentData.minHumidity;\n        this.humPID.maxValue = this.tentData.maxHumidity;\n        this.humPID.integral = 0; // Reset Integral\n        this.humPID.prevError = 0; // Reset Fehler\n\n        // VPD-PID aktualisieren\n        this.vpdPID.minValue = minVPD;\n        this.vpdPID.maxValue = maxVPD;\n        this.vpdPID.integral = 0; // Reset Integral\n        this.vpdPID.prevError = 0; // Reset Fehler\n\n        console.log(\"PID-Controller wurden aktualisiert mit neuen Werten.\");\n    }\n\n    generateActionsFromPID(tempAdjustment, humAdjustment, vpdAdjustment, lightVPDControl) {\n        const actions = {\n            exhaust: \"unchanged\",\n            humidifier: \"unchanged\",\n            dehumidifier: \"unchanged\",\n            heater: \"unchanged\",\n            cooler: \"unchanged\",\n            ventilation: \"unchanged\",\n            light: \"unchanged\",\n            climate: {\n                cool: \"unchanged\",\n                heat: \"unchanged\",\n                dry: \"unchanged\",\n            },\n        };\n\n        // Temperaturaktionen\n        if (tempAdjustment > 0) {\n            actions.heater = \"reduced\";\n            actions.cooler = \"increased\";\n            actions.climate.cool = \"increased\";\n            actions.climate.heat = \"reduced\";\n        } else if (tempAdjustment < 0) {\n            actions.climate.heat = \"increased\";\n            actions.climate.cool = \"reduced\"; \n            actions.cooler = \"reduced\";\n            actions.heater = \"increased\";\n        } else {\n            actions.cooler = \"unchanged\";\n            actions.heater = \"unchanged\";\n            actions.climate.cool = \"unchanged\";\n            actions.climate.heat = \"unchanged\";\n        }\n\n        // Feuchtigkeitsaktionen\n        if (humAdjustment > 0) {\n            actions.dehumidifier = \"increased\";\n            actions.climate.dry = \"increased\";\n            actions.humidifier = \"reduced\";\n        } else if (humAdjustment < 0) {\n            actions.humidifier = \"increased\";\n            actions.climate.dry = \"reduced\";\n            actions.dehumidifier = \"reduced\";\n        } else {\n            actions.dehumidifier = \"unchanged\";\n            actions.humidifier = \"unchanged\";\n            actions.climate.dry = \"unchanged\";\n        }\n\n        // VPD-Aktionen\n        if (vpdAdjustment > 0) {\n            actions.exhaust = \"increased\";\n            actions.ventilation = \"increased\";\n            actions.dehumidifier = \"reduced\";\n        } else if (vpdAdjustment < 0) {\n            actions.exhaust = \"reduced\";\n            actions.ventilation = \"reduced\";\n            actions.humidifier = \"increased\";\n        } else {\n            actions.exhaust = \"unchanged\";\n            actions.ventilation = \"unchanged\";\n        }\n\n        // Lichtsteuerung basierend auf VPD-Control\n        if (lightVPDControl) {\n            if (vpdAdjustment > 0) {\n                actions.light = \"reduced\";\n            } else if (vpdAdjustment < 0) {\n                actions.light = \"increased\";\n            } else {\n                actions.light = \"unchanged\";\n            }\n        } else {\n            actions.light = \"unchanged\"; // Kein VPD-Kontrollmodus aktiv\n        }\n\n        return actions;\n    }\n\n    getVPDRangeForMode() {\n            let minVPD, maxVPD;\n\n            switch (this.tentMode) {\n                case \"IN-VPD-Range\":\n                    // Nutzt die rangeVPD-Werte\n                    minVPD = this.vpd.range[0];\n                    maxVPD = this.vpd.range[1];\n                    break;\n\n                case \"VPD Perfection\":\n                    // Nutzt die perfekt min und perfekt max Werte\n                    minVPD = this.vpd.perfectMin;\n                    maxVPD = this.vpd.perfectMax;\n                    break;\n\n                case \"Targeted VPD\":\n                    // Nutzt die targeted Tolerance für Min und Max\n                    minVPD = this.vpd.targeted - this.vpd.targetedTolerance;\n                    maxVPD = this.vpd.targeted + this.vpd.targetedTolerance;\n                    break;\n\n                default:\n                    // Fallback: Nutzt Standardwerte\n                    minVPD = this.vpd.range[0];\n                    maxVPD = this.vpd.range[1];\n                    break;\n            }\n\n            return { minVPD, maxVPD };\n    }\n\n    checkCurrentVPD() {\n        const { minVPD, maxVPD } = this.getVPDRangeForMode();\n\n        if (this.vpd.current < minVPD) {\n            console.log(`VPD zu niedrig: ${this.vpd.current} < ${minVPD}`);\n            return \"increased\";\n        } else if (this.vpd.current > maxVPD) {\n            console.log(`VPD zu hoch: ${this.vpd.current} > ${maxVPD}`);\n            return \"reduced\";\n        } else {\n            console.log(`VPD innerhalb des Bereichs: ${minVPD} <= ${this.vpd.current} <= ${maxVPD}`);\n            return \"unchanged\";\n        }\n    }\n\n    adjustDevices(vpdAdjustment, tempAdjustment, humAdjustment, lightVPDControl) {\n        // Generiere Aktionen basierend auf PID\n        const actions = this.generateActionsFromPID(tempAdjustment, humAdjustment, vpdAdjustment, lightVPDControl);\n\n        // Aktionen für alle Geräte sammeln\n        const allActions = [];\n\n        this.devices.forEach((device) => {\n            if (device.deviceType in actions) {\n                const deviceAction = {\n                    device: device.name,\n                    type: device.deviceType,\n                    action: actions[device.deviceType],\n                };\n                allActions.push(deviceAction);\n            }\n\n            // Spezielle Behandlung für \"climate\" Subtypen (cool, heat, dry)\n            if (device.deviceType === \"climate\" && device.deviceSubtype in actions.climate) {\n                const climateAction = {\n                    device: device.name,\n                    type: `climate.${device.deviceSubtype}`,\n                    action: actions.climate[device.deviceSubtype],\n                };\n                allActions.push(climateAction);\n            }\n        });\n\n        return allActions;\n    }\n\n    increaseCooling(adjustment) {\n        const cooler = this.devices.find(device => device.deviceType === \"cooler\");\n        if (cooler) {\n            cooler.action = \"increased\";\n            node.warn(`Cooling increased by ${adjustment}`);\n            return { device: cooler.name, action: \"increased\", adjustment };\n        }\n    }\n\n    increaseHeating(adjustment) {\n        const heater = this.devices.find(device => device.deviceType === \"heater\");\n        if (heater) {\n            heater.action = \"increased\";\n            node.warn(`Heating increased by ${adjustment}`);\n            return { device: heater.name, action: \"increased\", adjustment};\n        }\n    }\n\n    increaseDehumidifying(adjustment) {\n        const dehumidifier = this.devices.find(device => device.deviceType === \"dehumidifier\");\n        if (dehumidifier) {\n            dehumidifier.action = \"increased\";\n            node.warn(`Dehumidifying increased by ${adjustment}`);\n            return { device: dehumidifier.name, action: \"increased\", adjustment};\n        }\n    }\n\n    increaseHumidifying(adjustment) {\n        const humidifier = this.devices.find(device => device.deviceType === \"humidifier\");\n        if (humidifier) {\n            humidifier.action = \"increased\";\n            node.warn(`Humidifying increased by ${adjustment}`);\n            return { device: humidifier.name, action: \"increased\", adjustment};\n        }\n    }\n\n    // Setze PID COntroll / default deaktivert\n    setPIDControl(pidControl) {\n        if (pidControl !== this.controls.pidControl) {\n            this.controls.pidControl = this.helperYesTrue(pidControl);\n            if(this.controls.pidControl){\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    // aktuler pid control\n    getPIDControl() {\n        return this.helperYesTrue(this.controls.pidControl)\n    }\n\n    // PID VPD\n    setProportionalVPDFactor(vpdFactor) {\n        if (vpdFactor !== undefined && vpdFactor !== null) {\n            if (parseFloat(vpdFactor) !== this.pid.vpd.proportionalFaktor) {\n                this.pid.vpd.proportionalFaktor = parseFloat(vpdFactor);\n                node.warn(`VPD-Proportionalfaktor gesetzt auf: ${this.pid.vpd.proportionalFaktor}`);\n                this.vpdPID.updateProportional(this.pid.vpd.proportionalFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getProportionalVPDFactor() {\n        return this.pid.vpd.proportionalFaktor;\n    }\n\n    setIntegralVPDFactor(vpdFactor) {\n        if (vpdFactor !== undefined && vpdFactor !== null) {\n            if (parseFloat(vpdFactor) !== this.pid.vpd.integralFaktor) {\n                this.pid.vpd.integralFaktor = parseFloat(vpdFactor);\n                node.warn(`VPD-Integralfaktor gesetzt auf: ${this.pid.vpd.integralFaktor}`);\n                this.vpdPID.updateIntegral(this.pid.vpd.integralFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getIntegralVPDFactor() {\n        return this.pid.vpd.integralFaktor;\n    }\n\n    setDerivativVPDFactor(vpdFactor) {\n        if (vpdFactor !== undefined && vpdFactor !== null) {\n            if (parseFloat(vpdFactor) !== this.pid.vpd.derivativFaktor) {\n                this.pid.vpd.derivativFaktor = parseFloat(vpdFactor);\n                node.warn(`VPD-Derivativfaktor gesetzt auf: ${this.pid.vpd.derivativFaktor}`);\n                this.vpdPID.updateDerivative(this.pid.vpd.derivativFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getDerivativVPDFactor() {\n        return this.pid.vpd.derivativFaktor;\n    }\n\n    // P.I.D Temp\n    setProportionalTempFactor(tempFactor) {\n        if (tempFactor !== undefined && tempFactor !== null) {\n            if (parseFloat(tempFactor) !== this.pid.temp.proportionalFaktor) {\n                this.pid.temp.proportionalFaktor = parseFloat(tempFactor);\n                node.warn(`Temperatur-Proportionalfaktor gesetzt auf: ${this.pid.temp.proportionalFaktor}`);\n                this.tempPID.updateProportional(this.pid.temp.proportionalFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getProportionalTempFactor() {\n        return this.pid.temp.proportionalFaktor;\n    }\n\n    setIntegralTempFactor(tempFactor) {\n        if (tempFactor !== undefined && tempFactor !== null) {\n            if (parseFloat(tempFactor) !== this.pid.temp.integralFaktor) {\n                this.pid.temp.integralFaktor = parseFloat(tempFactor);\n                node.warn(`Temperatur-Integralfaktor gesetzt auf: ${this.pid.temp.integralFaktor}`);\n                this.tempPID.updateIntegral(this.pid.temp.integralFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getIntegralTempFactor() {\n        return this.pid.temp.integralFaktor;\n    }\n\n    setDerivativTempFactor(tempFactor) {\n        if (tempFactor !== undefined && tempFactor !== null) {\n            if (parseFloat(tempFactor) !== this.pid.temp.derivativFaktor) {\n                this.pid.temp.derivativFaktor = parseFloat(tempFactor);\n                node.warn(`Temperatur-Derivativfaktor gesetzt auf: ${this.pid.temp.derivativFaktor}`);\n                this.tempPID.updateDerivative(this.pid.temp.derivativFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getDerivativTempFactor() {\n        return this.pid.temp.derivativFaktor;\n    }\n\n    // P.I.D Humidity\n    setProportionalHumidityFactor(humidityFactor) {\n        if (humidityFactor !== undefined && humidityFactor !== null) {\n            if (parseFloat(humidityFactor) !== this.pid.hum.proportionalFaktor) {\n                this.pid.hum.proportionalFaktor = parseFloat(humidityFactor);\n                node.warn(`Feuchtigkeits-Proportionalfaktor gesetzt auf: ${this.pid.hum.proportionalFaktor}`);\n                this.humPID.updateProportional(this.pid.hum.proportionalFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getProportionalHumidityFactor() {\n        return this.pid.hum.proportionalFaktor;\n    }\n\n    setIntegralHumidityFactor(humidityFactor) {\n        if (humidityFactor !== undefined && humidityFactor !== null) {\n            if (parseFloat(humidityFactor) !== this.pid.hum.integralFaktor) {\n                this.pid.hum.integralFaktor = parseFloat(humidityFactor);\n                node.warn(`Feuchtigkeits-Integralfaktor gesetzt auf: ${this.pid.hum.integralFaktor}`);\n                this.humPID.updateIntegral(this.pid.hum.integralFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getIntegralHumidityFactor() {\n        return this.pid.hum.integralFaktor;\n    }\n\n    setDerivativHumidityFactor(humidityFactor) {\n        if (humidityFactor !== undefined && humidityFactor !== null) {\n            if (parseFloat(humidityFactor) !== this.pid.hum.derivativFaktor) {\n                this.pid.hum.derivativFaktor = parseFloat(humidityFactor);\n                node.warn(`Feuchtigkeits-Derivativfaktor gesetzt auf: ${this.pid.hum.derivativFaktor}`);\n                this.humPID.updateDerivative(this.pid.hum.derivativFaktor)\n                this.updatePIDControllers();\n            }\n        }\n    }\n\n    getDerivativHumidityFactor() {\n        return this.pid.hum.derivativFaktor;\n    }\n\n    // DATA SETTER/GETTER ******************************\n    setTentName(tentName = \"\") {\n        if (tentName !== this.tentName) {\n            this.tentName = tentName;\n        }\n\n    }\n\n    // Setze ob Ausleih funktion für Ambient aktiv ist. \n    setControlSet(controlSet) {\n        if (this.controlSet !== controlSet) {\n            this.controlSet = controlSet\n        }\n    }\n\n    // erhalte ob Ambient Steuerung aktiv ist.\n    getControlSet() {\n        return this.controlSet\n    }\n\n    // Setze Aktiven ZeltMode\n    setTentMode(tentMode = \"\") {\n        if (this.tentMode !== tentMode) {\n            console.warn(`TentMode geändert von ${this.tentMode} auf ${tentMode} in ${this.tentName}`);\n\n            if (tentMode !== \"Drying\") {\n                this.drying.isRunning = false;\n                this.drying.isEnabled = false;\n                this.drying.currentDryMode = \"\";\n                this.dryStartTime = null;\n                console.warn(\"Drying-Modus deaktiviert und Timer zurückgesetzt.\");\n            }\n\n            this.tentMode = tentMode;\n\n            // PID-Controller aktualisieren\n            this.updatePIDControllers();\n        }\n    }\n\n    getTentMode() {\n        return this.tentMode\n    }\n\n    // Setze Targeted VPD wenn Mode aktiv!\n    setTargetedVPD(targetVPD) {\n        if (targetVPD !== this.vpd.targeted) {\n            if (this.tentMode === \"Targeted VPD\") {\n                this.vpd.targeted = parseFloat(targetVPD)\n            }\n        }\n    }\n\n    // Ehalte Targeted VPD wenn Mode aktiv!\n    getTargetedVPD() {\n        return parseFloat(this.vpd.targeted);\n    }\n\n    // Setze Plant Stage\n    setPlantStageValue(plantStage = \"\") {\n        if (this.plantStages.hasOwnProperty(plantStage)) {\n            const stage = this.plantStages[plantStage];\n            this.vpd.range = stage.vpdRange;\n            this.tentData.maxTemp = stage.maxTemp;\n            this.tentData.minTemp = stage.minTemp;\n            this.tentData.maxHumidity = stage.maxHumidity;\n            this.tentData.minHumidity = stage.minHumidity;\n            this.calculatePerfectVPD();\n            this.plantStage = plantStage;\n\n            // PID-Controller aktualisieren\n            this.updatePIDControllers();\n        } else {\n            console.warn(`Ungültige PlantStage: ${plantStage}`);\n        }\n    }\n\n    getPlantStageValue() {\n        return this.plantStage\n    }\n\n    // Setze aktuelle Temp\n    setCurrentTemp(temp) {\n        let newTemp = null;\n\n        // Überprüfen, ob temp ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(temp)) {\n            newTemp = parseFloat(this.calculateAvgValue(temp));\n        } else if (typeof temp === 'number') {\n            newTemp = temp;\n        } else if (typeof temp === 'string') {\n            newTemp = parseFloat(temp);\n        } else {\n            throw new Error(\"Invalid temperature data. Must be an array, number, or string.\");\n        }\n\n        if (newTemp === this.tentData.temperature) return;\n\n        this.tentData.temperature = newTemp;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Blatt Temp Offset\n    setLeafOffset(offset) {\n        if (parseFloat(offset) !== parseFloat(this.tentData.leafTempOffset)) {\n            this.tentData.leafTempOffset = parseFloat(offset)\n        }\n    }\n\n    getLeafOffset() {\n        return this.tentData.leafTempOffset\n    }\n\n    // Setze aktuelle Feuchtigkeit\n    setCurrentHumidity(humidity) {\n        let newHumidity = null;\n\n        // Überprüfen, ob humidity ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(humidity)) {\n            newHumidity = parseFloat(this.calculateAvgValue(humidity));\n        } else if (typeof humidity === 'number') {\n            newHumidity = humidity;\n        } else if (typeof humidity === 'string') {\n            newHumidity = parseFloat(humidity);\n        } else {\n            throw new Error(\"Invalid humidity data. Must be an array, number, or string.\");\n        }\n\n        if (newHumidity === this.tentData.humidity) return;\n\n        this.tentData.humidity = newHumidity;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Ambient Raum Daten (WO DAS ZELT STEHT!!!!)\n    setAmbientData(ambTemp, ambHum, ambDew = null) {\n        // Exit if any value is null\n        if (ambTemp === null || ambHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = ambDew !== null ? ambDew : this.calculateDewPoint(ambTemp, ambHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.ambientTemp !== ambTemp ||\n            this.enviorment.ambientHumidity !== ambHum ||\n            this.enviorment.ambientDewpoint !== dewpoint\n        ) {\n            this.enviorment.ambientTemp = ambTemp;\n            this.enviorment.ambientHumidity = ambHum;\n            this.enviorment.ambientDewpoint = dewpoint;\n        }\n    }\n\n    // Setze Temp von Außen \n    setOutsiteData(outTemp, outHum, outDew = null) {\n        // Exit if any value is null\n        if (outTemp === null || outHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = outDew !== null ? outDew : this.calculateDewPoint(outTemp, outHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.outsiteTemp !== outTemp ||\n            this.enviorment.outsiteHumidity !== outHum ||\n            this.enviorment.outsiteDewpoint !== dewpoint\n        ) {\n            this.enviorment.outsiteTemp = outTemp;\n            this.enviorment.outsiteHumidity = outHum;\n            this.enviorment.outsiteDewpoint = dewpoint;\n        }\n    }\n\n    // Setze aktuellen Dewpoint\n    setCurrentDewPoint(dewpoint) {\n        if (dewpoint !== this.tentData.dewpoint) {\n            this.tentData.dewpoint = this.calculateDewPoint(dewpoint)\n        }\n    }\n\n    // Aktiviere Nacht VPD Ignoranz\n    setVPDNightHold(nightHold) {\n        if (nightHold != this.helperYesTrue(this.isPlantDay.nightVPDHold)) {\n            this.isPlantDay.nightVPDHold = this.helperYesTrue(nightHold)\n        }\n    }\n\n    getVPDNightHold() {\n        return this.helperYesTrue(this.isPlantDay.nightVPDHold)\n    }\n\n    // Aktiviere Gewicht für Feinjustierung\n    activateOwnWeights(activ) {\n        if (activ !== this.controls.ownWeights) {\n            this.controls.ownWeights = this.helperYesTrue(activ)\n            if (!this.controls.ownWeights) {\n                this.controls.weights.temp = null\n                this.controls.weights.hum = null\n            }\n        }\n    }\n\n    // Erhatel Gewicht Aktivi Status\n    getifOwnWeightsActive() {\n        return this.helperYesTrue(this.controls.ownWeights)\n    }\n\n    // Setze Gewicht für Feinjustierung\n    setOwnWeights(name, weight) {\n        if (!this.controls.ownWeights) {\n            // Wenn `ownWeights` deaktiviert oder nicht definiert ist\n            if (!this.controls.ownWeights) {\n                return { ownWeights: \"Disabled\" }; // Gebe zurück, dass `ownWeights` deaktiviert ist\n            }\n            // Falls `ownWeights` undefined oder nicht initialisiert ist\n            this.controls.ownWeights = null;\n            return { ownWeights: \"Disabled\" };\n        } else {\n            // Wenn `ownWeights` aktiviert ist\n            if (name.includes(\"hum\")) {\n                // Feuchtigkeitsgewicht setzen\n                this.controls.weights.hum = parseFloat(weight);\n            } else if (name.includes(\"temp\")) {\n                // Temperaturgewicht setzen\n                this.controls.weights.temp = parseFloat(weight);\n            } else {\n                // Ungültiger Name\n                console.warn(`Unrecognized weight type: ${name}`);\n                return { error: `Invalid weight type: ${name}` };\n            }\n\n            return { ownWeights: \"Enabled\" }; // Gebe zurück, dass `ownWeights` aktiviert ist\n        }\n    }\n\n    // Erhalte Gewicht für Feinjustierung\n    getOwnWeights() {\n        if (this.controls.ownWeights) {\n            return { tempWeight: this.controls.weights.temp, humWweight: this.controls.weights.hum }\n        } else {\n            return { Data: \"NotNeeded\" }\n        }\n    }\n\n    // EXPRIMENTEL\n    setGLSControl(glscControl) {\n        if (glscControl !== this.controls.experimental) {\n            this.controls.experimental = this.helperYesTrue(glscControl)\n        }\n    }\n\n    // EXPRIMENTEL\n    getGLSControl() {\n        return this.helperYesTrue(this.controls.experimental)\n    }\n\n    // EXPRIMENTEL\n    setGLSPlantType(plantType) {\n        if (this.controls.experimental) {\n            if (plantType !== this.controls.experimental) {\n                this.expMods.plantType = plantType\n            }\n        } else {\n            if (this.expMods.plantType != \"\") {\n                this.expMods.plantType = \"\"\n\n            }\n\n        }\n\n    }\n    // EXPRIMENTEL\n    // EXPRIMENTEL\n    getGLSPlantType() {\n        return this.expMods.plantType\n    }\n\n    // EXPRIMENTEL\n\n\n    // Aktiviere CO2 Steuerung\n    setCO2Control(co2Control) {\n        if (co2Control !== this.controls.co2Control) {\n            this.controls.co2Control = this.helperYesTrue(co2Control)\n        }\n    }\n\n    // COS Status\n    getCO2Control() {\n        return this.helperYesTrue(this.controls.co2Control)\n    }\n\n    // Aktiviere Kontorlle für Licht\n    setLightControlByOGB(wantsControl) {\n        if (wantsControl !== this.isPlantDay.lightbyOGBControl) {\n            this.isPlantDay.lightbyOGBControl = this.helperYesTrue(wantsControl)\n        }\n    }\n\n    // Licht Controll Status\n    getLightControlByOGB() {\n        return this.helperYesTrue(this.isPlantDay.lightbyOGBControl)\n    }\n\n    // LICHT steuerung mit VPD //DEFAULT AUS\n    setVPDLightControl(lightControl) {\n        if (lightControl !== this.vpd.lightControl) {\n            this.vpd.lightControl = this.helperYesTrue(lightControl);\n\n            // Trigger: Update des Lichtstatus\n            this.evaluateLightVPDControl();\n        }\n    }\n    // AKTULER CONTROLLE STATUS\n    getVPDLightControl(){\n        return this.helperYesTrue(this.vpd.lightControl)  \n    }\n\n    // Setze lichtzeiten wenn Kontrolle AKTIV \n    setLightTimes(startTime = \"\", endTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (startTime !== this.isPlantDay.lightOnTime || endTime !== this.isPlantDay.lightOffTime) {\n            this.isPlantDay.lightOnTime = startTime;\n            this.isPlantDay.lightOffTime = endTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${startTime}, Ende: ${endTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setLightTimes(startTime, endTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n\n            this.updateLightState(); // Aktualisiere den Lichtstatus\n        }\n    }\n\n    // Setze Sonnen Auf/Untergang \n    setSunTimes(sunRiseTime = \"\", sunSetTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (sunRiseTime !== this.isPlantDay.sunRiseTimes || sunSetTime !== this.isPlantDay.sunSetTimes) {\n            this.isPlantDay.sunRiseTimes = sunRiseTime;\n            this.isPlantDay.sunSetTimes = sunSetTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${sunRiseTime}, Ende: ${sunSetTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setSunTimes(sunRiseTime, sunSetTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n        }\n    }\n\n    // HELPERS ******************************\n    helperYesTrue(input) {\n        if (typeof input === \"string\") {\n            // Convert string to boolean\n            const upperInput = input.toUpperCase(); // Normalize case\n            if (upperInput === \"YES\") return true;\n            if (upperInput === \"NO\") return false;\n        } else if (typeof input === \"boolean\") {\n            // Convert boolean to string\n            return input ? \"YES\" : \"NO\";\n        }\n        // Handle invalid input\n        throw new Error(\"Invalid input: expected a string ('YES'/'NO') or boolean (true/false).\");\n    }\n\n    evaluateLightVPDControl() {\n        // Prüfen, ob Licht an oder aus ist\n        const vpdLightControl = this.vpd.lightControl;\n\n        // Status basierend auf Lichtbedingung setzen\n        if (vpdLightControl) {\n            this.actions.Increased.light = \"increased\";\n            this.actions.Reduced.light = \"reduced\";\n        } else {\n            this.actions.Reduced.light = \"unchanged\"; \n            this.actions.Increased.light = \"unchanged\"; \n        }\n    }\n    \n    // Aktualisierung des Lichtstatus basierend auf der aktuellen Zeit\n    updateLightState(currentTime = new Date()) {\n        // Hole die aktuelle Zeit in Sekunden\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        // Konvertiere Lichtzeiten in Sekunden\n        const lightOnSeconds = this.parseTime(this.isPlantDay.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.isPlantDay.lightOffTime);\n\n        let lightOn;\n\n        if (lightOffSeconds < lightOnSeconds) {\n            // Lichtzyklus über Mitternacht: Licht an, wenn aktuelle Zeit nach Startzeit oder vor Endzeit\n            lightOn = currentSeconds >= lightOnSeconds || currentSeconds < lightOffSeconds;\n        } else {\n            // Lichtzyklus innerhalb eines Tages: Licht an, wenn aktuelle Zeit zwischen Start- und Endzeit\n            lightOn = currentSeconds >= lightOnSeconds && currentSeconds < lightOffSeconds;\n        }\n\n        // Setze den Lichtstatus in isPlantDay.lightOn\n        if (this.isPlantDay.lightOn !== lightOn) {\n            this.isPlantDay.lightOn = lightOn;\n\n            // Logge Änderungen für Debugging\n            node.warn(\n                `${this.tentName}: Lichtstatus aktualisiert - ${lightOn ? \"Licht AN\" : \"Licht AUS\"\n                } (Aktuelle Zeit: ${currentTime.toTimeString()}, On: ${this.isPlantDay.lightOnTime\n                }, Off: ${this.isPlantDay.lightOffTime})`\n            );\n            // Evaluieren des Lichtstatus\n            this.evaluateLightVPDControl();\n            // Überprüfe, ob ein Lichtgerät vorhanden ist, und aktualisiere es\n        }\n    }\n\n    // Hilfsfunktion zur Zeitumrechnung (HH:MM:SS → Sekunden)\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    /// DEVCIES ******************************\n    // Methode zum Abrufen der passenden Geräteklasse\n\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    setOwnDeviceSetup(deviceControl) {\n        const isActivated = this.helperYesTrue(deviceControl);\n\n        if (isActivated !== this.controls.ownDeviceSetup) {\n            this.controls.ownDeviceSetup = isActivated;\n\n            // Wenn `ownDeviceSetup` aktiviert ist, leere die Geräte\n            if (this.controls.ownDeviceSetup) {\n                node.warn(\"Eigene Geräte aktiviert: Lösche alle Geräte aus der Liste.\");\n                this.devices = [];\n\n            } else {\n                node.warn(\"Eigene Geräte deaktiviert: Lösche alle Geräte aus der Liste.\");\n                this.devices = [];\n            }\n        }\n    }\n\n\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    getOwnDeviceSetup() {\n        return this.helperYesTrue(this.controls.ownDeviceSetup)\n    }\n\n\n    getDeviceClass(deviceType) {\n        const deviceClasses = {\n            humidifier: Humidifier,\n            dehumidifier: Dehumidifier,\n            exhaust: Exhaust,\n            ventilation: Ventilation,\n            heater: Heater,\n            cooler: Cooler,\n            light: Light,\n            pump: Pump,\n            climate: Climate,\n            switch: GenericSwitch,\n            sensor: Sensor,\n        };\n\n        return deviceClasses[deviceType] || Device;\n    }\n    // Gerät direkt zur Instanz hinzufügen und in entities speichern\n    addDevice(deviceName, deviceData, context) {\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n    }\n\n    addListDevice(deviceName, deviceData, context) {\n        let listDeviceType\n        let listDeviceName\n            node.warn(`Add Own selected Device: ${deviceName}`);\n            const parts = deviceName.split(\".\");\n            if (parts.length > 1) {\n                listDeviceName = parts[1]; // Der Teil nach dem Punkt\n                listDeviceType = parts[0];\n            } else {\n                console.log(\"Kein Punkt im String gefunden.\");\n            }\n            const identifiedDevice = this.identifyDevice(listDeviceName, deviceData,listDeviceType);\n\n            if (!identifiedDevice) {\n                node.error(`Failed to identify device: ${listDeviceName}`);\n                return;\n            }\n            // Daten initialisieren, falls nicht vorhanden\n            identifiedDevice.data = { ...deviceData };\n            identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n            this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n            this.registerDevices(identifiedDevice)\n            node.warn(`Added new device: ${listDeviceName}`);\n    }\n\n    // Gerät direkt zur Instanz hinzufügen und in entities speichern\n    addDevice2(deviceName, deviceData, context) {\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n    }\n\n    // Geräte Identifizierung\n    identifyDevice(deviceName, deviceData, devType) {\n\n        if(devType){\n            const DeviceClass = this.getDeviceClass(devType);\n            node.warn(`Device ${deviceName} identified as ${devType}`);\n            return new DeviceClass(deviceName, devType, deviceData);\n        }\n\n        const deviceTypeMapping = {\n            \"sensor\": [\"mode\", \"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"h5179\"],\n            \"dehumidifier\": [\"dehumidifier\", \"drying\", \"dryer\", \"entfeuchter\", \"removehumidity\"],\n            \"humidifier\": [\"humidifier\", \"mist\", \"befeuchter\",],\n            \"exhaust\": [\"exhaust\", \"abluft\", \"ruck\"],\n            \"ventilation\": [\"vent\", \"vents\", \"venti\", \"ventilation\", \"inlet\", \"outlet\"],\n            \"heater\": [\"heater\", \"heizung\", \"warm\"],\n            \"climate\": [\"climate\", \"klima\",],\n            \"cooler\": [\"cooler\", \"kühler\", \"klima\"],\n            \"light\": [\"light\", \"lamp\", \"led\", \"switch.light\"],\n            \"co2\": [\"co2\", \"carbon\"],\n            \"switch\": [\"generic\", \"switch\"],\n            \"pump\": [\"pump\", \"waterpump\", \"pumpe\"],\n            //\"sensor\": [\"sensor\", \"mode\",\"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"flower\", \"veggi\", \"vegi\", \"dutycycle\", \"duty\", \"h5179\"],\n        };\n\n        // Prüfen, ob der Gerätename einen bekannten Typ enthält\n        // Überprüfen des Gerätetyps\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (keywords.some(keyword => deviceName.toLowerCase().includes(keyword))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                node.warn(`Device ${deviceName} identified as ${deviceType}`);\n                return new DeviceClass(deviceName, deviceType, deviceData);\n            }\n        }\n\n        // Prüfen, ob deviceData Schlüssel enthält, die auf einen Typ hindeuten\n        const entityKeys = Object.keys(deviceData || {});\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (entityKeys.some(key => keywords.some(keyword => key.toLowerCase().includes(keyword)))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                return new DeviceClass(deviceName, deviceType); // Gerät erstellen\n            }\n        }\n\n        node.warn(`Device ${deviceName} not recognized, returning unknown device.`);\n        return new Device(deviceName, \"unknown\");\n    }\n\n    // Registierung Caps ( noch nicht in nutzung)\n    registerDevices(device) {\n        // Sensoren ignorieren\n        if (device.deviceType.includes(\"sensor\")) return;\n        let capabilities\n        // Bestimme die Fähigkeiten des Geräts\n        capabilities = {\n            canHeat: device.deviceType === \"heater\" || device.deviceType === \"climate\" || device.deviceType === \"light\",\n            canCool: device.deviceType === \"cooler\" || device.deviceType === \"climate\",\n            canHumidify: device.deviceType === \"humidifier\",\n            canDehumidify: device.deviceType === \"dehumidifier\" || device.deviceType === \"climate\",\n            canVentilate: device.deviceType === \"ventilation\",\n            canExhaust: device.deviceType === \"exhaust\",\n            canLight: device.deviceType === \"light\",\n        };\n\n        // Entferne alle Fähigkeiten, die das Gerät nicht besitzt\n        capabilities = Object.fromEntries(\n            Object.entries(capabilities).filter(([key, value]) => value)\n        );\n\n        // Füge die bereinigten Fähigkeiten zum Gerät hinzu\n\n\n        // Füge das Gerät zum `registeredDevices`-Array hinzu\n        if (!this.devices) this.devices = [];\n        device.capabilities = { ...capabilities }\n\n        node.warn(`Device registered: ${device.name} with capabilities: ${Object.keys(capabilities).join(\", \")}`);\n    }\n\n    // Erhalte alle geräte \n    listDevices() {\n        return this.devices;\n    }\n\n    // Gerät sperren\n    lockDevice(device, roomName) {\n        if (!device.isLocked) {\n            device.isLocked = true;\n            device.lockedFor = roomName;\n            this.updateDevice(device);\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät entsperren\n    unlockDevice(device) {\n        if (device.isLocked) {\n            device.isLocked = false;\n            device.lockedFor = \"\";\n            console.warn(`Gerät entsperrt: ${device.name}`);\n            return true;\n        }\n        console.warn(`Gerät war nicht gesperrt: ${device.name}`);\n        return false;\n    }\n\n    // Gerät ausleihen\n    borrowDevice(device, fromTent) {\n        if (this.lockDevice(device, fromTent)) {\n            const borrowedIndex = this.devices.findIndex(d => d.name === device.name);\n            if (borrowedIndex === -1) {\n                this.devices.push(device);\n            }\n            device.inRoomName = this.tentName; // Setze den Raumnamen des geliehenen Geräts\n            device.isfromAmbient = false; // Markiere, dass es nicht mehr von Ambient kommt\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät aktualisieren\n    updateDevice(updatedDevice) {\n        const index = this.devices.findIndex(d => d.name === updatedDevice.name);\n        if (index !== -1) {\n            this.devices[index] = updatedDevice;\n        } else {\n            this.devices.push(updatedDevice);\n        }\n    }\n\n    // Gerät zurückgeben\n    returnDevice(device) {\n        if (this.unlockDevice(device)) {\n            // Entferne alle Instanzen des Geräts aus dem Array\n            device.action = \"off\";\n            device.mode = \"off\";\n            let offAction = device.turnOFF();\n            this.devices = this.devices.filter(d => d.name !== device.name);\n            console.warn(`Alle Instanzen von ${device.name} entfernt.`);\n\n            device.inRoomName = \"ambient\"; // Setze den Raumnamen zurück auf Ambient\n            device.isfromAmbient = true; // Markiere, dass es wieder zu Ambient gehört\n            device.action = \"off\";\n            node.warn(`OFF_Action_ROOM: ${JSON.stringify(offAction, null, 2)}`);\n            return offAction\n        }\n        console.warn(`Gerät konnte nicht entsperrt werden: ${device.name}`);\n        return false;\n    }\n    \n    // Add Own Devices von list ohne erkennung \n    addOwnDevices(deviceName,deviceData,context){\n\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n   \n    }\n\n    getCurrentOwnDeviceList(deviceType) {\n        // Filtere die Geräte basierend auf dem übergebenen `deviceType`\n        let devicetypes = this.ownDeviceList.filter(device => device.deviceType === deviceType);\n\n        // Extrahiere nur die Namen der Geräte (`entity`) aus der gefilterten Liste\n        let deviceNames = devicetypes.map(device => device.entity);\n\n        // Rückgabe der Gerätenamen\n        return deviceNames;\n    }\n\n    setCurrentOwnDeviceList(entity, deviceType) {\n        // Erstelle ein neues Gerät-Objekt\n        const deviceObject = { entity, deviceType };\n\n        // Überprüfen, ob ein Gerät mit derselben entity und deviceType bereits existiert\n        const exists = this.ownDeviceList.some(\n            (device) => device.entity === entity && device.deviceType === deviceType\n        );\n\n        // Nur hinzufügen, wenn es noch nicht existiert\n        if (!exists) {\n            this.ownDeviceList.push(deviceObject);\n        }\n    }\n\n\n    findDeviceByEntity(entity) {\n        // Überprüfen, ob ownSetttetDevices existieren und ein Array sind\n        if (!Array.isArray(this.devices)) {\n            return false;\n        }\n\n        // Durchlaufe alle Geräte in ownSetttetDevices\n        for (const device of this.devices) {\n            // Überprüfe, ob die Entität im `data`-Objekt des Geräts existiert\n            if (device.data && Object.prototype.hasOwnProperty.call(device.data, entity)) {\n                return { device, found: true };\n            }\n        }\n\n        // Wenn keine Entität gefunden wurde, gib false zurück\n        return { device: null, found: false };\n    }\n\n    // Calc Funks ******************************\n    // Calc Dewpoint\n    calculateDewPoint(temperature = this.tentData.temperature, humidity = this.tentData.humidity) {\n        const temp = parseFloat(temperature);\n        const hum = parseFloat(humidity);\n        if (isNaN(temp) || isNaN(hum)) {\n            return \"unavailable\";\n        }\n\n        const a = 17.27;\n        const b = 237.7;\n\n        // Berechnung der Hilfsvariable γ(T, RH)\n        const gamma = (a * temp) / (b + temp) + Math.log(hum / 100);\n\n        // Berechnung des Taupunkts\n        const dewPoint = (b * gamma) / (a - gamma);\n        this.tentData.dewpoint = parseFloat(dewPoint.toFixed(2))\n        return parseFloat(dewPoint.toFixed(2));\n    }\n\n    // Calc Aktellen VPD ( Based TEMP-HUM-EAFTEMP)\n    calculateCurrentVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.leafTempOffset) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.vpd.current = parseFloat(vpd.toFixed(2));\n        return this.vpd.current;\n    }\n\n    // Calc Aktellen VPD Mittelwert aus aktuellen Plantstage min/max werten \n    calculatePerfectVPD(vpdRange = this.vpd.range) {\n        const averageVPD = (vpdRange[0] + vpdRange[1]) / 2;\n        this.vpd.perfection = parseFloat(averageVPD.toFixed(2));\n\n        this.vpd.perfectMin = parseFloat((this.vpd.perfection - this.vpd.perfectTolerance).toFixed(3));\n        this.vpd.perfectMax = parseFloat((this.vpd.perfection + this.vpd.perfectTolerance).toFixed(3));\n    }\n\n    // Berechne aus array/string/number/object den avg wert.\n    calculateAvgValue(temps = []) {\n        let sum = 0;\n        let count = 0;\n\n        // Prüfen, ob es ein Array von Zahlen ist oder ein Array von Objekten mit `value`\n        temps.forEach((entry) => {\n            let temp = parseFloat(entry.value);\n\n            if (!isNaN(temp)) {\n                sum += temp;\n                count++;\n            }\n        });\n\n        if (count === 0) {\n            return \"unavailable\";\n        }\n\n        const avg = sum / count;\n        return avg.toFixed(2);\n    }\n\n    // DRYING ******************************\n    // Setze aktuellen DryMode\n    setDryingMode(dryMode) {\n        if (this.tentMode !== \"Drying\") return\n        node.warn(`DryingModeINcome:${dryMode}`);\n        const normalizedMode = Object.keys(this.drying.modes).find(\n            mode => mode.toLowerCase() === dryMode.toLowerCase()\n        );\n\n        if (!normalizedMode) {\n            node.warn(`Ungültiger Trocknungsmodus: ${dryMode}. Standardmodus 'elClassico' wird verwendet.`);\n            this.drying.currentDryMode = \"elClassico\"; // Standardmodus setzen\n        } else {\n            this.drying.currentDryMode = normalizedMode;\n        }\n\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date)) {\n            this.setDryingStartTime();\n        }\n\n        this.drying.isEnabled = true;\n        this.drying.isRunning = true;\n        node.warn(`Trocknungsmodus aktiviert: ${this.drying.currentDryMode}`);\n    }\n\n    // Erhalte aktulle DryPhase nach Zeitpunkt\n    getDryingPhase() {\n        // Sicherstellen, dass dryStartTime gültig ist\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            node.error(\"Startzeit ist ungültig. Setze Startzeit neu.\");\n            this.setDryingStartTime();\n        }\n\n        // Sicherstellen, dass ein gültiger Drying-Mode gesetzt ist\n        if (!this.drying.currentDryMode || !this.drying.modes.hasOwnProperty(this.drying.currentDryMode)) {\n            node.error(\"Kein gültiger Drying-Mode gesetzt! Setze Standardmodus 'elClassico'.\");\n            this.setDryingMode(\"elClassico\");\n        }\n\n        const startTimeInSeconds = Math.floor(this.dryStartTime.getTime() / 1000);\n        const nowInSeconds = Math.floor(Date.now() / 1000);\n        const elapsedSeconds = nowInSeconds - startTimeInSeconds;\n\n        node.warn(`Verstrichene Zeit: ${elapsedSeconds} Sekunden`);\n\n        // Phasen abrufen und in Sekunden umrechnen\n        const currentMode = this.drying.modes[this.drying.currentDryMode];\n        const { start, halfTime, endTime } = currentMode.phase;\n\n        const startDuration = start.durationHours * 3600;\n        const halfTimeDuration = halfTime.durationHours * 3600;\n        const endTimeDuration = endTime.durationHours * 3600;\n\n        if (elapsedSeconds < startDuration) return \"start\";\n        if (elapsedSeconds < startDuration + halfTimeDuration) return \"halfTime\";\n        if (elapsedSeconds < startDuration + halfTimeDuration + endTimeDuration) return \"endTime\";\n\n        node.warn(\"Trocknung abgeschlossen.\");\n        return \"completed\";\n    }\n\n    // Erhalte aktuellen DryMode\n    getDryingMode() {\n        return this.drying.currentDryMode\n    }\n\n    // Setze Initale Zeit für DryZeitpunkt\n    setDryingStartTime() {\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            this.dryStartTime = new Date(); // Erstelle gültiges Date-Objekt\n            node.warn(`Startzeit wurde gesetzt: ${this.dryStartTime.toISOString()}`);\n        }\n    }\n\n    // Berechne Wasseraktivität\n    calcWatteractiviy(humidity = this.tentData.humidity) {\n        let hum = parseFloat(humidity);\n\n        if (isNaN(hum)) {\n            console.error(\"Invalid humidity value. Water activity cannot be calculated.\");\n            this.drying.waterActivity = null; // Setze den Wert explizit auf null bei Fehler\n            return null;\n        }\n\n        let wa = hum / 100; // Wasseraktivität berechnet als Verhältnis von Luftfeuchtigkeit\n        this.drying.waterActivity = parseFloat(wa.toFixed(2)); // Auf zwei Dezimalstellen runden\n        return this.drying.waterActivity;\n    }\n\n    // Berechne DewPointVPD (Based on Dewpoint/TEMP)\n    calcDewVPD(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for VPD calculation.\");\n            this.drying.dryingVPD = null;\n            return null;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * airTemp) / (airTemp + 237.3));\n        let adp = 0.6108 * Math.exp((17.27 * dewPoint) / (dewPoint + 237.3));\n\n        let dewVPD = sdpLuft - adp;\n        this.drying.dewpointVPD = parseFloat(dewVPD.toFixed(2)); // Rundet den VPD-Wert auf zwei Dezimalstellen\n        return this.drying.dewpointVPD;\n    }\n\n    // Berechne SharkMouse VPD (Based on TERMP/HUM/VPD)\n    calcSharkMouseVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.temperature) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.drying.sharkMouseVPD = parseFloat(vpd.toFixed(2));\n        return this.drying.sharkMouseVPD;\n    }\n\n    // Setze Aktuelle Vapor Pressure Werte\n    calcDryingVPs(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for vapor pressure calculation.\");\n            this.drying.vaporPressureActual = null;\n            this.drying.vaporPressureSaturation = null;\n            return null;\n        }\n\n        // Berechnung des tatsächlichen Dampfdrucks (ADP) am Taupunkt\n        let vaporPressureActual = 6.11 * Math.pow(10, (7.5 * dewPoint) / (237.3 + dewPoint));\n        this.drying.vaporPressureActual = parseFloat(vaporPressureActual.toFixed(2)); // Runden\n\n        // Berechnung des Sättigungsdampfdrucks (SDP) für Lufttemperatur\n        let vaporPressureSaturation = 6.11 * Math.pow(10, (7.5 * airTemp) / (237.3 + airTemp));\n        this.drying.vaporPressureSaturation = parseFloat(vaporPressureSaturation.toFixed(2)); // Runden\n\n        return {\n            vaporPressureActual: this.drying.vaporPressureActual,\n            vaporPressureSaturation: this.drying.vaporPressureSaturation,\n        };\n    }\n\n    //MODES ******************************\n    // MITTEL wert ziel aus range vpd werten\n    perfectionAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n        let ActionType = \"\"\n        if (currentVPD < perfectVPD - tolerance) {\n            action = this.actions.Increased;\n            ActionType = \"Increased\"\n        } else if (currentVPD > perfectVPD + tolerance) {\n            action = this.actions.Reduced;\n            ActionType = \"Reduced\"\n        }else{\n            action = this.actions.Unchanged;\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"Perfection Reached\",\n                ActionType: \"Perfection\",\n                currentVPD: currentVPD,\n                targetVPD: perfectVPD,\n                targetReached:true,\n                vpdDiffPercent: vpdDiffPercent,\n                perfectMin: this.vpd.perfectMin,\n                perfectMax: this.vpd.perfectMax,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode, // Wenn unverändert, setzen wir \"Unchanged\"\n            inMode: \"VPD Perfection\",\n            ActionType: ActionType,\n            currentVPD: currentVPD,\n            targetVPD: perfectVPD,\n            targetReached:false,\n            vpdDiffPercent: vpdDiffPercent,\n            perfectMin: this.vpd.perfectMin,\n            perfectMax: this.vpd.perfectMax,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Jumper zwishen min und max werten.\n    rangeAdjustments(currentVPD = this.vpd.current, targetVPDRange = this.vpd.range, tolerance = this.vpd.rangeTolerance) {\n        let action;\n        let vpdDiffPercent;\n        let ActionType = \"\"\n        if (currentVPD < targetVPDRange[0] - tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[0]) / targetVPDRange[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n            ActionType = \"Increased\"\n        } else if (currentVPD > targetVPDRange[1] + tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[1]) / targetVPDRange[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n            ActionType = \"Reduced\"\n        }else{\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[1]) / targetVPDRange[1]) * 100).toFixed(2));\n            action = this.actions.Unchanged;\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"Range Reached\",\n                ActionType: \"Unchanged\",\n                targetReached:true,\n                currentVPD: currentVPD,\n                targetVPDMin: targetVPDRange[0],\n                targetVPDMax: targetVPDRange[1],\n                vpdDiffPercent: vpdDiffPercent,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"VPD Range\",\n            ActionType:ActionType,\n            targetReached:false,\n            currentVPD: currentVPD,\n            targetVPDMin: targetVPDRange[0],\n            targetVPDMax: targetVPDRange[1],\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Targeted VPD Ziel mit Targed VPD\n    targetAdjustment(currentVPD = this.vpd.current, targetVPD = this.vpd.targeted, tolerance = this.vpd.targetedTolerance) {\n        let action;\n        let ActionType = \"\"\n        let vpdDiffPercent = parseFloat((((currentVPD - targetVPD) / targetVPD) * 100)); // Korrektur der Berechnung\n\n\n        if (currentVPD < targetVPD + tolerance) {\n            action = this.actions.Increased;\n            ActionType = \"Increased\"\n        } else if (currentVPD > targetVPD + tolerance) {\n            action = this.actions.Reduced;\n            ActionType = \"Reduced\"\n            \n        }else{\n            action = this.actions.Unchanged;\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"Target Reached\",\n                ActionType: \"Unchanged\",\n                currentVPD: currentVPD,\n                targetedVPD: targetVPD,\n                targetReached:true,\n                vpdDiffPercent: vpdDiffPercent,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n        \n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"Targeted-VPD\",\n            ActionType: ActionType,\n            currentVPD: currentVPD,\n            targetedVPD: targetVPD,\n            targetReached:false,\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // DryingModeChecks \n    dryAdjustments() {\n        if (!this.drying.isEnabled || !this.drying.isRunning) {\n            this.drying.isEnabled = true;\n            this.drying.isRunning = true;\n            this.setDryingStartTime();\n            node.warn(\"Trocknung gestartet und Status aktualisiert.\");\n        }\n\n        const currentPhase = this.getDryingPhase();\n        if (!currentPhase) {\n            node.error(\"Keine Phase berechnet, Startzeit fehlt.\");\n            return { error: \"Phase konnte nicht berechnet werden.\" };\n        }\n\n        if (currentPhase === \"completed\") {\n            node.warn(\"Trocknung abgeschlossen.\");\n            this.drying.isRunning = false;\n            return { status: \"completed\" };\n        }\n\n        // Wasseraktivität und VPD berechnen\n        this.calcWatteractiviy(this.tentData.humidity);\n        this.calcDewVPD(this.tentData.temperature, this.tentData.dewpoint);\n        this.calcDryingVPs(this.tentData.temperature, this.tentData.dewpoint)\n        this.calcSharkMouseVPD(this.tentData.temperature, this.tentData.humidity)\n\n        node.warn(`CURRENTPHASE: ${currentPhase}`);\n\n\n        // Phase-spezifische Aktionen ausführen\n        switch (this.drying.currentDryMode) {\n            case \"elClassico\":\n                return this.dryElClassico(currentPhase);\n            case \"SharkMouse\":\n                return this.drySharkMouse(currentPhase);\n            case \"dewBased\":\n                return this.dryDewBased(currentPhase);\n            default:\n                node.error(\"Unbekannter Drying-Mode!\");\n                return { error: \"Unbekannter Drying-Mode\" };\n        }\n    }\n\n    // DRYMODE Classic\n    dryElClassico(currentPhase) {\n        const phaseConfig = this.drying.modes.elClassico.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const tempTolerance = 0.5; // Toleranz in °C\n        const humTolerance = 2;   // Toleranz in %\n\n        // Anpassungen basierend auf Temperatur\n        if (Math.abs(this.tentData.temperature - phaseConfig.targetTemp) > tempTolerance) {\n            if (this.tentData.temperature < phaseConfig.targetTemp) {\n                dryAction.heater = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        // Anpassungen basierend auf Feuchtigkeit\n        if (Math.abs(this.tentData.humidity - phaseConfig.targetHumidity) > humTolerance) {\n            if (this.tentData.humidity < phaseConfig.targetHumidity) {\n                dryAction.humidifier = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"unchanged\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"increased\" };\n            }\n        }\n\n        // Konfliktlösung: Priorisierung von Temperatur\n        if (dryAction.dehumidifier === \"increased\" && this.tentData.temperature < phaseConfig.targetTemp) {\n            dryAction.heater = \"increased\";\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE VPD Based\n    drySharkMouse(currentPhase) {\n        const phaseConfig = this.drying.modes.SharkMouse.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const vpdTolerance = 0.05; // Toleranz für VPD\n\n        // Anpassungen basierend auf VPD\n        const currentVPD = this.calculateCurrentVPD();\n        if (Math.abs(currentVPD - phaseConfig.targetVPD) > vpdTolerance) {\n            if (currentVPD < phaseConfig.targetVPD) {\n                dryAction.heater = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetVPD: phaseConfig.targetVPD,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE DewPoint Based\n    // DRYMODE DewPoint Based\n    dryDewBased(currentPhase) {\n        const phaseConfig = this.drying.modes.dewBased.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const dewPointTolerance = 0.5; // Toleranz für Taupunkt\n\n        // Anpassungen basierend auf Vapor Pressure (Taupunkt, tatsächlicher Dampfdruck und Sättigungsdampfdruck)\n        const currentDewPoint = this.calculateDewPoint();\n        const vaporPressureActual = this.drying.vaporPressureActual;\n        const vaporPressureSaturation = this.drying.vaporPressureSaturation;\n\n        // Sicherstellen, dass currentDewPoint eine Zahl ist\n        if (typeof currentDewPoint !== \"number\" || isNaN(currentDewPoint)) {\n            console.warn(\"Current Dew Point is unavailable or invalid.\");\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetDewPoint: phaseConfig.targetDewPoint,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction,\n                warning: \"Dew Point data is invalid or unavailable.\",\n            };\n        }\n\n        // Überprüfen, ob die aktuellen Werte im Zielbereich liegen\n        if (\n            Math.abs(currentDewPoint - phaseConfig.targetDewPoint) > dewPointTolerance ||\n            vaporPressureActual < 0.9 * vaporPressureSaturation ||\n            vaporPressureActual > 1.1 * vaporPressureSaturation\n        ) {\n            if (currentDewPoint < phaseConfig.targetDewPoint || vaporPressureActual < 0.9 * vaporPressureSaturation) {\n                dryAction.humidifier = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"unchanged\", cool: \"unchanged\", heat: \"increased\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"increased\", cool: \"unchanged\", heat: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetDewPoint: phaseConfig.targetDewPoint,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction,\n        };\n    }\n\n    // EXPERIMENTEL\n    glbjAdjustments(currentVPD = this.vpd.current, ecoTarget = this.vpd.ecotarget) {\n        let action;\n        let vpdECOPercent;\n\n        if (currentVPD < ecoTarget[0]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[0]) / ecoTarget[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n        } else if (currentVPD > ecoTarget[1]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[1]) / ecoTarget[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: currentVPD,\n            Action:\"MasterBrain\",\n            targetVPDMin: ecoTarget[0],\n            targetVPDMax: ecoTarget[1],\n            vpdDiffPercent: vpdECOPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // NIGHTHOLD VPD OUTPUT\n    inDontCareMode() {\n        let action = {\n            exhaust: \"maximal\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"maximal\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        // NEED TO TEST ON LIGHT OFF PHASE\n        node.warn(`Ignore VPD on NightTime run minimal Actions`);\n        return {\n            tentName: this.tentName,\n            tentMode: \"I DONT CARE MODE\",\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    /// DISABELD \n    disabledMode() {\n        node.log(\"Disabled mode active\");\n        let action = {\n            exhaust: \"Unchanged\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"Unchanged\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        return {\n            TentName: this.tentName,\n            tentMode: this.tentMode,\n            actions: action,\n        };\n    }\n\n    /// ACTIONS ******************************\n\n    selectModeAction(){\n        if(this.controls.pidControl){\n            return this.selectPIDAction()\n        }else{\n            return this.selectAction()\n\n        }\n    }\n\n    selectAction() {\n        let preparedDevices = []; // Speicher für Geräteaktionen\n        let actionData = {};\n        let limitAdjustments\n        let finalActions \n        // Prüfen, ob der Zustand seit der letzten Aktion unverändert ist\n        if (this.checkIfActionNeeded()) {\n            this.needchange = true;\n        } else {\n            this.needchange = false;\n        }\n\n        // Modusabhängige Logik\n        if (this.needchange) {\n            switch (this.tentMode) {\n                case \"VPD Perfection\":\n                    actionData = this.perfectionAdjustments(\n                        this.vpd.current,\n                        this.vpd.perfection,\n                        this.vpd.perfectTolerance\n                    );\n                    break;\n                case \"IN-VPD-Range\":\n                    actionData = this.rangeAdjustments(\n                        this.vpd.current,\n                        this.vpd.range,\n                        this.vpd.rangeTolerance\n                    );\n                    break;\n                case \"Targeted VPD\":\n                    actionData = this.targetAdjustment(\n                        this.vpd.current,\n                        this.vpd.targeted,\n                        this.vpd.targetedTolerance\n                    );\n                    break;\n                case \"GLBJ-Mode\":\n                    actionData = this.glbjAdjustments(\n                        this.vpd.current,\n                        this.vpd.ecotarget,\n                    );\n                    break;\n                case \"Drying\":\n                    actionData = this.dryAdjustments();\n                    break;\n                case \"Disabled\":\n                    actionData = this.disabledMode();\n                    break;\n\n                default:\n                    throw new Error(\"Unknown mode: \" + this.tentMode);\n            }\n\n            if (this.isPlantDay.lightOn === false && this.isPlantDay.nightVPDHold === false) {\n                actionData = this.inDontCareMode()\n            }\n\n            // Vorzeitige Anpassungen\n            limitAdjustments = this.checkLimits();\n\n            // Kombiniere alle Aktionen\n            finalActions = {\n                ...actionData.actions || null,\n                ...limitAdjustments || null,\n            };\n\n            this.devices.forEach((device) => {\n\n                // Prüfen, ob das Gerät korrekt initialisiert wurde\n                if (device.switches.length === 0) return\n                if (device && typeof device.prepareAction === \"function\") {\n                    if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n\n                    device = device.prepareAction(finalActions);\n\n                    let actions = device.runAction()\n\n                    //node.warn(`FinalAction: ${JSON.stringify(actions, null, 2)}`);\n\n                    preparedDevices.push(actions)\n\n                } else {\n                    // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                    node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n                }\n            });\n\n\n            this.dataSetter({\n                    ...actionData || null,\n                    actions: finalActions || null,\n                    devices: this.devices || null,\n                    deviceActions: preparedDevices || null,\n                });\n\n\n            return {\n                ...actionData || null,\n                actions: finalActions || null,\n                devices: this.devices || null,\n                deviceActions: preparedDevices || null,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n\n            };\n\n        }else{\n            this.devices.forEach((device) => {\n                device.needChange = false\n                finalActions = this.actions.Unchanged\n                // Prüfen, ob das Gerät korrekt initialisiert wurde\n                if (device.switches.length === 0) return\n                if (device && typeof device.prepareAction === \"function\") {\n                    if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n                        device = device.prepareAction(finalActions);\n                        let actions = device.runAction()\n                        preparedDevices.push(actions)\n                } else {\n                    // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                    node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n                }\n            });\n            return {\n                TentName:this.tentName,\n                TentMode:this.tentMode,\n                Action:\"Unchanged\",\n                TargetReached:false,\n                NeedChange:false,\n                ...actionData || null,\n                actions: finalActions || null,\n                devices: this.devices || null,\n                deviceActions: preparedDevices || null,\n            };\n        }\n\n    }\n\n    selectPIDAction() {\n\n        const preparedDevices = [];\n        let tempAdjustment\n        let humAdjustment\n        let vpdAdjustment\n        let pidActions\n        let pidAdjustments\n\n\n        if (!this.tempPID || !this.humPID || !this.vpdPID) {\n            console.error(\"PID-Controller sind nicht initialisiert.\");\n            return {\n                error: \"PID-Controller nicht initialisiert\",\n            };\n        }\n\n        // Berechne Anpassungen basierend auf den aktuellen PID-Werten\n        this.PIDAdjustments.tempAdjustment = this.tempPID.compute(parseFloat(this.tentData.temperature));\n        this.PIDAdjustments.humAdjustment = this.humPID.compute(parseFloat(this.tentData.humidity));\n        this.PIDAdjustments.vpdAdjustment = this.vpdPID.compute(parseFloat(this.vpd.current));\n        pidAdjustments = this.PIDAdjustments\n\n        if (this.checkIPIDfActionNeeded()) {\n            this.needchange = true;\n\n        } else {\n            this.needchange = false;\n        }\n\n        if(this.needchange){\n\n            // Generiere Aktionen basierend auf den PID-Werten\n            pidActions = this.generateActionsFromPID(tempAdjustment, humAdjustment, vpdAdjustment, this.vpd.lightControl);\n           \n            if (!pidActions) {\n                console.error(\"applyPIDControl hat keine Ergebnisse geliefert.\");\n                return {\n                    error: \"Keine Ergebnisse von applyPIDControl\",\n                };\n            }\n\n            // Geräteaktionen vorbereiten\n            this.devices.forEach((device) => {\n                if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n\n                if (device && typeof device.prepareAction === \"function\") {\n                    device = device.prepareAction(pidActions);\n                    const actions = device.runAction();\n                    preparedDevices.push(actions);\n                } else {\n                    console.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n                }\n            });\n\n            // Speichere die Aktion\n            this.dataPIDSetter({\n                tentMode:\"P.I.D\",\n                PIDAdjustments:pidAdjustments || {},\n                actions: pidActions || {},\n                devices: this.devices || {},\n                deviceActions: preparedDevices || {},\n            });\n            // Rückgabe der Aktion mit den angepassten Geräten und PID-Werten\n            return {\n                tentName: this.tentName,\n                tentMode: \"P.I.D\",\n                vpdPID: this.vpdPID,\n                tempPID: this.tempPID,\n                humPID: this.humPID,\n                PIDAdjustments: pidAdjustments || {},\n                VPD: {\n                    VPD: this.vpd.current\n                },\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity,\n                },\n\n                devices: this.devices || {},\n                actions: pidActions || {},\n                deviceActions: preparedDevices || {},\n            };\n        }else{\n            this.devices.forEach((device) => {\n\n                // Prüfen, ob das Gerät korrekt initialisiert wurde\n                if (device.switches.length === 0) return\n                if (device && typeof device.prepareAction === \"function\") {\n                    if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n                        device = device.prepareAction(this.actions.Unchanged);\n                        let actions = device.runAction()\n                        preparedDevices.push(actions)\n                } else {\n                    // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                    node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n                }\n            });\n            return {\n                tentName: this.tentName,\n                tentMode: \"P.I.D-Unchanged\",\n                vpdPID: this.vpdPID,\n                tempPID: this.tempPID,\n                humPID: this.humPID,\n                PIDAdjustments: pidAdjustments || {},\n                VPD: {\n                    VPD: this.vpd.current\n                },\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity,\n                },\n\n                devices: this.devices || {},\n                actions: pidActions || {},\n                deviceActions: preparedDevices || {},\n            };\n        }\n\n    }\n\n    calculateDynamicWeight(plantStage, deviation) {\n        const baseWeight = this.controls.weights.defaultValue;\n        const stageMultiplier = plantStage.includes(\"Flower\") ? 1.25 : 1.0;\n        return baseWeight * stageMultiplier * Math.abs(deviation);\n    }\n\n    checkLimits() {\n        let adjustments = {};\n\n        //CALC DIYNAMIC WEWIGHT\n        //this.calculateDynamicWeight(this.plantStage)\n\n        // Sicherstellen, dass der Modus nicht \"Drying\" ist\n        if (this.tentMode === \"Drying\") return;\n\n        // Keine Änderungen erforderlich, wenn kein Bedarf besteht\n        if (!this.needchange) return adjustments;\n\n        // Dynamische Gewichtung basierend auf Plant Stage\n        let humidityWeight, temperatureWeight;\n\n        if (this.controls.ownWeights) {\n            humidityWeight = this.controls.weights.hum || 1.0;\n            temperatureWeight = this.controls.weights.temp || 1.0;\n        } else {\n            if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                humidityWeight = 1.25; // Feuchtigkeit ist wichtiger\n                temperatureWeight = 1.0; // Temperatur ist weniger wichtig\n            } else {\n                humidityWeight = 1.0; // Standardgewichtung\n                temperatureWeight = 1.0;\n            }\n        }\n\n        // Initialisierung von Abweichungen\n        let tempDeviation = 0;\n        let humDeviation = 0;\n\n        // Abweichungen nur berechnen, wenn außerhalb der Grenzen\n        if (this.tentData.temperature > this.tentData.maxTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n        } else if (this.tentData.temperature < this.tentData.minTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.minTemp) * temperatureWeight;\n        }\n\n        if (this.tentData.humidity > this.tentData.maxHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n        } else if (this.tentData.humidity < this.tentData.minHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.minHumidity) * humidityWeight;\n        }\n\n        //adjustments.climate = {\n        //    cool: \"unchanged\",\n        //    heat: \"unchanged\",\n        //    dry: \"unchanged\",\n        //};\n\n        // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n        if (tempDeviation > 0 && humDeviation > 0 && this.isPlantDay.lightOn) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n            // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation > 0 && humDeviation < 0 && this.isPlantDay.lightOn) {\n            adjustments.humidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n            // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation > 0 && this.isPlantDay.lightOn) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n            // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation < 0 && this.isPlantDay.lightOn) {\n            adjustments.humidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.ventilation = \"reduced\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n        }\n\n        // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp + 5 && this.isPlantDay.lightOn) {\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n        if (this.tentData.temperature < this.tentData.minTemp - 5 && this.isPlantDay.lightOn) {\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            \n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n\n        }\n\n        // **7. Lichtsteuerung basierend auf Temperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n            node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n            \n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n        }\n\n        // **8. CO₂-Management**\n        if (this.tentData.co2Level < 400 && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            adjustments.co2 = \"increased\";\n            adjustments.exhaust = \"minimum\";\n            node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n\n        } else if (this.tentData.co2Level > 1200 && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            adjustments.co2 = \"reduced\";\n            adjustments.exhaust = \"increased\";\n            node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n\n        }\n\n        // **9. Taupunkt- und Kondensationsschutz**\n        if (this.tentData.dewpoint >= this.tentData.temperature - 1 && this.isPlantDay.lightOn) {\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n\n        }\n\n        // **10. Nachtmodus (Licht aus, maximale Abluft)**\n        if (!this.isPlantDay.lightOn) {\n            adjustments.light = \"off\";\n            //adjustments.exhaust = \"maximum\";\n            //adjustments.ventilation = \"increased\";\n            //adjustments.co2 = \"minimum\";\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n        }\n\n        return adjustments;\n    }\n\n    checkLimitsWithOutAmbient() {\n        let adjustments = {};\n\n        // Sicherstellen, dass der Modus nicht \"Drying\" ist\n        if (this.tentMode === \"Drying\") return;\n\n        // Keine Änderungen erforderlich, wenn kein Bedarf besteht\n        if (!this.needchange) return adjustments;\n\n        // Dynamische Gewichtung basierend auf Plant Stage\n        let humidityWeight, temperatureWeight;\n\n        if (this.controls.ownWeights) {\n            humidityWeight = this.controls.weights.hum || 1.0;\n            temperatureWeight = this.controls.weights.temp || 1.0;\n        } else {\n            if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                humidityWeight = 1.25; // Feuchtigkeit ist wichtiger\n                temperatureWeight = 1.0; // Temperatur ist weniger wichtig\n            } else {\n                humidityWeight = 1.0; // Standardgewichtung\n                temperatureWeight = 1.0;\n            }\n        }\n\n        // Initialisierung von Abweichungen\n        let tempDeviation = 0;\n        let humDeviation = 0;\n\n        // Abweichungen nur berechnen, wenn außerhalb der Grenzen\n        if (this.tentData.temperature > this.tentData.maxTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n        } else if (this.tentData.temperature < this.tentData.minTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.minTemp) * temperatureWeight;\n        }\n\n        if (this.tentData.humidity > this.tentData.maxHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n        } else if (this.tentData.humidity < this.tentData.minHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.minHumidity) * humidityWeight;\n        }\n\n        // **Initialisiere climate innerhalb von adjustments**\n        adjustments.climate = {\n            cool: \"unchanged\",\n            heat: \"unchanged\",\n            dry: \"unchanged\",\n        };\n\n        // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n        if (tempDeviation > 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n            // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation > 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n            // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n            // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.ventilation = \"reduced\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n        }\n\n        // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp + 5) {\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n        if (this.tentData.temperature < this.tentData.minTemp - 5) {\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.heat = \"increased\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"maximum\"\n            }\n            node.warn(`${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **7. Lichtsteuerung basierend auf Temperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n        }\n\n        // **8. CO₂-Management**\n        if (this.tentData.co2Level < 400) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"increased\";\n                adjustments.exhaust = \"minimum\";\n                node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n            }\n\n        } else if (this.tentData.co2Level > 1200) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"reduced\";\n                adjustments.exhaust = \"increased\";\n                node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n            }\n            adjustments.co2 = \"reduced\";\n            adjustments.exhaust = \"increased\";\n            node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n        }\n\n        // **9. Taupunkt- und Kondensationsschutz**\n        if (this.tentData.dewpoint >= this.tentData.temperature - 1) {\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n        }\n\n        // **10. Nachtmodus (Licht aus, maximale Abluft)**\n        if (!this.isPlantDay.lightOn) {\n            adjustments.light = \"off\";\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.co2 = \"minimum\";\n            node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n        }\n\n        return adjustments;\n    }\n\n    analyzeAmbientInfluence() {\n        let ambientAdjustments = {};\n        if (this.enviorment.ambientTemp === 0) return ambientAdjustments\n        // Temperaturdifferenz berechnen\n        const ambientTempDiff = this.tentData.temperature - this.enviorment.ambientTemp;\n\n        if (!isNaN(ambientTempDiff)) {\n            if (ambientTempDiff > 2) {\n                // Zelt ist wärmer -> Nutze Umgebungsluft zum Kühlen\n                ambientAdjustments.cooler = \"increased\";\n                ambientAdjustments.exhaust = \"increased\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, cool: \"increased\" };\n            } else if (ambientTempDiff < -2) {\n                // Zelt ist kälter -> Reduziere Abluft\n                ambientAdjustments.cooler = \"reduced\";\n                ambientAdjustments.exhaust = \"reduced\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, cool: \"reduced\" };\n            }\n        }\n\n        // Feuchtigkeitsdifferenz berechnen\n        const ambientHumDiff = this.tentData.humidity - this.enviorment.ambientHumidity;\n\n        if (!isNaN(ambientHumDiff)) {\n            if (ambientHumDiff > 5) {\n                // Zelt ist feuchter -> Nutze Umgebungsluft zum Entfeuchten\n                ambientAdjustments.dehumidifier = \"increased\";\n                ambientAdjustments.exhaust = \"increased\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, dry: \"increased\" };\n            } else if (ambientHumDiff < -5) {\n                // Zelt ist trockener -> Reduziere Abluft, erhöhe Befeuchtung\n                ambientAdjustments.humidifier = \"increased\";\n                ambientAdjustments.exhaust = \"reduced\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, dry: \"reduced\" };\n            }\n        }\n\n        return ambientAdjustments;\n    }\n\n    // Experimentel ( use outsite and ambient data)\n    analyzeTrends() {\n        let trend = {\n            temperature: this.enviorment.outsiteTemp - this.enviorment.ambientTemp,\n            humidity: this.enviorment.outsiteHumidity - this.enviorment.ambientHumidity,\n        };\n\n        if (trend.temperature > 0) {\n            // Außentemperatur steigt -> Vorzeitig lüften\n            this.actionsIncreased.exhaust = \"preemptively increased\";\n        } else if (trend.temperature < 0) {\n            // Außentemperatur sinkt -> Lüftung reduzieren\n            this.actionsReduced.exhaust = \"preemptively reduced\";\n        }\n\n        if (trend.humidity > 0) {\n            // Außenfeuchtigkeit steigt -> Entfeuchter verstärken\n            this.actionsIncreased.dehumidifier = \"preemptively increased\";\n        } else if (trend.humidity < 0) {\n            // Außenfeuchtigkeit sinkt -> Befeuchter anpassen\n            this.actionsReduced.humidifier = \"preemptively reduced\";\n        }\n    }\n\n    // DATA SETTER FAKE DB ******************************\n    dataSetter(data) {\n        const time = new Date().toISOString();\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n        // Definiere eine Schwelle für Änderungen\n        const vpdThreshold = 0.005;\n\n        if (data.Action === \"Unchanged\" ||data.tentMode === \"Unchanged\" || this.tentMode === \"Unchanged\" || this.tentMode === \"Disabled\" || this.tentMode === \"I DONT CARE MODE\") {\n            return;\n        }\n\n        // Filter für aktive oder relevante Geräte\n        // Filter für aktive oder relevante Geräte\n        const relevantDevices = this.devices.filter(\n            (device) => (device.switches.length > 0) || device.isRunning\n        );\n\n        if (data.PIDAdjustments){\n\n        }\n\n\n        // Erstelle das Datenobjekt\n        const enrichedData = {\n            time,\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: this.vpd.current,\n            targetVPD: data.targetVPD,\n            targetVPDMin: this.vpd.range[0],\n            targetVPDMax: this.vpd.range[1],\n            vpdDiffPercent: data.vpdDiffPercent || 0,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp,\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity,\n            },\n            Dewpoint: this.tentData.dewpoint,\n            Environment: {\n                ambientTemp: this.enviorment.ambientTemp,\n                ambientHumidity: this.enviorment.ambientHumidity,\n                ambientDewpoint: this.enviorment.ambientDewpoint,\n            },\n            Outside: {\n                outsiteTemp: this.enviorment.outsiteTemp,\n                outsiteHumidity: this.enviorment.outsiteHumidity,\n                outsiteDewpoint: this.enviorment.outsiteDewpoint,\n            },\n            actions: data.actions,\n            devices: relevantDevices.map((device) => ({\n                ...device\n            })),\n            deviceActions: data.deviceActions\n        };\n\n        // Bedingung für signifikante Änderungen\n        const significantChange =\n            !lastAction ||\n            Math.abs(lastAction.currentVPD - this.vpd.current) > vpdThreshold ||\n            lastAction.Temps.Temperature !== enrichedData.Temps.Temperature ||\n            lastAction.Humditys.Humidity !== enrichedData.Humditys.Humidity ||\n            lastAction.Dewpoint !== enrichedData.Dewpoint;\n\n        if (significantChange) {\n            this.previousActions.push(enrichedData);\n            node.log(`${this.tentName} Neue Aktion gespeichert:\", ${enrichedData}`);\n            return enrichedData\n        } else {\n            node.log(`${this.tentName} Änderung nicht signifikant - Keine Aktion gespeichert.`);\n        }\n\n        // Begrenze die Anzahl der gespeicherten Aktionen\n        if (this.previousActions.length > 250) {\n            this.previousActions = this.previousActions.slice(-250);\n        }\n\n    }\n\n    dataPIDSetter(data) {\n        const time = new Date().toISOString();\n        const vpdThreshold = 0.005;\n        const tempThreshold = 0.25;\n        const humThreshold = 0.25;\n\n        if (\n            data.tentMode === \"P.I.D-Unchanged\" ||\n            this.tentMode === \"Unchanged\" ||\n            this.tentMode === \"Disabled\" ||\n            this.tentMode === \"I DONT CARE MODE\"\n        ) {\n            return;\n        }\n\n        // Filter für aktive oder relevante Geräte\n        const relevantDevices = this.devices.filter(\n            (device) => device.switches.length > 0 || device.isRunning\n        );\n\n        // Erstelle das Datenobjekt\n        const enrichedData = {\n            time,\n            tentName: this.tentName,\n            tentMode: \"P.I.D\",\n            currentVPD: this.vpd.current,\n            PIDAdjustments: data.PIDAdjustments,\n            VPDPID:this.vpdPID,\n            TempPID:this.tempPID,\n            HumidityPID:this.humPID,\n            CO2PID:this.co2PID,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp,\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity,\n            },\n            Dewpoint: this.tentData.dewpoint,\n            Environment: {\n                ambientTemp: this.enviorment.ambientTemp,\n                ambientHumidity: this.enviorment.ambientHumidity,\n                ambientDewpoint: this.enviorment.ambientDewpoint,\n            },\n            Outside: {\n                outsiteTemp: this.enviorment.outsiteTemp,\n                outsiteHumidity: this.enviorment.outsiteHumidity,\n                outsiteDewpoint: this.enviorment.outsiteDewpoint,\n            },\n            actions: data.actions,\n            devices: relevantDevices.map((device) => ({\n                ...device\n            })),\n            deviceActions: data.deviceActions\n        };\n\n        // Hole die letzte Aktion\n        const lastAction = this.previousPIDActions[this.previousPIDActions.length - 1];\n\n        // Prüfe, ob sich Werte signifikant geändert haben\n        const significantChange =\n            !lastAction ||\n            Math.abs(lastAction.PIDAdjustments.vpdAdjustment - data.PIDAdjustments.vpdAdjustment) > vpdThreshold ||\n            Math.abs(lastAction.PIDAdjustments.temperatureAdjustment - data.PIDAdjustments.temperatureAdjustment) > tempThreshold ||\n            Math.abs(lastAction.PIDAdjustments.humidityAdjustment - data.PIDAdjustments.humidityAdjustment) > humThreshold;\n\n        if (significantChange) {\n            this.previousPIDActions.push(enrichedData);\n            node.log(`${this.tentName} Neue Aktion gespeichert: ${JSON.stringify(enrichedData, null, 2)}`);\n            return enrichedData;\n        } else {\n            node.log(`${this.tentName} Änderung nicht signifikant - Keine Aktion gespeichert.`);\n        }\n\n        // Begrenze die Anzahl der gespeicherten Aktionen\n        if (this.previousPIDActions.length > 250) {\n            this.previousPIDActions = this.previousPIDActions.slice(-250);\n        }\n    }\n\n    // Check if action is needed to chagnes in vpd \n    checkIfActionNeeded() {\n        if (this.previousActions.length === 0) return true;\n\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n\n       \n\n        // Prüfen, ob der aktuelle Zustand identisch mit dem letzten gespeicherten Zustand ist\n        if (lastAction && lastAction.currentVPD === this.vpd.current) {\n            //node.warn(\"VPD hat sich nicht geändert. Keine Aktion notwendig.\");\n            return false;\n        }else{\n            node.warn(`CurrentVPD:${this.vpd.current}, LastActionVPD:${lastAction.currentVPD}`)\n            return true;\n        }\n\n    }\n    \n    // Check if action is needed to chagnes in vpd,temp,humidity over TEMP\n    checkIPIDfActionNeeded2() {\n        if (this.previousPIDActions.length === 0) {\n            console.warn(\"Keine vorherigen Aktionen vorhanden. Aktion notwendig.\");\n            return true;\n        }\n\n        const lastAction = this.previousPIDActions[this.previousPIDActions.length - 1];\n        const { temperatureAdjustment, humidityAdjustment, vpdAdjustment } = this.PIDAdjustments;\n\n        // Prüfen, ob sich die VPD geändert hat\n        if (lastAction && lastAction.PIDAdjustments) {\n            const {\n                temperatureAdjustment: lastTempAdjustment,\n                humidityAdjustment: lastHumAdjustment,\n                vpdAdjustment: lastVpdAdjustment,\n            } = lastAction.PIDAdjustments;\n\n            if (\n                temperatureAdjustment === lastTempAdjustment &&\n                humidityAdjustment === lastHumAdjustment &&\n                vpdAdjustment === lastVpdAdjustment &&\n                lastAction.currentVPD === this.vpd.current\n            ) {\n                console.warn(\"Keine Änderungen an PID-Parametern oder VPD. Keine Aktion notwendig.\");\n                return false;\n            } else {\n                console.warn(`Änderung festgestellt:\n                Temperatur: ${lastTempAdjustment} -> ${temperatureAdjustment},\n                Luftfeuchtigkeit: ${lastHumAdjustment} -> ${humidityAdjustment},\n                VPD: ${lastVpdAdjustment} -> ${vpdAdjustment},\n                CurrentVPD: ${lastAction.currentVPD} -> ${this.vpd.current}`);\n                return true;\n            }\n        } else {\n            console.warn(\"Fehlende vorherige PID-Daten. Aktion notwendig.\");\n            return true;\n        }\n    }\n\n    checkIPIDfActionNeeded() {\n        if (this.previousPIDActions.length === 0) {\n            console.warn(\"Keine vorherigen Aktionen vorhanden. Aktion notwendig.\");\n            return true;\n        }\n\n        const lastAction = this.previousPIDActions[this.previousPIDActions.length - 1];\n        const { temperatureAdjustment, humidityAdjustment, vpdAdjustment } = this.PIDAdjustments;\n\n        // Prüfen, ob sich die VPD geändert hat\n        if (lastAction && lastAction.PIDAdjustments) {\n            const {\n                temperatureAdjustment: lastTempAdjustment,\n                humidityAdjustment: lastHumAdjustment,\n                vpdAdjustment: lastVpdAdjustment,\n            } = lastAction.PIDAdjustments;\n\n            const areAdjustmentsEqual =\n                Math.abs(temperatureAdjustment - lastTempAdjustment) < 0.01 &&\n                Math.abs(humidityAdjustment - lastHumAdjustment) < 0.01 &&\n                Math.abs(vpdAdjustment - lastVpdAdjustment) < 0.01 &&\n                Math.abs(lastAction.currentVPD - this.vpd.current) < 0.01;\n\n            if (areAdjustmentsEqual) {\n                console.warn(\"Keine Änderungen an PID-Parametern oder VPD. Keine Aktion notwendig.\");\n                return false;\n            } else {\n                console.warn(`Änderung festgestellt:\n            Temperatur: ${lastTempAdjustment} -> ${temperatureAdjustment},\n            Luftfeuchtigkeit: ${lastHumAdjustment} -> ${humidityAdjustment},\n            VPD: ${lastVpdAdjustment} -> ${vpdAdjustment},\n            CurrentVPD: ${lastAction.currentVPD} -> ${this.vpd.current}`);\n                return true;\n            }\n        } else {\n            console.warn(\"Fehlende vorherige PID-Daten. Aktion notwendig.\");\n            return true;\n        }\n    }\n\n}\n\nclass OGBPIDController {\n    constructor(name, Kp, Ki, Kd, minValue, maxValue, setPoint = null) {\n        this.name = name;\n        this.Kp = Kp; // Proportionaler Faktor\n        this.Ki = Ki; // Integraler Faktor\n        this.Kd = Kd; // Derivativer Faktor\n        this.minValue = minValue; // Minimalwert\n        this.maxValue = maxValue; // Maximalwert\n        this.SetPoint = 0; // Zielwert\n        this.integral = 0; // Summierter Fehler (für Ki)\n        this.prevError = 0; // Fehler aus der vorherigen Berechnung (für Kd)\n        this.maxIntegral = 100; // Anti-Windup Grenze\n        this.prevValue = null; // Vorheriger Wert (für Glättung)\n        this.lastComputeTime = null; // Zeit der letzten Berechnung\n    }\n\n    // Anti-Windup für Integralanteil\n    clampIntegral() {\n        this.integral = Math.max(-this.maxIntegral, Math.min(this.maxIntegral, this.integral));\n    }\n\n    // Aktualisieren der Parameter\n    updateProportional(value) { if (value !== this.Kp) this.Kp = value; }\n    updateIntegral(value) { if (value !== this.Ki) this.Ki = value; }\n    updateDerivative(value) { if (value !== this.Kd) this.Kd = value; }\n\n    // Glättung der Eingabewerte (Moving Average)\n    smoothInput(currentValue, alpha = 0.1) {\n        if (this.prevValue === null) {\n            this.prevValue = currentValue; // Initialisierung, wenn noch kein vorheriger Wert existiert\n            console.log(`[${this.name}] prevValue initialisiert: ${this.prevValue}`);\n        }\n        const smoothedValue = alpha * currentValue + (1 - alpha) * this.prevValue;\n        this.prevValue = smoothedValue; // `prevValue` wird aktualisiert\n        console.log(`[${this.name}] Glättung: currentValue=${currentValue}, prevValue=${this.prevValue}, smoothedValue=${smoothedValue}`);\n        return smoothedValue;\n    }\n\n    updateSetPoint() {\n        this.SetPoint = (this.minValue + this.maxValue) / 2; // Zielwert\n    }\n\n    // PID-Berechnung mit Zeitdifferenz und korrekt verwendetem `prevValue`\n    compute(currentValue, useSmoothing = false, alpha = 0.1) {\n        if (typeof currentValue !== 'number' || isNaN(currentValue)) {\n            console.error(`[${this.name}] Ungültiger Eingabewert: ${currentValue}`);\n            return this.minValue; // Standardausgabe bei Fehler\n        }\n\n        // Sicherstellen, dass der SetPoint korrekt aktualisiert wird\n        if (typeof this.updateSetPoint === 'function') {\n            this.updateSetPoint();\n        } else {\n            console.warn(`[${this.name}] updateSetPoint() ist nicht definiert.`);\n        }\n\n        const now = Date.now(); // Aktuelle Zeit in Millisekunden\n        const deltaTime = this.lastComputeTime ? (now - this.lastComputeTime) / 1000 : 0; // Zeitdifferenz in Sekunden\n        this.lastComputeTime = now;\n\n        if (deltaTime === 0) {\n            console.warn(`[${this.name}] DeltaTime ist 0. Keine Berechnung durchgeführt.`);\n            return this.minValue; // Keine Berechnung, falls keine Zeit vergangen ist\n        }\n\n        const input = useSmoothing ? this.smoothInput(currentValue, alpha) : currentValue;\n        const error = this.SetPoint - input;\n\n        // Debugging: Fehlervergleich und Eingabewerte\n        console.log(`[${this.name}] Fehlervergleich: error=${error}, prevError=${this.prevError}`);\n        console.log(`[${this.name}] Eingabewerte: input=${input}, SetPoint=${this.SetPoint}`);\n\n        // Berechnung des Integral- und Derivativen Anteils mit Zeitdifferenz\n        this.integral += error * deltaTime;\n        this.clampIntegral();\n        const derivative = (error - this.prevError) / deltaTime;\n\n        // Debugging: DeltaTime, Integral und Derivative\n        console.log(`[${this.name}] DeltaTime=${deltaTime}, Integral=${this.integral}, Derivative=${derivative}`);\n\n        // PID-Ausgabe\n        const output = (this.Kp * error) + (this.Ki * this.integral) + (this.Kd * derivative);\n\n        // Fehler für nächste Iteration speichern\n        this.prevError = error;\n\n        // Begrenzung der Ausgabe\n        const boundedOutput = Math.max(this.minValue, Math.min(this.maxValue, output));\n\n        // Debugging: Ausgabe\n        console.log(`[${this.name}] PID-Ausgabe: output=${output}, boundedOutput=${boundedOutput}`);\n\n        return boundedOutput;\n    }\n}\n\nclass OGBPIDController1{\n    constructor(name,Kp, Ki, Kd, minValue, maxValue) {\n        this.name = name\n        this.Kp = Kp; // Proportionaler Faktor\n        this.Ki = Ki; // Integraler Faktor\n        this.Kd = Kd; // Derivativer Faktor\n        this.SetPoint = 0\n        this.minValue = minValue; // Minimalwert\n        this.maxValue = maxValue; // Maximalwert\n        this.integral = 0; // Summierter Fehler (für Ki)\n        this.prevError = 0; // Fehler aus der vorherigen Berechnung (für Kd)\n    }\n\n    updateProportional(value){\n        if(value !== this.Kp){\n            this.Kp = value\n        } \n    }\n\n    updateIntegral(value){\n        if(value !== this.Ki){\n            this.Ki = value\n        } \n    }\n\n    updateDerivative(value){\n        if(value !== this.Kd){\n            this.Kd = value\n        } \n    }\n\n    compute(currentValue) {\n        const setPoint = (this.minValue + this.maxValue) / 2;\n        this.SetPoint = parseFloat(setPoint)\n        const error = setPoint - currentValue;\n\n        // Begrenzung für den Integralwert\n        this.integral = Math.max(-100, Math.min(100, this.integral + error));\n\n        const derivative = error - this.prevError;\n        const output = (this.Kp * error) + (this.Ki * this.integral) + (this.Kd * derivative);\n\n        this.prevError = error;\n\n        return Math.max(this.minValue, Math.min(this.maxValue, output)); // Begrenzte Ausgabe\n    }\n\n    compute2(currentValue) {\n        const setPoint = (this.minValue + this.maxValue) / 2;\n        const error = setPoint - currentValue;\n        this.integral += error;\n        const derivative = error - this.prevError;\n\n        //node.warn(`${this.name} Berechnung: SetPoint=${setPoint}, Error=${error}, Integral=${this.integral}, Derivative=${derivative}`);\n\n        const output = (this.Kp * error) + (this.Ki * this.integral) + (this.Kd * derivative);\n        this.prevError = error;\n\n        //node.warn(`${this.name} PID-Ausgabe: ${output}`);\n        return output;\n    }\n\n}\n\nclass Device {\n    constructor(deviceName, deviceType = \"generic\") {\n        this.name = deviceName;\n        this.deviceType = deviceType;\n        this.isRunning = false;\n        this.isDimmable = false;\n        this.needChange = false;\n        this.action = \"\";\n        this.inRoomName = \"\";\n        this.isfromAmbient = false;\n        this.isLocked = false;\n        this.lockedFor = \"\";\n\n        this.switches = [];\n        this.sensors = [];\n        this.data = {};\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.updateChangedData(this.data, data);\n\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.checkIfDimmable();\n    }\n\n    updateChangedData(currentData, newData) {\n        if (!newData || typeof newData !== \"object\") return {};\n        if (!currentData || typeof currentData !== \"object\") currentData = {};\n\n        let changedData = {};\n\n        Object.keys(newData).forEach(function (key) {\n            const newValue = newData[key];\n            const currentValue = currentData[key];\n\n            if (currentValue !== newValue) {\n                changedData[key] = newValue;\n                currentData[key] = newValue;\n            }\n        });\n        return changedData;\n    }\n\n    setFromtent(roomName) {\n        if (roomName !== this.inRoomName) {\n            this.inRoomName = roomName;\n        }\n    }\n\n    identifyIfFromAmbient() {\n        this.isfromAmbient = typeof this.inRoomName === \"string\" &&\n            this.inRoomName.toLowerCase().includes(\"ambient\");\n    }\n\n    identifySwitchesAndSensors() {\n        if (!this.data || typeof this.data !== \"object\") return;\n\n        const keys = Object.keys(this.data);\n        this.switches = keys.filter((key) =>\n            key.startsWith(\"switch.\") || key.startsWith(\"light.\") || key.startsWith(\"fan.\") || key.startsWith(\"climate.\")|| key.startsWith(\"humidifier\")\n        );\n        this.sensors = keys.filter((key) =>\n            key.startsWith(\"sensor.\") || key.startsWith(\"select.\") || key.startsWith(\"number.\") || key.startsWith(\"text.\") || key.startsWith(\"time.\")\n        );\n    }\n\n\n    updateIsRunningState() {\n        this.isRunning = false;\n\n        if (!this.data || typeof this.data !== \"object\") {\n            return;\n        }\n\n        const checkKeys = [\"fan.\", \"light.\", \"climate.\", \"switch.\", \"humidifier.\"];\n        for (const prefix of checkKeys) {\n            const keys = Object.keys(this.data).filter((key) => key.startsWith(prefix));\n            if (keys.some((key) => this.data[key] === \"on\")) {\n                this.isRunning = true;\n                return;\n            }\n        }\n    }\n\n    checkIfDimmable() {\n        const allowedDeviceTypes = [\"ventilation\", \"exhaust\", \"light\"]; // Erlaubte Gerätetypen\n        if (!allowedDeviceTypes.includes(this.deviceType)) {\n            //console.log(`Dimmprüfung nicht erlaubt für Gerätetyp: ${this.deviceType}`);\n            return;\n        }\n        if (this.foundDuty === false)return\n        if (this.isDimmable) return; // Bereits als dimmbar erkannt\n        if (this.name === \"ogb\") return; // Spezielle Ausnahme\n\n        if (!this.data || typeof this.data !== \"object\") {\n            console.log(\"Keine gültigen Daten gefunden, um Dimmfähigkeit zu prüfen.\");\n            return;\n        }\n\n        // Schlüsselwörter, die auf Dimmfähigkeit hinweisen\n        const dimmableKeys = [\n            \"duty\",\n            \"dutycycle\",\n            \"duty_cycle\",\n            \"fan.\",\n            \"light.\",\n            \"number.\",\n            \"select.\"\n        ];\n\n        console.log(\"Prüfe auf Dimmfähigkeit. Verfügbare Daten:\", Object.keys(this.data));\n\n        // Prüfe, ob einer der Schlüssel in den Gerätedaten enthalten ist\n        this.isDimmable = Object.keys(this.data).some((key) => {\n            const match = dimmableKeys.some((dimmableKey) => key.toLowerCase().includes(dimmableKey));\n            if (match) {\n                console.log(`Dimmbare Eigenschaft gefunden: ${key}`);\n            }\n            return match;\n        });\n\n        if (!this.isDimmable) {\n            console.log(\"Keine dimmbaren Eigenschaften in den Daten gefunden.\");\n            this.foundDuty = false\n        } else {\n            console.log(\"Das Gerät ist dimmbar.\");\n            this.foundDuty = true\n        }\n    }\n\n\n\n    prepareAction(finalActions) {\n        if (finalActions.hasOwnProperty(this.deviceType)) {\n            const actionValue = finalActions[this.deviceType];\n\n            if (this.deviceType === \"light\") {\n                this.needChange = actionValue !== \"unchanged\";\n                this.action = actionValue;\n            } else if (this.deviceType === \"climate\") {\n                if (finalActions.climate && typeof finalActions.climate === \"object\") {\n                    for (const [mode, action] of Object.entries(finalActions.climate)) {\n                        if (action !== \"unchanged\") {\n                            this.needChange = true;\n                            this.action = { mode, action };\n                            break;\n                        }\n                    }\n                } else {\n                    this.action = \"unchanged\";\n                }\n            } else {\n                this.needChange = actionValue !== \"unchanged\" && [\"maximum\", \"reduced\", \"increased\", \"minimum\", \"on\", \"off\"].includes(actionValue);\n                this.action = actionValue;\n            }\n        } else {\n            this.needChange = false;\n            this.action = \"unchanged\";\n        }\n\n        return this;\n    }\n\n    evalAction() {\n        return this.action !== \"unchanged\";\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            return { entity_id: entity, action: \"off\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            return { entity_id: entity, action: \"on\" };\n        }\n    }\n}\n\nclass Light extends Device {\n    constructor(name) {\n        super(name, \"light\");\n        this.isInitialized = false;\n        this.dutyCycle = null;\n        this.voltage = 0.0;\n        this.minDuty = 20;\n        this.maxDuty = 100;\n\n        // Light Times\n        this.lightOnTime = \"\"; // Startzeit des Lichts\n        this.lightOffTime = \"\"; // Endzeit des Lichts\n        this.isScheduled = false; // Ob das Licht Zeitpläne berücksichtigt\n\n        // Sunrise/SunSet StepSize\n        this.stepSize = 1; // Schrittweite für Änderungen\n\n        // CONTROL VARS\n        this.controlOverVoltage = false;\n        this.controledOverOGB = true\n        this.worksWithCO2 = false;\n\n        // PHASE VARS\n        this.currentPlantPhase = {\n            phase:\"\",\n            min: 0,\n            max: 0,\n        };\n        this.PlantStageMinMax = {\n            Germ: {\n                min: 20,\n                max: 30,\n                phase:\"\",\n            },\n            Veg: {\n                min: 30,\n                max: 55,\n                phase:\"\",\n            },\n            Flower: {\n                min: 70,\n                max: 100,\n                phase:\"\",\n            },\n        };\n        // Sunrise and Sunset Data       \n        this.sunPhases={\n            sunRise:{\n                isSunRise: false,\n                isRunning: false,\n                time:\"\",\n                minSunRise:20,\n                maxSunRise: this.currentPlantPhase.max,\n            },\n            sunSet:{\n                isSunSet: false,\n                isRunning: false,\n                time: \"\",\n                minSunSet:20,\n                maxSunSet: this.currentPlantPhase.max,\n                startDuty: null,\n            }\n        }\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.setCurrenPlantPhaseName(context);\n        this.checkIfDimmable();\n        this.identifyIfControledByVoltage();\n        this.identifyIfControledByOGB(context.isPlantDay.lightbyOGBControl);\n        this.setLightTimes(context);\n        this.setSunTimes(context.isPlantDay.sunRiseTimes, context.isPlantDay.sunSetTimes);\n    \n        // **Validiere Sunrise und Sunset**\n        this.validateSunTimes();\n    \n        if (!this.controledOverOGB) {\n            this.resetOGBControl();\n        }\n    \n        if (!this.isInitialized) {\n            this.initializeDutyCycle();\n            this.isInitialized = true;\n        } else {\n            this.findDutyCycle();\n        }\n    }  \n    \n    initializeDutyCycle() {\n        if (!this.isDimmable) return;\n    \n        // Versuche, den Duty-Cycle zu finden\n        this.findDutyCycle();\n    \n        // Wenn kein Duty-Cycle gesetzt wurde, initialisiere ihn\n        if (this.dutyCycle === null || this.dutyCycle === undefined) {\n            this.dutyCycle = this.minDuty; // Setze auf den minimalen Wert der aktuellen Phase\n            console.log(`${this.inRoomName} - ${this.name}: Duty Cycle nicht gefunden. Initialisiere auf ${this.dutyCycle}%.`);\n        } else {\n            console.log(`${this.name}: Bestehender Duty Cycle gefunden: ${this.dutyCycle}%.`);\n        }\n    } \n\n    identifyIfControledByOGB(controledBY) {\n        if (typeof controledBY !== \"boolean\") {\n            console.log(`${this.inRoomName} - ${this.name}: Ungültiger Wert für controledBY.`);\n            return;\n        }\n    \n        if (this.controledOverOGB !== controledBY) {\n            this.controledOverOGB = controledBY;\n            if (!this.controledOverOGB) {\n                this.resetOGBControl();\n            }\n        }\n    }\n    \n    identifyIfControledByVoltage(){\n        if (!this.isDimmable) return;\n        const voltageKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n        );\n        if(voltageKey){\n            this.controlOverVoltage = true\n        }else{\n            this.controlOverVoltage = false\n        }\n    }\n\n    voltageFactorToDutyCycle(voltage) {\n        return Math.floor(voltage * 10);\n    }\n\n    resetOGBControl() {\n        if (!this.controledOverOGB) {\n            console.log(`${this.name}: Steuerung durch OGB deaktiviert. Alle relevanten Daten werden zurückgesetzt.`);\n    \n            // Zurücksetzen aller OGB-gesteuerten Variablen\n            this.resetPhaseAndTimes();\n            this.isScheduled = false;\n            this.isRunning = false;\n            this.dutyCycle = null;\n            this.controlOverVoltage = false;\n    \n            // Sicherstellen, dass alle Aktionen zurückgesetzt werden\n            this.action = \"unchanged\";\n    \n            // Entfernen von möglichen Locks\n            this.isLocked = false;\n            this.lockedFor = \"\";\n    \n            console.log(`${this.name}: Steuerung zurückgesetzt.`);\n        }\n    }\n    \n    validateSunTimes() {\n        if (!this.isDimmable) return;\n        // Überprüfen, ob Sunrise- oder Sunset-Zeit auf \"00:00:00\" gesetzt ist\n        if (!this.sunPhases.sunRise.time || this.sunPhases.sunRise.time === \"00:00:00\") {\n            this.sunPhases.sunRise.isSunRise = false;\n            console.log(`${this.name}: Sunrise deaktiviert, da Zeit auf 00:00:00 gesetzt ist oder nicht vorhanden.`);\n        } else {\n            this.sunPhases.sunRise.isSunRise = true;\n        }\n\n        if (!this.sunPhases.sunSet.time || this.sunPhases.sunSet.time === \"00:00:00\") {\n            this.sunPhases.sunSet.isSunSet = false;\n            console.log(`${this.name}: Sunset deaktiviert, da Zeit auf 00:00:00 gesetzt ist oder nicht vorhanden.`);\n        } else {\n            this.sunPhases.sunSet.isSunSet  = true;\n        }\n\n        console.log(`${this.name}: isSunrise: ${this.sunPhases.sunRise.isSunRise}, isSunset: ${this.sunPhases.sunSet.isSunSet}`);\n    }   \n   \n    findDutyCycle() {\n        if (!this.isDimmable) return;\n        if (!this.data) {\n            console.log(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n    \n        const voltageKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n        );\n    \n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\") ||\n            key.toLowerCase().includes(\"lightpower\")\n        );\n    \n        if (voltageKey) {\n            const voltageValue = parseFloat(this.data[voltageKey]);\n            if (!isNaN(voltageValue)) {\n                const calculatedDuty = this.voltageFactorToDutyCycle(voltageValue);\n                const clampedDuty = this.clampDutyCycle(calculatedDuty);\n                if (clampedDuty !== this.dutyCycle) {\n                    this.dutyCycle = clampedDuty;\n                    this.voltage = voltageValue;\n                    console.log(`${this.inRoomName} - ${this.name}: Duty Cycle aus Voltage berechnet: ${this.dutyCycle}%, Voltage: ${this.voltage}.`);\n                }\n            }\n        }\n    \n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                const clampedDuty = this.clampDutyCycle(dutyCycleValue);\n                if (clampedDuty !== this.dutyCycle) {\n                    this.dutyCycle = clampedDuty;\n                    console.log(`${this.inRoomName} - ${this.name}: Duty Cycle aus Daten gesetzt auf ${this.dutyCycle}%.`);\n                }\n            }\n        }\n    }\n    \n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    clampSunriseDuty(dutyCycle) {\n        return Math.max(this.sunPhases.sunRise.minSunRise, Math.min(this.sunPhases.sunRise.maxSunRise, dutyCycle));\n    } \n\n    clampSunsetDuty(duty) {\n        return Math.max(this.sunPhases.sunSet.minSunSet, Math.min(this.sunPhases.sunSet.maxSunSet, duty));\n    }\n\n    setCurrenPlantPhaseName(context) {\n        if (!context || !context.plantStage  ) return;\n        if (this.currentPlantPhase.phase !== context.plantStage ) {\n            this.currentPlantPhase.phase = context.plantStage;\n            this.setForPlantLightPhase();\n        }\n    }\n\n    setForPlantLightPhase() {\n        const phase = this.currentPlantPhase.phase;\n        if (phase.includes(\"Germination\") || phase.includes(\"Clones\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Germ };\n        } else if (phase.includes(\"Veg\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Veg };\n        } else if (phase.includes(\"Flower\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Flower };\n        }\n        this.minDuty = this.currentPlantPhase.min;\n        this.maxDuty = this.currentPlantPhase.max;\n        this.sunPhases.sunRise.maxSunRise = this.currentPlantPhase.max\n        this.sunPhases.sunSet.maxSunSet = this.currentPlantPhase.max\n    }\n\n    setLightTimes(context) {\n        if (!context) return;\n        const { lightOnTime, lightOffTime } = context.isPlantDay || {};\n        this.lightOnTime = lightOnTime;\n        this.lightOffTime = lightOffTime;\n\n        if (this.lightOnTime && this.lightOffTime !== \"\") {\n            this.isScheduled = true;\n        }\n    }\n\n    setSunTimes(sunRiseTime, sunSetTime) {\n        if (!this.isDimmable) return;\n        if (this.isDimmable) {\n            if (sunRiseTime || sunSetTime !== \"\") {\n                this.sunPhases.sunRise.time = sunRiseTime;\n                this.sunPhases.sunSet.time = sunSetTime;\n            }\n            this.validateSunTimes()\n        } else {\n            return { ERROR: \"NoDuty\" }\n        }\n\n    }\n\n    parseTime(timeString) {\n        if (!timeString || typeof timeString !== \"string\") {\n            console.log(\"DEBUG: Invalid time string provided:\", timeString);\n            return 0; // Fallback auf Mitternacht\n        }\n\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return (hours * 3600) + (minutes * 60) + seconds;\n    }\n\n    parseSunTime(timeString) {\n        if (!this.isDimmable) return \n        if (!timeString || typeof timeString !== \"string\") {\n            console.log(\"DEBUG: Invalid time string provided:\", timeString);\n            return 0; // Fallback auf Mitternacht\n        }\n\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return (hours * 3600) + (minutes * 60) + seconds;\n    }\n\n    checkforStartStop() {\n        if(!this.controledOverOGB)return\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n        const startTime = this.parseTime(this.lightOnTime);\n        const endTime = this.parseTime(this.lightOffTime);\n    \n        //console.log(`DEBUG: Current Time: ${currentSeconds}, Start Time: ${startTime}, End Time: ${endTime}`);\n    \n        let isLightOn;\n    \n        if (endTime < startTime) {\n            isLightOn = currentSeconds >= startTime || currentSeconds <= endTime;\n        } else {\n            isLightOn = currentSeconds >= startTime && currentSeconds <= endTime;\n        }\n    \n        //console.log(`DEBUG: Is Light On: ${isLightOn}, Is Running: ${this.isRunning}`);\n    \n        if (!isLightOn && this.isRunning) {\n            console.log(`${this.inRoomName} - ${this.name}: Turning light OFF as current time is outside schedule.`);\n            this.action = \"off\";\n            return this.turnOFF();\n        }\n    \n        if (isLightOn && !this.isRunning) {\n            console.log(`${this.inRoomName} - ${this.name}: Turning light ON as current time is within schedule.`);\n            this.action = \"on\";\n            return this.turnON();\n        }\n    \n        console.log(`${this.inRoomName} - ${this.name}: No changes needed for light ON/OFF schedule.`);\n        return null;\n    }\n\n    checkforPhase() {\n        if (!this.controledOverOGB) return;\n\n        this.validateSunTimes();\n        const currentTime = new Date();\n        const currentSeconds = this.parseSunTime(currentTime.toTimeString().split(\" \")[0]);\n\n        const lightOnSeconds = this.parseSunTime(this.lightOnTime);\n        const lightOffSeconds = this.parseSunTime(this.lightOffTime);\n        const sunRiseSeconds = this.parseSunTime(this.sunPhases.sunRise.time);\n        const sunSetSeconds = this.parseSunTime(this.sunPhases.sunSet.time);\n\n        const sunriseEndSeconds = lightOnSeconds + sunRiseSeconds;\n        const sunsetStartSeconds = lightOffSeconds - sunSetSeconds;\n\n        const actions = [];\n\n        //console.log(`DEBUG: Current Time (Seconds): ${currentSeconds}`);\n        //console.log(`DEBUG: Light On Time: ${lightOnSeconds}, Light Off Time: ${lightOffSeconds}`);\n        //console.log(`DEBUG: Sunrise End: ${sunriseEndSeconds}, Sunset Start: ${sunsetStartSeconds}`);\n        //console.log(`DEBUG: Current Duty Cycle: ${this.dutyCycle}`);\n        //console.log(`DEBUG: Current Voltage: ${this.voltage}`);\n\n        // **Sonnenaufgang (Sunrise Phase)**\n        if (this.sunPhases.sunRise.isSunRise && currentSeconds >= lightOnSeconds && currentSeconds <= sunriseEndSeconds) {\n            console.log(`${this.name}: Sunrise phase active.`);\n            this.sunPhases.sunRise.isRunning = true\n            const elapsedSunrise = currentSeconds - lightOnSeconds;\n            const totalSunriseDuration = sunRiseSeconds;\n\n            //console.log(`DEBUG: Elapsed Sunrise Seconds: ${elapsedSunrise}, Total Sunrise Duration: ${totalSunriseDuration}`);\n            //console.log(`DEBUG: MinSunRise: ${this.sunPhases.sunRise.minSunRise}, MaxSunRise: ${this.sunPhases.sunRise.maxSunRise}`);\n\n            const totalIncrement = this.sunPhases.sunRise.maxSunRise - this.sunPhases.sunRise.minSunRise;\n            const incrementFactor = Math.min(elapsedSunrise / totalSunriseDuration, 1);\n            const dutyIncrement = totalIncrement * incrementFactor;\n\n            //console.log(`DEBUG: Increment Factor: ${incrementFactor}, Duty Increment: ${dutyIncrement}`);\n\n            let newDuty = Math.floor(this.sunPhases.sunRise.minSunRise + dutyIncrement);\n\n            // **Erzwinge Maximalwert am Ende der Sunrise-Phase**\n            if (currentSeconds === sunriseEndSeconds) {\n                newDuty = this.sunPhases.sunRise.maxSunRise;\n                console.log(`${this.inRoomName} - ${this.name}: Sunrise phase ending. Forcing max Duty Cycle: ${newDuty}`);\n                this.sunPhases.sunRise.isRunning = false\n            }\n\n            const newVoltage = parseFloat((newDuty / 10).toFixed(1));\n\n            //console.log(`DEBUG: Calculated Duty: ${newDuty}, Voltage: ${newVoltage}`);\n\n            if (this.dutyCycle !== newDuty || this.voltage !== newVoltage) {\n                //console.log(`DEBUG: Sunrise Phase - New Duty Cycle: ${newDuty}, Voltage: ${newVoltage}`);\n                actions.push(this.changeDuty(newDuty));\n            } else {\n                //console.log(`DEBUG: No changes to Duty Cycle during Sunrise Phase.`);\n            }\n        }\n\n\n        // **Sonnenuntergang (Sunset Phase)**\n        if (this.sunPhases.sunSet.isSunSet && currentSeconds >= sunsetStartSeconds && currentSeconds <= lightOffSeconds) {\n            console.log(`${this.inRoomName} - ${this.name}: Sunset phase active.`);\n            this.sunPhases.sunSet.isRunning = true\n            // Speichere den Start-Duty-Cycle bei Beginn der Sunset-Phase\n            if (this.sunPhases.sunSet.startDuty === null) {\n                this.sunPhases.sunSet.startDuty = this.dutyCycle; // Initialisiere den Start-Duty-Cycle\n                //console.log(`DEBUG: Sunset Start Duty Cycle initialized: ${this.sunPhases.sunSet.startDuty}`);\n            }\n\n            const elapsedSunset = currentSeconds - sunsetStartSeconds;\n            const totalSunsetDuration = sunSetSeconds;\n\n            //console.log(`DEBUG: Elapsed Sunset Seconds: ${elapsedSunset}, Total Sunset Duration: ${totalSunsetDuration}`);\n\n            const totalDecrement = this.sunPhases.sunSet.startDuty - this.sunPhases.sunSet.minSunSet; // Differenz vom Start-Duty-Cycle\n            const decrementFactor = Math.min(elapsedSunset / totalSunsetDuration, 1); // Fortschritt (0-1)\n            const dutyDecrement = totalDecrement * decrementFactor;\n\n            //console.log(`DEBUG: Decrement Factor: ${decrementFactor}, Duty Decrement: ${dutyDecrement}`);\n\n            const newDuty = this.clampSunsetDuty(\n                Math.floor(this.sunPhases.sunSet.startDuty - dutyDecrement) // Subtrahiere Reduktion von Start-Duty\n            );\n            const newVoltage = parseFloat((newDuty / 10).toFixed(1)); // Voltage = DutyCycle / 10\n\n            //console.log(`DEBUG: Calculated Duty: ${newDuty}, Voltage: ${newVoltage}`);\n\n            if (this.dutyCycle !== newDuty || this.voltage !== newVoltage) {\n                //console.log(`DEBUG: Sunset Phase - New Duty Cycle: ${newDuty}, Voltage: ${newVoltage}`);\n                actions.push(this.changeDuty(newDuty)); // Aktualisiert Werte korrekt\n            } else {\n                //console.log(`DEBUG: No changes to Duty Cycle during Sunset Phase.`);\n            }\n\n            // Zurücksetzen des Start-Duty-Cycle bei Ende der Sunset-Phase\n            if (currentSeconds > lightOffSeconds) {\n                this.sunPhases.sunSet.startDuty = null; // Zurücksetzen\n                this.sunPhases.sunSet.isRunning = false\n            }\n        }\n\n        return actions;\n    }\n    \n    resetPhaseAndTimes() {\n        this.action = \"Unchanged\"\n        this.currentPlantPhase.max = 0\n        this.currentPlantPhase.min = 0\n        this.dutyCycle = null\n        this.minDuty = null\n        this.maxDuty = null\n        this.lightOnTime = \"\"\n        this.lightOffTime = \"\"\n        this.sunPhases.sunRise.time = \"00:00:00\"\n        this.sunPhases.sunSet.time = \"00:00:00\"\n    }\n\n    handleGeneralControl() {\n        if(this.controledOverOGB){\n            if (!this.isDimmable) {\n                console.log(`${this.inRoomName} - ${this.name}: Gerät nicht Dimmbar.`);\n                return { Light: `${this.switches[0]}`, Action: \"NoDimmeActionPossible\" };\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                let newDuty;\n                switch (this.action) {\n                    case \"increased\":\n                        newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                        break;\n                    case \"reduced\":\n                        newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                        break;\n                    case \"maximum\":\n                        newDuty = this.maxDuty;\n                        break;\n                    case \"minimum\":\n                        newDuty = this.minDuty;\n                        break;\n                    case \"reset\":\n                        newDuty = this.minDuty;\n                        break;\n                    default:\n                        return null; // Unbekannte Aktion\n                }\n        \n                if (newDuty !== this.dutyCycle) {\n                    return this.changeDuty(newDuty);\n                }\n            }\n        \n            return null; // Keine Änderungen notwendig\n        }else{\n            return null \n        }\n   \n    }\n    \n    runAction() {\n        if (!this.controledOverOGB) {\n            console.log(`${this.inRoomName} - ${this.name}: Steuerung durch OGB deaktiviert.`);\n            return { Light: `${this.switches[0]}`, Action: \"NoControlForOGB\" };\n        }\n        \n        if(this.controledOverOGB){\n            // Prüfen, ob Start/Stop-Logik angewendet werden muss\n            const startStopAction = this.checkforStartStop();\n            if (startStopAction) {\n                return [startStopAction]; // Priorisiere Start/Stop\n            }\n        }\n\n    \n        const actions = [];\n    \n        // Sunrise/Sunset-Logik prüfen\n        const phaseActions = this.checkforPhase();\n        if (phaseActions && phaseActions.length > 0) {\n            console.log(`${this.inRoomName} - ${this.name} SunPhase actions found, skipping general actions.`);\n            actions.push(...phaseActions);\n        }\n    \n        // Allgemeine Steuerung ausführen, wenn keine Phase aktiv ist\n        if (!phaseActions || phaseActions.length === 0) {\n            console.log(\"DEBUG: No active phase. Executing general control.\");\n            const generalAction = this.handleGeneralControl();\n            if (generalAction) {\n                actions.push(generalAction);\n            }\n        }\n    \n        // Entfernen redundanter Aktionen\n        const filteredActions = actions.filter((action, index, self) =>\n            self.findIndex(a => a.entity_id === action.entity_id && a.action === action.action) === index\n        );\n    \n        //console.log(`DEBUG: Actions nach Verarbeitung: ${JSON.stringify(filteredActions, null, 2)}`);\n        return filteredActions.length > 0 ? filteredActions : [];\n    }\n\n    changeDuty(newDuty) {\n        if (!this.isDimmable) {\n            return { entity_id: this.switches[0], action: \"NoDutyCycle\" };\n        }\n    \n        const clampedDuty = Math.max(this.sunPhases.sunRise.minSunRise, Math.min(this.sunPhases.sunRise.maxSunRise, newDuty));\n        const newVoltage = parseFloat((clampedDuty / 10).toFixed(1)); // Voltage = DutyCycle / 10\n    \n        //console.log(`DEBUG: Current DutyCycle: ${this.dutyCycle}, New DutyCycle: ${clampedDuty}`);\n        //console.log(`DEBUG: Current Voltage: ${this.voltage}, New Voltage: ${newVoltage}`);\n    \n        // Fall: Kontrolle nur über Voltage\n        if (this.controlOverVoltage) {\n            if (this.voltage !== newVoltage) {\n                this.voltage = newVoltage;\n                this.dutyCycle = clampedDuty; // Voltage und Duty synchronisieren\n                console.log(`${this.name}: Voltage wird aktualisiert.`);\n                const voltageEntity = this.sensors.find(key =>\n                    key.toLowerCase().includes(\"voltage\")\n                );\n                return [\n                    { entity_id: voltageEntity, action: \"number\", value: newVoltage }\n                ];\n            }\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n    \n        // Fall: Kontrolle über DutyCycle\n        if (this.dutyCycle === clampedDuty && this.voltage === newVoltage) {\n            console.log(`${this.inRoomName} - ${this.name}: Keine Änderung nötig. Duty-Cycle und Voltage bleiben gleich.`);\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n    \n        // Aktualisiere Werte\n        this.dutyCycle = clampedDuty;\n        this.voltage = newVoltage;\n    \n        return [\n            { entity_id: this.switches[0], action: \"dutycycle\", dutycycle: clampedDuty }\n        ];\n    }\n\n    turnLightON() {\n        const entity = this.switches[0];\n\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.inRoomName} - ${this.name}: Gerät wurde eingeschaltet in ${this.inRoomName}.`);\n\n            if (this.isDimmable) {\n                const newVoltage = parseFloat((this.dutyCycle / 10).toFixed(1));\n                this.voltage = newVoltage;\n\n                const voltageEntity = this.sensors.find(key =>\n                    key.toLowerCase().includes(\"voltage\")\n                );\n\n                console.log(`${this.name}: Voltage auf ${newVoltage}V gesetzt basierend auf Duty-Cycle ${this.dutyCycle}.`);\n                return [\n                    { entity_id: entity, action: \"on\" },\n                    { entity_id: voltageEntity, action: \"number\", value: newVoltage }\n                ];\n            }\n\n            return { entity_id: entity, action: \"on\" };\n        } else {\n            console.log(`${this.name}: Gerät ist bereits eingeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"AlreadyON\" };\n        }\n    \n\n    }\n\n    turnLightOFF() {\n        const entity = this.switches[0]; // Dynamische Entität\n        if (this.isRunning) {\n            this.isRunning = false;\n            console.log(`${this.inRoomName} - ${this.name}: Gerät wurde ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"off\" };\n        } else {\n            console.log(`${this.inRoomName} - ${this.name}: Gerät ist bereits ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"AlreadyOFF\" };\n        }\n    }\n\n}\n\nclass Exhaust extends Device {\n    constructor(name) {\n        super(name, \"exhaust\");\n        this.isInitialized = false;\n        this.dutyCycle = null;\n        this.minDuty = 10;\n        this.maxDuty = 95;\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.checkIfDimmable();\n        if (!this.isInitialized) {\n            this.initializeDutyCycle();\n            this.isInitialized = true;\n        } else {\n            this.findDutyCycle();\n        }\n    }\n\n    initializeDutyCycle() {\n        if (!this.isDimmable) return\n        let initDuty = 50\n        this.dutyCycle = initDuty; // Initialisiere auf 50%\n        node.warn(`${this.inRoomName} - ${this.name}: Initialisiere Duty Cycle auf ${this.dutyCycle}%.`);\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.inRoomName} - ${this.name}: Keine Gerätedaten vorhanden.`);\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                if (dutyCycleValue === this.dutyCycle) return\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                //node.warn(`${this.name}: Duty Cycle aus Daten gesetzt auf ${this.dutyCycle}%.`);\n            }\n        } else {\n            node.warn(`${this.inRoomName} - ${this.name}: Kein Duty Cycle-Schlüssel gefunden.`);\n        }\n    }\n\n    setDutyCycle(dutyCycle) {\n        const clampedDuty = this.clampDutyCycle(dutyCycle);\n\n        if (clampedDuty !== this.dutyCycle) {\n            this.dutyCycle = clampedDuty;\n            return clampedDuty;\n        }\n\n        return\n\n    }\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    changeDuty(duty) {\n        const newDuty = this.clampDutyCycle(duty);\n        if (this.switches?.[0]) {\n            const switchId = this.switches[0];\n            if (newDuty !== this.dutyCycle) {\n                const clampedDuty = this.clampDutyCycle(duty);\n                this.dutyCycle = clampedDuty;\n            } else {\n                return { entity_id: switchId, action: \"SameDuty\", dutycycle: newDuty };\n            }\n\n            node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle ${this.dutyCycle} an Abluft ${switchId} gesendet.`);\n            return { entity_id: switchId, action: \"dutycycle\", dutycycle: newDuty };\n        } else {\n            return { error: \"No switch available\" };\n        }\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { Exhaust: `${this.name}`, Action: \"NoChangeNeeded\" };\n        }\n\n        const switchId = this.switches?.[0];\n        if (!switchId) {\n            return { error: \"No switch available\" };\n        }\n\n        switch (this.action) {\n            case \"maximum\":\n                if (this.isDimmable) {\n                    return this.changeDuty(this.maxDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"minimum\":\n                if (this.isDimmable) {\n                    return this.changeDuty(this.minDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"increased\":\n                if (this.isDimmable) {\n                    const increasedDuty = Math.min(this.dutyCycle + 5, this.maxDuty);\n                    return this.changeDuty(increasedDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"reduced\":\n                if (this.isDimmable) {\n                    const reducedDuty = Math.max(this.dutyCycle - 5, this.minDuty);\n                    return this.changeDuty(reducedDuty);\n                } else {\n                    return this.turnOFF(switchId);\n                }\n\n\n            case \"on\":\n                return this.turnON(switchId);\n\n            case \"off\":\n                return this.turnOFF(switchId);\n\n            case \"unchanged\":\n                return { entity_id: switchId, action: \"UNCHANGED\" };\n\n            default:\n                node.warn(`${this.inRoomName} - ${this.name}: Unbekannte Aktion.`);\n                return { Exhaust: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.inRoomName} - ${this.name}: Lüfter eingeschaltet in ${this.inRoomName}.`);\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.inRoomName} - ${this.name}: Lüfter ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n}\n\nclass Ventilation extends Device {\n    constructor(name) {\n        super(name, \"ventilation\");\n        this.dutyCycle = null; // Startwert\n        this.maxDuty = 75;   // Minimalwert\n        this.minDuty = 100;  // Maximalwert\n        this.isInitialized = false;\n        this.isTasmota = false;\n\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.checkIfDimmable();\n        this.identifyIfTasmota(); // Prüfe, ob es ein Tasmota-Gerät ist\n\n        if (this.isTasmota) {\n            // Für Tasmota-Geräte initialisiere Duty Cycle und überspringe findDutyCycle\n            if (!this.isInitialized) {\n                this.initializeDutyCycle();\n                this.isInitialized = true;\n            }\n            return;\n        }\n\n        // Für Nicht-Tasmota-Geräte den Duty Cycle aus den Daten suchen\n        if (!this.isInitialized) {\n            this.initializeDutyCycle();\n            this.isInitialized = true;\n        } else {\n            this.findDutyCycle();\n        }\n    }\n\n    initializeDutyCycle() {\n        if (!this.isDimmable) return\n        let initDuty = 50\n        this.dutyCycle = initDuty; // Initialisiere auf 50%\n        node.warn(`${this.name}: Initialisiere Duty Cycle auf ${this.dutyCycle}%.`);\n    }\n\n    identifyIfTasmota() {\n        this.isTasmota = this.switches.some(\n            (switchDevice) => typeof switchDevice === \"string\" && switchDevice.startsWith(\"light.\")\n        );\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                if (dutyCycleValue === this.dutyCycle) return\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                //node.warn(`${this.name}: Duty Cycle aus Daten gesetzt auf ${this.dutyCycle}%.`);\n            }\n        } else {\n            node.warn(`${this.inRoomName} - ${this.name}: Kein Duty Cycle-Schlüssel gefunden.`);\n        }\n    }\n\n    setDutyCycle(dutyCycle) {\n        const clampedDuty = this.clampDutyCycle(dutyCycle);\n\n        if (clampedDuty !== this.dutyCycle) {\n            this.dutyCycle = clampedDuty;\n            return clampedDuty;\n        }\n\n        return\n\n    }\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    changeDuty(switchId, duty) {\n        const newDuty = this.clampDutyCycle(duty);\n\n        if (newDuty !== this.dutyCycle) {\n            const clampedDuty = this.clampDutyCycle(duty);\n            this.dutyCycle = clampedDuty;\n        } else {\n            return { entity_id: switchId, action: \"SameDuty\", dutycycle: newDuty };\n        }\n\n        node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle ${this.dutyCycle} an Vents ${switchId} gesendet.`);\n        return { entity_id: switchId, action: \"dutycycle\", dutycycle: newDuty };\n    }\n\n    runAction() {\n        if (!this.needChange) return { Ventilation: `${this.switches[0]}`, Action: \"NoChangeNeeded\" };\n\n        const results = [];\n        const applyActionToSwitches = (actionCallback) => {\n            return this.switches.map((switchId) => {\n                const result = actionCallback(switchId);\n                results.push(result);\n                return result;\n            });\n        };\n\n        switch (this.action) {\n            case \"maximum\":\n                node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle auf Maximum (${this.maxDuty}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.maxDuty));\n\n            case \"minimum\":\n                node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle auf Minimum (${this.minDuty}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.minDuty));\n\n            case \"reduced\":\n                const reducedDuty = Math.max(this.dutyCycle - 5, this.minDuty);\n                node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle reduziert auf ${reducedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, reducedDuty));\n\n            case \"increased\":\n                const increasedDuty = Math.min(this.dutyCycle + 5, this.maxDuty);\n                node.warn(`${this.inRoomName} - ${this.name}: Duty Cycle erhöht auf ${increasedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, increasedDuty));\n\n            case \"on\":\n                return applyActionToSwitches((switchId) => this.turnON(switchId));\n\n            case \"off\":\n                return applyActionToSwitches((switchId) => this.turnOFF(switchId));\n\n            case \"unchanged\":\n                node.warn(`${this.inRoomName} - ${this.name}: Keine Änderung erforderlich.`);\n                return applyActionToSwitches((switchId) => ({ entity_id: switchId, action: \"UNCHANGED\" }));\n\n            default:\n                node.warn(`${this.inRoomName} - ${this.name}: Unbekannte Aktion.`);\n                return { Ventilation: `${this.switches[0]}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n}\n\nclass Climate extends Device {\n    constructor(name) {\n        super(name, \"climate\");\n        this.currentHAVOC = \"off\"; // Standardzustand\n        this.havocs = {\n            dry: \"dry\",\n            cool: \"cool\",\n            hot: \"hot\",\n            heat: \"heat\",\n            wind: \"wind\",\n            off: \"off\",\n        };\n        this.isRunning = false; // Status der Klimaanlage\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyCurrentHavoc();\n    }\n\n    identifyCurrentHavoc() {\n        const havocDevice = this.switches[0];\n        if (!havocDevice) {\n            console.warn(`${this.inRoomName} - ${this.name}: Keine Switches definiert, um HAVOC zu identifizieren.`);\n            return;\n        }\n\n        const havocValue = this.data[havocDevice];\n\n        if (havocValue && Object.values(this.havocs).includes(havocValue)) {\n            this.currentHAVOC = havocValue;\n            console.warn(`${this.inRoomName} - ${this.name}: HAVOC-Modus gesetzt auf \"${this.currentHAVOC}\".`);\n        } else {\n            console.warn(`${this.inRoomName} - ${this.name}: Ungültiger HAVOC-Wert \"${havocValue}\", Standardwert \"off\" wird verwendet.`);\n        }\n    }\n\n    runAction() {\n        if (!this.needChange || !this.action || typeof this.action !== \"object\") {\n            console.warn(`${this.inRoomName} - ${this.name}: Keine Änderungen erforderlich.`);\n            return null;\n        }\n\n        const { mode, action } = this.action;\n        const lowerMode = mode.toLowerCase(); // Konvertiere in Kleinbuchstaben\n        const validMode = this.havocs[lowerMode]; // Vergleiche mit `havocs` Mapping\n\n        //console.warn(`${this.inRoomName} - Aktion empfangen: Mode = \"${mode}\", Action = \"${action}\", ValidMode = \"${validMode}\", CurrentHAVOC = \"${this.currentHAVOC}\"`);\n\n        // Prüfen, ob der Modus ungültig ist\n        if (!validMode) {\n            console.warn(`${this.inRoomName} - ${this.name}: Ungültiger Modus \"${mode}\" erhalten. Standardwert \"off\" wird verwendet.`);\n            return { entity_id: this.switches[0], action: \"invalid_mode\", received_mode: mode };\n        }\n\n        // Prüfen, ob der Modus bereits läuft\n        if (this.isRunning && this.currentHAVOC.toLowerCase() === validMode) {\n            console.warn(`${this.inRoomName} - ${this.name}: Keine Änderungen notwendig. Der Modus \"${validMode}\" ist bereits aktiv.`);\n            return { entity_id: this.switches[0], action: \"AllReady_ON\", climate_mode: this.currentHAVOC };\n        }\n\n        if (action === \"off\") {\n            return this.turnOFF();\n        }\n\n        if (!this.isRunning) {\n            return this.turnON(validMode);\n        }\n\n        return this.changeMode(validMode);\n    }\n\n    turnON(mode) {\n        this.isRunning = true;\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_Running\", climate_mode: mode };\n        }\n\n    }\n\n    turnOFF() {\n        if (this.isRunning) {\n            const previousMode = this.currentHAVOC;\n\n            if (this.isRunning === true) {\n                this.isRunning = false;\n                this.currentHAVOC = \"off\";\n                return { entity_id: this.switches[0], action: \"off\", previous_mode: previousMode };\n            } else {\n                return { entity_id: this.switches[0], action: \"AllreadyOFF\", previous_mode: previousMode };\n            }\n        }\n        return { entity_id: this.switches[0], action: \"already_off\" };\n    }\n\n    changeMode(mode) {\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_OFF\", climate_mode: mode };\n        }\n\n    }\n}\n\nclass Humidifier extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.targetHumidity = 0; // Ziel-Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n        this.realHumidifier = false; // Erkennung eines echten Luftbefeuchters\n        this.hasModes = false; // Erkennung von Modis\n        this.isSimpleSwitch = true; // Gerät ist nur ein einfacher Schalter\n        this.modes = {\n            interval: true,\n            small: false,\n            large: false,\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyIfHasModes();\n    }\n\n    identifyMode() {\n        if (!this.sensors || !Array.isArray(this.sensors)) {\n            console.log(`${this.name}: Keine Sensoren definiert.`);\n            return;\n        }\n\n        // Suche nach einem passenden Sensor (select.* und mode im Namen)\n        const modeSensor = this.sensors.find(sensor => sensor.startsWith(\"select.\") && sensor.includes(\"mode\"));\n\n        if (!modeSensor) {\n            console.log(`${this.name}: Kein passender Modus-Sensor gefunden.`);\n            return;\n        }\n\n        // Moduswert aus den Daten extrahieren\n        const modeValue = this.data[modeSensor];\n\n        if (!modeValue || modeValue === \"unavailable\") {\n            console.log(`${this.name}: Kein gültiger Moduswert verfügbar für Sensor \"${modeSensor}\".`);\n            return;\n        }\n\n        // Alle Modi zurücksetzen\n        this.modes = {\n            interval: false,\n            small: false,\n            large: false,\n        };\n\n        // Modus basierend auf dem Wert setzen\n        switch (modeValue) {\n            case \"interval\":\n                this.modes.interval = true;\n                break;\n            case \"small\":\n                this.modes.small = true;\n                break;\n            case \"large\":\n                this.modes.large = true;\n                break;\n            default:\n                console.log(`${this.name}: Unbekannter Moduswert \"${modeValue}\" für Sensor \"${modeSensor}\".`);\n                break;\n        }\n\n        //console.log(`${this.name}: Modus erkannt: ${modeValue}`);\n    }\n\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.isSimpleSwitch = true;\n                this.realHumidifier = false;\n            } else {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n            }\n        } else {\n            console.log(`${this.name}: Keine Daten vorhanden, Standard: Einfacher Schalter.`);\n            this.realHumidifier = false;\n            this.isSimpleSwitch = true;\n        }\n    }\n\n    identifyIfHasModes() {\n        if (this.data && this.data[\"select.humidifier_mode\"]) {\n            this.realHumidifier = true;\n            this.hasModes = true;\n            this.isSimpleSwitch = false;\n            this.identifyMode()\n        } else {\n            this.hasModes = false;\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) {\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n        const entity = this.sensors[0];\n        this.targetHumidity = humlevel;\n        console.log(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        // Wenn es ein einfacher Schalter ist\n        if (this.isSimpleSwitch) {\n            return this.action === \"increased\" || this.action === \"on\"\n                ? this.turnON()\n                : this.turnOFF();\n        }\n\n        // Für komplexe Geräte mit Modi\n        if (this.hasModes && this.realHumidifier) {\n            const actions = [];\n\n            // Gerät einschalten, falls es aus ist\n            if (!this.isRunning) {\n                const turnOnAction = this.turnON();\n                actions.push(turnOnAction);\n            }\n\n            // Modusänderung basierend auf der Aktion\n            if (this.action === \"increased\") {\n                const modeActions = this.changeMode(\"increase\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"reduced\") {\n                const modeActions = this.changeMode(\"decrease\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"off\") {\n                const turnOffAction = this.turnOFF();\n                actions.push(turnOffAction);\n            }\n\n            return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Action Found\" };\n        }\n\n        console.log(`${this.name}: Keine passenden Aktionen gefunden.`);\n        return { entity_id: this.switches[0], action: \"No Action Found\" };\n    }\n\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            this.closeModes()\n            console.log(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    closeModes(){\n        this.modes.small = true\n        this.modes.interval = false\n        this.modes.large = false\n    }\n\n    changeMode(direction) {\n        if (!this.hasModes) {\n            console.log(`${this.name}: Moduswechsel nicht unterstützt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n    \n        const actions = [];\n    \n        // Modusänderung basierend auf der Richtung\n        if (direction === \"increase\") {\n            // Wenn das Gerät aus ist und der Modus \"small\" ist, setze \"interval\"\n            if (!this.isRunning && this.modes.small) {\n                this.modes.interval = true;\n                this.modes.small = false;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n            // Wenn das Gerät läuft und im Modus \"small\" ist, wechsle direkt zu \"large\"\n            else if (this.isRunning && this.modes.small) {\n                this.modes.interval = false;\n                this.modes.small = false;\n                this.modes.large = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n            // Wenn der Modus \"interval\" ist, setze ihn auf \"small\"\n            else if (this.modes.interval) {\n                this.modes.interval = false;\n                this.modes.small = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            // Wenn der Modus \"small\" ist, setze ihn auf \"large\"\n            else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.large = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n        } else if (direction === \"decrease\") {\n            // Wenn der Modus \"large\" ist, setze ihn auf \"small\"\n            if (this.modes.large) {\n                this.modes.large = false;\n                this.modes.small = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            // Wenn der Modus \"small\" ist, setze ihn auf \"interval\"\n            else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n            // Wenn der Modus \"interval\" ist, schalte das Gerät aus\n            else if (this.modes.interval) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                this.modes.large = false;\n                actions.unshift({ entity_id: this.switches[0], action: \"off\" });\n                console.log(`${this.name}: Luftbefeuchter wird ausgeschaltet.`);\n            }\n        }\n    \n        // Gerät einschalten, wenn es aus ist\n        if (!this.isRunning) {\n            this.isRunning = true;\n            actions.unshift({ entity_id: this.switches[0], action: \"on\" });\n            console.log(`${this.name}: Luftbefeuchter wird eingeschaltet.`);\n        }\n    \n        // Rückgabe der Aktionen\n        return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Change\" };\n    }\n    \n\n    changeHumidity(delta) {\n        if (!this.realHumidifier) {\n            console.log(`${this.name}: Luftfeuchtigkeit kann nicht geändert werden, da es sich um einen einfachen Schalter handelt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            console.log(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        console.log(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"number\", value: newHumidity };\n    }\n}\n\nclass Dehumidifier extends Device {\n    constructor(name) {\n        super(name, \"dehumidifier\");\n        this.realHumidifier = false; // Erkennung eines echten Luftentfeuchters\n        this.isSimpleSwitch = false; // Standardmäßig ein einfacher Schalter\n        this.hasModes = false; // Erkennung von Modis\n        this.currentMode = null; // Aktueller Modus des Luftentfeuchters\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyDehumidifierType();\n    }\n\n\n\n    identifyDehumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n                this.hasModes = true;\n                this.currentMode = \"dry\"; // Standardmodus\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n                this.hasModes = false;\n                this.currentMode = null;\n            } else {\n                console.log(`${this.name}: Keine gültigen Daten gefunden, Standard auf einfacher Schalter.`);\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n                this.hasModes = false;\n                this.currentMode = null;\n            }\n        }\n    }\n\n    runAction() {\n        // Wenn keine Änderung nötig ist, gib aktuellen Zustand zurück\n        if (!this.needChange) {\n            if (this.action === \"reduced\" && !this.isRunning) {\n                return { entity_id: this.switches[0], action: \"Already OFF\" };\n            } else if (this.action === \"increased\" && this.isRunning) {\n                return { entity_id: this.switches[0], action: \"Already ON\" };\n            }\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        // Aktionen für einfache Schalter\n        if (this.isSimpleSwitch) {\n            if (this.action === \"reduced\") {\n                return this.turnOFF();\n            } else if (this.action === \"increased\") {\n                return this.turnON();\n            }\n        }\n\n        // Aktionen für echte Luftentfeuchter\n        if (this.realHumidifier) {\n            if (this.action === \"reduced\") {\n                return this.turnOFF();\n            } else if (this.action === \"increased\") {\n                return this.activateDryMode();\n            }\n        }\n\n        // Wenn keine passende Aktion gefunden wurde\n        console.log(`${this.name}: Keine passenden Aktionen gefunden.`);\n        return { entity_id: this.switches[0], action: \"No Action Found\" };\n    }\n\n\n    activateDryMode() {\n        const entity = this.sensors.find(sensor => sensor.startsWith(\"humidifier.\"));\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Luftentfeuchter im Modus \"dry\" eingeschaltet in ${this.inRoomName}`);\n            return [\n                { entity_id: this.switches[0], action: \"on\" }, // Gerät einschalten\n                { entity_id: entity, action: \"select\", option: \"dry\" }, // Modus auf \"dry\" setzen\n            ];\n        }\n        return { entity_id: this.switches[0], action: \"Already ON\" };\n    }\n\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        } else {\n            return { entity_id: entity, action: \"Already ON\" };\n        }\n\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            console.log(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        } else {\n            return { entity_id: entity, action: \"Already OFF\" };\n        }\n\n    }\n}\n\nclass Heater extends Device {\n    constructor(name) {\n        super(name, \"heater\");\n    }\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.inRoomName} - ${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.inRoomName} - ${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.inRoomName} - ${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\nclass Cooler extends Device {\n    constructor(name) {\n        super(name, \"cooler\");\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.inRoomName} - ${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.inRoomName} - ${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.inRoomName} - ${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\n//NEED TO TEST THIS \nclass Pump extends Device {\n    constructor(name) {\n        super(name, \"pump\");\n        this.pumpInterval = 3600; // Mindestintervall zwischen Pumpzyklen (in Sekunden)\n        this.pumpDuration = 10; // Pumpdauer in Sekunden\n        this.isAutoRun = false; // Automatikmodus\n        this.OGBAutoMODE = false; // OpenGrowBox Steuerung\n        this.lastPumpTime = null; // Zeitpunkt des letzten Pumpvorgangs\n        this.soilMoisture = 0; // Bodenfeuchtigkeit\n        this.soilEC = 0; // Elektrische Leitfähigkeit\n        this.minSoilMoisture = 25; // Mindestbodenfeuchte\n        this.maxSoilEC = 2.5; // Maximaler EC-Wert\n    }\n\n    // Gerätedaten setzen und Bodenwerte aktualisieren\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.evaluateStateFromData();\n        this.identifyIfOGBControlled(context);\n\n        // Aktualisiere Sensorwerte\n        if (data.soilmoisture) this.soilMoisture = parseFloat(data.soilmoisture);\n        if (data.soilec) this.soilEC = parseFloat(data.soilec);\n    }\n\n    // Prüfe OpenGrowBox Steuerung\n    identifyIfOGBControlled(context) {\n        this.OGBAutoMODE = !!context.controls.co2Control;\n    }\n\n    // Status aus Gerätedaten evaluieren\n    evaluateStateFromData() {\n        if (this.data) {\n            const pumpOnKey = Object.keys(this.data).find(key => key.includes(\"pump_on\"));\n            if (pumpOnKey) this.isRunning = this.data[pumpOnKey] === \"on\";\n\n            const autoRunKey = Object.keys(this.data).find(key => key.includes(\"pump_autorun\"));\n            if (autoRunKey) this.isAutoRun = this.data[autoRunKey] === \"on\";\n        }\n    }\n\n    // Mindestintervall prüfen\n    canPumpNow() {\n        const now = new Date();\n        const elapsedTime = this.lastPumpTime\n            ? (now.getTime() - this.lastPumpTime.getTime()) / 1000\n            : this.pumpInterval;\n\n        return elapsedTime >= this.pumpInterval;\n    }\n\n    // Prüfe, ob Bewässerung notwendig ist\n    needsWatering() {\n        return this.soilMoisture < this.minSoilMoisture && this.soilEC < this.maxSoilEC;\n    }\n\n    // Geräteaktionen ausführen\n    runAction(context) {\n        // Prüfe ob AutoModus aktiv ist\n        if (this.isAutoRun) {\n            return this.runAutoMode();\n        }\n\n        switch (this.action) {\n            case \"on\":\n                return this.runPump(\"on\");\n            case \"off\":\n                return this.runPump(\"off\");\n            case \"autorun-on\":\n                return this.setAutoMode(true);\n            case \"autorun-off\":\n                return this.setAutoMode(false);\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { entity_id: this.switches[0], action: \"UnknownAction\" };\n        }\n    }\n\n    // Automatische Steuerung der Pumpe\n    runAutoMode() {\n        if (!this.canPumpNow()) {\n            node.warn(`${this.name}: Intervall nicht erreicht.`);\n            return { entity_id: this.switches[0], action: \"wait_interval\" };\n        }\n\n        if (!this.needsWatering()) {\n            node.warn(`${this.name}: Keine Bewässerung notwendig (Moisture: ${this.soilMoisture}, EC: ${this.soilEC}).`);\n            return { entity_id: this.switches[0], action: \"no_water_needed\" };\n        }\n\n        this.lastPumpTime = new Date();\n        this.isRunning = true;\n\n        node.warn(`${this.name}: Starte automatische Bewässerung.`);\n        return { entity_id: this.switches[0], action: \"on\", duration: this.pumpDuration };\n    }\n\n    // Manuelle Pumpaktion ausführen\n    runPump(state) {\n        if (state === \"on\" && !this.isRunning) {\n            this.isRunning = true;\n            this.lastPumpTime = new Date();\n            node.warn(`${this.name}: Pumpe manuell eingeschaltet.`);\n            return { entity_id: this.switches[0], action: \"on\" };\n        } else if (state === \"off\" && this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Pumpe manuell ausgeschaltet.`);\n            return { entity_id: this.switches[0], action: \"off\" };\n        } else {\n            return { entity_id: this.switches[0], action: `Already ${state.toUpperCase()}` };\n        }\n    }\n\n    // AutoModus setzen\n    setAutoMode(state) {\n        this.isAutoRun = state;\n        const action = state ? \"on\" : \"off\";\n        node.warn(`${this.name}: Automatikmodus ${state ? \"aktiviert\" : \"deaktiviert\"}.`);\n        return { entity_id: this.switches[1], action: action };\n    }\n}\n\nclass CO2 extends Device {\n    constructor(name) {\n        super(name, \"co2\"); // Setze den Gerätetyp auf \"co2\"\n        this.targetCO2 = 0; // Zielwert für CO2 (ppm)\n        this.currentCO2 = 0; // Aktueller CO2-Wert (ppm)\n        this.autoRegulate = false; // Automatische Steuerung\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    setTargetCO2(target) {\n        if (target !== this.targetCO2) {\n            this.targetCO2 = target;\n        }\n    }\n\n    enableAutoRegulation() {\n        if (!this.enableAutoRegulation) {\n            this.autoRegulate = true;\n        }\n    }\n\n    disableAutoRegulation() {\n        if (this.enableAutoRegulation) {\n            this.autoRegulate = false;\n        }\n    }\n\n    updateCurrentCO2(value) {\n        if (value !== this.currentCO2) {\n            this.currentCO2 = value;\n        }\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") return false;\n\n        if (this.autoRegulate && this.currentCO2 < this.targetCO2) {\n            this.action = \"increased\";\n            return true;\n        } else if (this.autoRegulate && this.currentCO2 > this.targetCO2) {\n            this.action = \"reduced\";\n            return true;\n        }\n\n        return this.action !== \"unchanged\";\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { CO2: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"increased\":\n                node.warn(`${this.name}: CO2-Zufuhr wird erhöht.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"reduced\":\n                node.warn(`${this.name}: CO2-Zufuhr wird gestoppt.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"on\":\n                node.warn(`${this.name}: CO2-Zufuhr wird aktiviert.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: CO2-Zufuhr wird deaktiviert.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { CO2: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass GenericSwitch extends Device {\n    constructor(name) {\n        super(name, \"switch\"); // Setze den Gerätetyp auf \"switch\"\n        this.isRunning = false; // Status des Schalters\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Switch: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                if (!this.isRunning) {\n                    this.isRunning = true;\n                    node.warn(`${this.inRoomName} - ${this.name}: Switch wird eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"on\" };\n                } else {\n                    node.warn(`${this.inRoomName} - ${this.name}: Switch ist bereits eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already ON\" };\n                }\n\n            case \"off\":\n                if (this.isRunning) {\n                    this.isRunning = false;\n                    node.warn(`${this.inRoomName} - ${this.name}: Switch wird ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"off\" };\n                } else {\n                    node.warn(`${this.inRoomName} - ${this.name}: Switch ist bereits ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already OFF\" };\n                }\n\n            default:\n                node.warn(`${this.inRoomName} - ${this.name}: Unbekannte Aktion.`);\n                return { Switch: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\n//// UNTIL HERE\n\nclass Sensor extends Device {\n    constructor(name) {\n        super(name, \"sensor\");\n        this.readings = []; // Speichert Sensordaten\n    }\n\n    addReading(reading) {\n        this.readings.push(reading);\n        return this.readings;\n    }\n\n    getLastReading() {\n        return this.readings.length > 0 ? this.readings[this.readings.length - 1] : null;\n    }\n\n    clearReadings() {\n        this.readings = [];\n    }\n}\n\n// Instanziiere die VPDControl-Klasse und speichere sie in der globalen Node-RED-Variablen\nglobal.set(\"OpenGrowBox\", OpenGrowBox);\nnode.status({ fill: \"green\", shape: \"ring\", text: \"OpenGrowBox Started\" });\nmsg.topic = \"Init\"\nreturn msg\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":520,"y":160,"wires":[[]]},{"id":"6bcddff9e4459ebe","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"event","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":390,"y":560,"wires":[]},{"id":"9243695e03284f5a","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Manager","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1140,"y":560,"wires":[]},{"id":"689b21de2004713b","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Manager","func":"// Hole oder initialisiere die globale Variable für Räume\nif (msg.topic === \"all_rooms\") return null;\n\n// Prüfen, ob die Klasse OpenGrowBox im globalen Kontext verfügbar ist\nconst OpenGrowBox = global.get(\"OpenGrowBox\");\nif (!OpenGrowBox) {\n    node.error(\"OpenGrowBox class not found in global context\");\n    return null;\n}\n\nconst room = msg.topic;\n\n// Hole die aktuelle Instanz des Raums\nlet roomInstance = global.get(room);\n\n// Instanz für den Raum erstellen, falls sie nicht existiert\nif (!roomInstance) {\n    roomInstance = new OpenGrowBox(room);\n    global.set(room, roomInstance);\n    node.warn(`Created new room instance for: ${room}`);\n}\n\n// Prüfen, ob Payload-Daten vorhanden sind\nif (msg.payload && typeof msg.payload === \"object\") {\n    const data = msg.payload;\n\n    // Iteriere über die Räume (Gruppen) und Geräte\n    for (const roomKey in data) {\n        const group = data[roomKey];\n\n        // Iteration über die Geräte in der Gruppe\n        for (const deviceName in group) {\n            const deviceData = group[deviceName];\n\n            // Geräte aus der Instanz abrufen oder leeres Array initialisieren\n            const currentRoomDevs = roomInstance.devices || [];\n\n            // Überprüfen, ob das Gerät in den normalen Geräten existiert\n            const existingDevice = currentRoomDevs.find((device) => device.name === deviceName);\n\n            // Iteration über die inneren Daten des Geräts für weitere Verarbeitung\n            for (const entity in deviceData) {\n                if (roomInstance) {\n                    try {\n                        let currentValue = deviceData[entity];\n                        updateTentEnvs(entity, currentValue, roomInstance);\n                    } catch (err) {\n                        node.error(`Error processing entity: ${entity} - ${err.message}`);\n                    }\n                }\n\n            }\n\n\n            if (existingDevice) {\n                // Gerät existiert in normalen Geräten: Aktualisieren\n                existingDevice.setData(deviceData, roomInstance);\n            } else {\n                // Gerät existiert in keinem der Arrays: Neues Gerät hinzufügen\n                // Prüfen, ob `ownDeviceSetup` aktiviert ist\n                if (roomInstance.controls.ownDeviceSetup) { \n                    const ownDeviceList = roomInstance.ownDeviceList || [];\n                    let ownDeviceType \n                    // Überprüfen, ob das Gerät in der eigenen Liste ist\n                    const isDeviceInOwnList = ownDeviceList.some((device) => {\n                        //node.warn(`${roomInstance.tentName} Device Entry : -> ${JSON.stringify(device, null, 2)}`);\n                        ownDeviceType = `${device.deviceType}.${deviceName}`\n                        return device.entity === deviceName;\n                    });\n\n                    if (isDeviceInOwnList) {\n                        // Gerät ist in der Liste: Hinzufügen\n                        roomInstance.addListDevice(ownDeviceType, deviceData, roomInstance,true);\n                    } else {\n                        // Gerät ist nicht in der Liste: Warnung\n                        //node.warn(`Gerät \"${deviceName}\" ist nicht in der ownDeviceList und wird nicht hinzugefügt.`);\n                    }\n                } else {\n                    // `ownDeviceSetup` ist deaktiviert: Standard-Verhalten\n                    roomInstance.addDevice(deviceName, deviceData, roomInstance,false);\n                }\n\n            }\n\n\n        }\n    }\n\n\n    // Nach Verarbeitung die aktualisierte Instanz in den globalen Kontext zurückschreiben\n    global.set(room, roomInstance);\n}\n\n\n// Update-Funktion für TentEnvs\nfunction updateTentEnvs(entity, value, roomInstance) {\n    if (!roomInstance) return;\n\n    if (entity.toLowerCase().includes(\"ogb_tentmode\")) {\n        let currentObjState = roomInstance.getTentMode() ;\n        if(currentObjState === value) return\n        node.warn(`TentMode geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setTentMode(value);\n\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_plantstage\")) {\n        if (value === \"unknown\")return\n        let currentObjState = roomInstance.getPlantStageValue();\n        if(currentObjState === value)return \n        node.warn(`PlantStage geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setPlantStageValue(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_dryingmodes\")) {\n        if(roomInstance.tentMode !== \"Drying\")return\n        let currentObjState = roomInstance.getDryingMode();\n        if(currentObjState === value) return\n        node.warn(`DryingMode geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setDryingMode(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_vpdlightcontrol\")) {\n        let currentObjState = roomInstance.getVPDLightControl();\n        if(currentObjState === value) return\n        node.warn(`Control Light VPD geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setVPDLightControl(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_holdvpdnight\")) {\n        let currentObjState = roomInstance.getVPDNightHold();\n        if(currentObjState === value)return\n        node.warn(`VPD Night Hold geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setVPDNightHold(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_controlset\")) {\n        let currentObjState = roomInstance.getControlSet();\n        if(currentObjState === value) return\n        node.warn(`ControlSet geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setControlSet(value);\n    }\n\n\n    if (entity.toLowerCase().includes(\"ogb_lightontime\")) {\n        \n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n        if (currentObjState !== value) {\n            let stopTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n            roomInstance.setLightTimes(value, stopTime);\n        }\n        roomInstance.updateLightState();\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_lightofftime\")) {\n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n        if (currentObjState !== value) {\n            let startTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n            roomInstance.setLightTimes(startTime, value);\n        }\n        roomInstance.updateLightState();\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_sunrisetime\")) {\n        let currentObjState = roomInstance.isPlantDay.sunRiseTimes;\n        if (currentObjState !== value) {\n            node.warn(`Sunrise Value Verändert: ${currentObjState} -> ${value}`);\n            roomInstance.isPlantDay.sunRiseTimes = value\n        }\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_sunsettime\")) {\n        let currentObjState = roomInstance.isPlantDay.sunSetTimes;\n        if (currentObjState !== value) {\n            node.warn(`Sunset Value Verändert: ${currentObjState} -> ${value}`);\n            roomInstance.isPlantDay.sunSetTimes = value\n        }\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_vpdtarget\")) {\n        if(value === null)return\n        let currentObjState = roomInstance.getTargetedVPD();\n        if (parseFloat(currentObjState) === parseFloat(value)) return\n        node.warn(`Targeted VPD geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setTargetedVPD(parseFloat(value));\n\n    }   \n\n    if (entity.toLowerCase().includes(\"ogb_leaftemp\")) {\n        let currentObjState = parseFloat(roomInstance.getLeafOffset()) ;\n        if (parseFloat(currentObjState) === parseFloat(value)) return\n        node.warn(`LeafOffSet geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setLeafOffset(parseFloat(value));\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_co2_control\")) {\n        let currentObjState = roomInstance.getCO2Control();\n        if (currentObjState === value) return\n        node.warn(`CO2 Control geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setCO2Control(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_lightcontrol\")) {\n        let currentObjState = roomInstance.getLightControlByOGB();\n        if (currentObjState === value) return\n        node.warn(`OGBLightControl geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setLightControlByOGB(value);\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_ownweights\")) {\n        let currentObjState = roomInstance.getifOwnWeightsActive();\n        if (currentObjState === value) return\n        node.warn(`OwnWeights geändert: ${currentObjState} -> ${value}`);\n        roomInstance.activateOwnWeights(value);\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_temperatureweight\") || entity.toLowerCase().includes(\"ogb_humidityweight\")) {\n        let currentObjState = roomInstance.getOwnWeights ? roomInstance.getOwnWeights() : \"\";\n\n        if (currentObjState !== value) {\n            roomInstance.setOwnWeights(entity, value);\n        }\n    }\n    // P.I.D Controller\n    if (entity.toLowerCase().includes(\"ogb_pidcontrol\")) {\n        let currentObjState = roomInstance.getPIDControl();\n        if (currentObjState === value) return\n        node.warn(`P.I.D Control geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setPIDControl(value);\n    }\n\n    // P.I.D VPD\n    if (entity.toLowerCase().includes(\"ogb_proportionalvpdfaktor\")) {\n        let currentObjState = roomInstance.setProportionalVPDFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setProportionalVPDFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_integralvpdfaktor\")) {\n        let currentObjState = roomInstance.getIntegralVPDFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setIntegralVPDFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_derivativvpdfaktor\")) {\n        let currentObjState = roomInstance.getDerivativVPDFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setDerivativVPDFactor(value);\n    }\n    \n    // P.I.D Temp\n    if (entity.toLowerCase().includes(\"ogb_proportionaltempfaktor\")) {\n        let currentObjState = roomInstance.getProportionalTempFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setProportionalTempFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_integraltempfaktor\")) {\n        let currentObjState = roomInstance.getIntegralTempFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setIntegralTempFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_derivativtempfaktor\")) {\n        let currentObjState = roomInstance.getDerivativTempFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setDerivativTempFactor(value);\n    }\n\n    // P.I.D Humidity\n    if (entity.toLowerCase().includes(\"ogb_proportionalhumfaktor\")) {\n        let currentObjState = roomInstance.getProportionalHumidityFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setProportionalHumidityFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_integralhumfaktor\")) {\n        let currentObjState = roomInstance.getIntegralTempFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setIntegralHumidityFactor(value);\n    }\n    if (entity.toLowerCase().includes(\"ogb_derivativhumfaktor\")) {\n        let currentObjState = roomInstance.getDerivativHumidityFactor();\n        if (currentObjState === parseFloat(value)) return\n        roomInstance.setDerivativHumidityFactor(value);\n    }\n\n    // Own Device List Setter\n    if (entity.toLowerCase().includes(\"ogb_owndevicesets\")) {\n        let currentObjState = roomInstance.getOwnDeviceSetup();\n        if(currentObjState === value) return\n        node.warn(`OwnDevice List Geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setOwnDeviceSetup(value);\n    }\n\n    if (roomInstance.controls.ownDeviceSetup) {\n        // Device List Selects\n        const deviceTypes = [\n            { key: \"ogb_lightselect\", type: \"light\" },\n            { key: \"ogb_exhaustselect\", type: \"exhaust\" },\n            { key: \"ogb_ventsselect\", type: \"ventilation\" },\n            { key: \"ogb_humidifierselect\", type: \"humidifier\" },\n            { key: \"ogb_dehumidifierselect\", type: \"dehumidifier\" },\n            { key: \"ogb_heaterselect\", type: \"heater\" },\n            { key: \"ogb_coolerselect\", type: \"cooler\" },\n            { key: \"ogb_climateselect\", type: \"climate\" },\n            { key: \"ogb_co2select\", type: \"co2\" }\n        ];\n\n        deviceTypes.forEach(({ key, type }) => {\n            if (entity.toLowerCase().includes(key)) {\n                if (value === \"unknown\" || value === \"\") return;\n\n                const deviceType = type;\n                const currentObjState = roomInstance.getCurrentOwnDeviceList(deviceType);\n                //node.warn(`CurrentObject ${currentObjState} -> From ${entity} Value: ${value}`);\n\n                if (roomInstance.controls.ownDeviceSetup) {\n                    // Prüfen, ob das Gerät bereits in der Liste enthalten ist\n                    if (!currentObjState.includes(value)) {\n                        node.warn(`Gerät hinzugefügt ${currentObjState} -> ${value}`);\n                        roomInstance.setCurrentOwnDeviceList(value, deviceType);\n                    } else {\n                        //node.warn(`Gerät \"${value}\" ist bereits in der Liste.`);\n                    }\n                }\n            }\n        });\n    }\n\n}\n\n// Rückgabe der aktualisierten Rauminstanz\nglobal.set(`${room}`, roomInstance);\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1140,"y":600,"wires":[["6fe72eaf1d2902f0","9243695e03284f5a"]]},{"id":"637ca5a8c9caff38","type":"api-call-service","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Setze Select-Wert","server":"5772bf4c.b461d","version":7,"debugenabled":false,"action":"{{payload.action}}","floorId":[],"areaId":[],"deviceId":[],"entityId":[],"labelId":[],"data":"{     \"entity_id\": \"{{payload.data.entity_id}}\",     \"options\": \"{{payload.data.options}}\" }","dataType":"json","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","blockInputOverrides":false,"domain":"{{payload","service":"action}}","output_location":"payload","output_location_type":"msg","x":1130,"y":680,"wires":[[]]},{"id":"df0c7ce07867e0a6","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"OwnEntity","func":"// Zugriff auf das Hauptobjekt\nconst data = msg.payload;\nconst globalContext = global.get(\"tentsDataCount\") || {}; // Vorher gespeicherte Anzahl der Gruppen\nconst updatedContext = { ...globalContext }; // Kopie zum Aktualisieren\n\n// Dynamisch den ersten Schlüssel im Hauptobjekt finden\nconst mainKey = Object.keys(data)[0];\n\n// Sicherstellen, dass der Hauptschlüssel ein gültiges Objekt ist\nif (data[mainKey] && typeof data[mainKey] === \"object\") {\n    const room = msg.topic; // Raumname\n\n    // Extrahiere die Gruppennamen (Gerätegruppen)\n    const groupNames = Object.keys(data[mainKey]);\n\n    // Überprüfen, ob sich die Anzahl der Gruppen geändert hat\n    const previousGroupCount = globalContext[mainKey] || 0;\n    const currentGroupCount = groupNames.length;\n\n    if (currentGroupCount === previousGroupCount) {\n        node.status({\n            fill: \"yellow\",\n            shape: \"ring\",\n            text: `Keine Änderung der Gruppenanzahl (${currentGroupCount})`,\n        });\n        return null; // Keine Änderung, keine Nachricht senden\n    }\n\n    // Aktualisiere die gespeicherte Anzahl der Gruppen im Kontext\n    updatedContext[mainKey] = currentGroupCount;\n    global.set(\"tentsDataCount\", updatedContext);\n\n    // Funktion, um eine Nachricht im gewünschten Format zu erstellen\n    function createMessage(entityId, groupNames) {\n        return {\n            domain: \"opengrowbox\",\n            service: \"add_select_options\",\n            payload: {\n                entity_id: entityId,\n                options: groupNames, // Array der Gruppennamen\n            },\n        };\n    }\n\n    // Array für selektierbare Geräte (alle möglichen selects)\n    const selectKeys = [\n        \"select.ogb_lightselect1\",\n        \"select.ogb_lightselect2\",\n        \"select.ogb_lightselect3\",\n        \"select.ogb_exhaustselect\",\n        \"select.ogb_ventsselect\",\n        \"select.ogb_climateselect\",\n        \"select.ogb_co2select\",\n        \"select.ogb_coolerselect\",\n        \"select.ogb_dehumidifierselect\",\n        \"select.ogb_humidifierselect\",\n        \"select.ogb_heaterselect\",\n\n    ];\n\n    // Nachrichten für alle selects erstellen\n    let deviceMessages = [];\n    selectKeys.forEach((selectKey) => {\n        deviceMessages.push(createMessage(`${selectKey}_${room}`, groupNames));\n    });\n\n    // Statusmeldung und Nachrichten senden\n    let index = 0;\n    deviceMessages.forEach((message) => {\n        if (message) {\n            index++;\n\n            node.status({\n                fill: \"green\",\n                shape: \"dot\",\n                text: `Sende Nachricht ${index}: ${message.payload.entity_id}`,\n            });\n\n            node.send({\n                ...msg,\n                payload: message.payload,\n                domain: message.domain,\n                service: message.service,\n            });\n        }\n    });\n\n    node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: `${index} Nachrichten gesendet (${currentGroupCount} Gruppen)`,\n    });\n} else {\n    // Falls kein gültiges Hauptobjekt existiert\n    node.status({\n        fill: \"red\",\n        shape: \"dot\",\n        text: \"Kein gültiges Hauptobjekt gefunden.\",\n    });\n    return null;\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":530,"y":680,"wires":[["d2b18836de168ff3"]]},{"id":"d2b18836de168ff3","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Format Payload for Select","func":"// Überprüfen, ob die erforderlichen Felder vorhanden sind\nif (!msg.payload.entity_id || !msg.payload.options) {\n    node.error(\"Fehlende entity_id oder option im Payload\");\n    return null;\n}\n\n// Erstellen des neuen Payloads für den Dienstaufruf\nmsg.payload = {\n    domain: \"opengrowbox\",\n    service: \"add_select_options\",\n    data: {\n        entity_id: msg.payload.entity_id,\n        options: msg.payload.options // Option korrekt als String belassen\n    }\n};\n\n// Statusmeldung für Debugging-Zwecke\nnode.status({\n    fill: \"green\",\n    shape: \"dot\",\n    text: `Setze Devices für ${msg.payload.data.entity_id}`\n});\n\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":830,"y":680,"wires":[["637ca5a8c9caff38"]]},{"id":"3fb0e90d008a49cb","type":"link out","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"GroupData","mode":"link","links":["fba4373e4922558f","2f145079d4c19792"],"x":875,"y":600,"wires":[]},{"id":"fba4373e4922558f","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Manger","links":["3fb0e90d008a49cb"],"x":1035,"y":600,"wires":[["689b21de2004713b"]]},{"id":"2f145079d4c19792","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"OwnDeviceList","links":["3fb0e90d008a49cb"],"x":305,"y":680,"wires":[["df0c7ce07867e0a6"]]},{"id":"5772bf4c.b461d","type":"server","name":"OpenGrowBox","version":5,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":true,"cacheJson":true,"heartbeat":false,"heartbeatInterval":"30","areaSelector":"friendlyName","deviceSelector":"friendlyName","entitySelector":"friendlyName","statusSeparator":"at: ","statusYear":"hidden","statusMonth":"short","statusDay":"numeric","statusHourCycle":"h23","statusTimeFormat":"h:m","enableGlobalContextStore":true},{"id":"home-assistant-server","type":"server","name":"Home Assistant","addon":true}]