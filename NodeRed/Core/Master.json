[{"id":"5b9485aa95f0d129","type":"tab","label":"Master","disabled":false,"info":"","env":[]},{"id":"3523f89ec9c2c676","type":"group","z":"5b9485aa95f0d129","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["f918483e39cca146","002d11c9c357103a","e8932288657b06b0","216fd3f0b8d840e8","2ab6344485625dcd","6fe72eaf1d2902f0","fabadc4d4be7d4e0","99978d5c67470d93","d5304206f52a55b7","d55ff9409b336801","6bcddff9e4459ebe","30e734dbde9b993e","9243695e03284f5a","c806a9566fb660e3","ef80caba76d3b5d2"],"x":14,"y":539,"w":1122,"h":222},{"id":"43457bccef542a7d","type":"group","z":"5b9485aa95f0d129","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ff31217e40ad4b05","7c87b0ddef19c485","544a86e20ad408b7","830ae29ab82e7324","e169760164875f0d","475e1c236aeba4d1","e2d1060d7f9a6441","9626681e71699287","8fe9c92afc561145","9967ec5e0edd8865","51e259473c842217","7972042b37655b19","1f613600601fde7a","cbd6c91073fd88a5","43d31f16658453c9","4760488940785c7b","47e4915877639ef5","10e3067fe685efa7","cfef77bffb098c25","21dd9af34945132e","64cb926c237c0102","139015f29bc3dd89","090ae69011847e65","06edd4eb472d3731","f539391e66f50ccf","3173745ac1f6be42"],"x":14,"y":199,"w":1442,"h":302},{"id":"ef62895c84290225","type":"group","z":"5b9485aa95f0d129","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ec276734748d6829","04f5f1cb8930332f","46fe411f25a067ab","5b6a82d0293eb58e","9e924b8b3bf85b05","a43ba85d9f0563c4","40afa2a7ef46e38a"],"x":14,"y":39,"w":712,"h":142},{"id":"64cb926c237c0102","type":"junction","z":"5b9485aa95f0d129","g":"43457bccef542a7d","x":440,"y":340,"wires":[["51e259473c842217","7c87b0ddef19c485"]]},{"id":"c806a9566fb660e3","type":"junction","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","x":800,"y":680,"wires":[["fabadc4d4be7d4e0","216fd3f0b8d840e8"]]},{"id":"7c87b0ddef19c485","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"areas","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/area_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"areas","propertyType":"msg","value":"","valueType":"results"},{"property":"topic","propertyType":"msg","value":"areas","valueType":"str"}],"x":510,"y":400,"wires":[["43d31f16658453c9","4760488940785c7b"]]},{"id":"544a86e20ad408b7","type":"inject","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Manual Update","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":"15","topic":"","payload":"","payloadType":"date","x":160,"y":240,"wires":[["64cb926c237c0102"]]},{"id":"830ae29ab82e7324","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"entities","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/entity_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"entities","propertyType":"msg","value":"","valueType":"results"}],"x":1040,"y":400,"wires":[["cbd6c91073fd88a5"]]},{"id":"e169760164875f0d","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"On Connect","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"home_assistant_client","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":110,"y":460,"wires":[["475e1c236aeba4d1"]]},{"id":"475e1c236aeba4d1","type":"switch","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"con","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"connected","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":330,"y":420,"wires":[["64cb926c237c0102"]]},{"id":"e2d1060d7f9a6441","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"entity_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"entity_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":140,"y":280,"wires":[["9967ec5e0edd8865"]]},{"id":"9626681e71699287","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"device_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"device_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":150,"y":340,"wires":[["9967ec5e0edd8865"]]},{"id":"8fe9c92afc561145","type":"server-events","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"area_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"area_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":140,"y":400,"wires":[["9967ec5e0edd8865"]]},{"id":"9967ec5e0edd8865","type":"trigger","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Update","op1":"","op2":"","op1type":"nul","op2type":"payl","duration":"1","extend":false,"overrideDelay":false,"units":"min","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":340,"y":340,"wires":[["64cb926c237c0102"]]},{"id":"51e259473c842217","type":"ha-get-entities","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"Get All Entities","server":"home-assistant-server","version":1,"rules":[],"outputType":"array","outputEmptyResults":false,"outputLocationType":"msg","outputLocation":"payload","x":540,"y":300,"wires":[["7972042b37655b19"]]},{"id":"7972042b37655b19","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"AllData","func":"msg.topic=\"AllData\"\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":300,"wires":[["ff31217e40ad4b05","139015f29bc3dd89"]]},{"id":"1f613600601fde7a","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"GroupFilledRoom","func":"let data = msg.payload;\nlet allData = data.AllData;\ndelete data.AllData;\n\n// Erstelle ein Mapping von entity_id zu state aus dem AllData-Array\nlet entityIdToStateMap = {};\nallData.forEach(item => {\n    entityIdToStateMap[item.entity_id] = item.state;\n});\n\n// Erstelle ein neues Objekt zur Gruppierung der Daten, das die gleiche Struktur wie das Ursprungsobjekt beibehält\nlet groupedData = {};\n\n// Iteriere über die Hauptgruppen in data (z.B., flowertent, vegittent, dryingtent, ambient)\nfor (let group in data) {\n    if (data.hasOwnProperty(group)) {\n        groupedData[group] = {}; // Behalte den Gruppennamen wie flowertent\n\n        // Iteriere über die Untergruppen in der Hauptgruppe (z.B., light, plant, co2, ...)\n        for (let subGroup in data[group]) {\n            if (data[group].hasOwnProperty(subGroup)) {\n                groupedData[group][subGroup] = {};\n\n                // Iteriere über die Sensoren in der Untergruppe\n                for (let sensor in data[group][subGroup]) {\n                    if (data[group][subGroup].hasOwnProperty(sensor)) {\n                        // Hole den Wert aus entityIdToStateMap, falls vorhanden, andernfalls behalte den bestehenden Wert\n                        let value = entityIdToStateMap[sensor] !== undefined ? entityIdToStateMap[sensor] : data[group][subGroup][sensor];\n\n                        // Speichere den Sensor-Schlüssel mit dem gefüllten Wert in groupedData\n                        groupedData[group][subGroup][sensor] = value;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Setze das gefüllte Objekt als msg.payload\nmsg.payload = groupedData;\nmsg.tentData = true\n// Entferne nicht benötigte Eigenschaften aus msg\ndelete msg.devices;\ndelete msg.entities;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1270,"y":300,"wires":[["47e4915877639ef5","06edd4eb472d3731"]]},{"id":"cbd6c91073fd88a5","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DynamicRoomData","func":"// Erster Teil: Erstellen des `entities`-Objekts mit `area_id` und `name`\nconst entities = {};\n\nmsg.entities.forEach(e => {\n    // Überprüfe, ob entweder `device_id` gefüllt ist oder `area_id` gefüllt ist, aber `device_id` null ist\n    if (!e.device_id && e.area_id) {\n        const area = msg.areas.find(a => a.area_id === e.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    } else if (e.device_id) {\n        const device = msg.devices.find(d => d.id === e.device_id);\n        const area = msg.areas.find(a => a.area_id === device.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    }\n});\n\n// Erzeuge die nicht gruppierte Nachricht für den zweiten Output\nlet ungroupedOutput = { payload: entities, update: true };\n\n// Zweiter Teil: Gruppierung von `entities` nach `area_id` und `name`\nlet output = {};\n\nfor (let key in entities) {\n    let area_id = entities[key].area_id;\n    let entityName = entities[key].name;\n\n    // Falls der `area_id`-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id]) {\n        output[area_id] = {};\n    }\n\n    // Teile den Sensor-String in `name` und `type` auf\n    let [prefix, suffix] = key.split('.'); // Trenne bei Punkt, z.B. \"sensor.light_ip\"\n    let [name, type] = suffix.split('_'); // Trenne bei Unterstrich, z.B. \"light_ip\"\n\n    // Falls der Name-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id][name]) {\n        output[area_id][name] = {};\n    }\n\n    // Speichere den vollständigen Sensor-Schlüssel mit `null` als Wert\n    output[area_id][name][key] = null;\n}\n\n// Erzeugung von Nachrichten für jeden `area_id`-Bereich (erster Output)\nlet messages = [];\n\nfor (let area_id in output) {\n    if (output.hasOwnProperty(area_id)) {\n        // Erzeuge eine Nachricht für jede Gruppe mit `area_id` als `topic`\n        messages.push({\n            topic: area_id,\n            payload: output[area_id]\n        });\n    }\n}\n\n// Rückgabe der beiden Outputs: erster Output für die gruppierten Daten, zweiter für die ungruppierten\nreturn [messages, ungroupedOutput];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1270,"y":400,"wires":[["cfef77bffb098c25","f539391e66f50ccf"],["10e3067fe685efa7","3173745ac1f6be42"]]},{"id":"f918483e39cca146","type":"server-events","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"newEvent","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"state_changed","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":100,"y":620,"wires":[["002d11c9c357103a"]]},{"id":"ff31217e40ad4b05","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DynamicCombinedRoomData","func":"// Überprüfe, ob die Nachricht `AllData` ist und speichere sie im Kontext\nif (msg.topic === \"AllData\") {\n    context.set(\"AllData\", msg.payload);\n    node.status({ fill: \"green\", shape: \"dot\", text: \"AllData Loaded\", })\n    return null; // `AllData` wird nur gespeichert und nicht sofort ausgegeben\n}\n\n// Hole `AllData` aus dem Kontext\nlet allData = context.get(\"AllData\");\n\n// Wenn `AllData` noch nicht geladen ist, warte auf weitere Nachrichten\nif (!allData) {\n    node.warn(\"AllData noch nicht im Kontext vorhanden. Warte auf AllData.\");\n    node.status({fill:\"red\", shape: \"ring\", text: \"No Data Available\", })\n    return null;\n}\n\n// Kombiniere `AllData` mit der aktuellen Nachricht\nlet combinedData = {\n    AllData: allData,\n    [msg.topic]: msg.payload\n};\n\n// Setze das kombinierte Objekt als `msg.payload`\nmsg.payload = combinedData;\n\n// Gib die kombinierte Nachricht zurück\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":990,"y":300,"wires":[["1f613600601fde7a","090ae69011847e65"]]},{"id":"002d11c9c357103a","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"SetArea","func":"if (msg.update) {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Area Data Loaded\" });\n    context.set(\"data\", msg.payload);\n    return;\n}\n\nconst data = context.get(\"data\");\n\nif (!data) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"No Area Data\" });\n    return;\n}\n\nconst area = data[msg.payload.entity_id];\nif (!area) return;\n\nmsg.area = area.name.toLowerCase();\n\n// Extrahiere `entity_id`, z.B. \"sensor.h5179_485d_temperature\"\nconst entity_id = msg.payload.entity_id;\n\n// Zerlege den `entity_id`-String, um den Gerätetyp zu extrahieren\nconst parts = entity_id.split('.')[1]; // Entfernt den Präfix (z.B., \"sensor.\")\nconst device = parts.split('_')[0]; // Entfernt den Suffix nach dem ersten Unterstrich\n\n// Extrahiere alten und neuen Zustand\nconst oldState = msg.payload.event.old_state?.state || null;\nconst newState = msg.payload.event.new_state?.state || null;\n\n// Überprüfe, ob alte und neue Zustände ignoriert werden sollen\nconst invalidStates = [\"NaN\", \"unknown\", \"undefined\", \"unbekannt\",\"unavailable\", null];\n\nif (invalidStates.includes(oldState) || invalidStates.includes(newState)) {\n    node.status({ fill: \"yellow\", shape: \"ring\", text: \"Invalid state, ignored\" });\n    return;\n}\n\n// Erstelle ein Objekt `updateData` für das Update\nconst updateData = {\n    room: msg.area,\n    device: device,\n    entity_id: entity_id,\n    oldState: oldState,\n    newState: newState\n};\n\nnode.status({ text: `Update for: ${msg.area}` });\nmsg.payload = updateData;\nmsg.update = true;\nreturn msg;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":340,"y":620,"wires":[["2ab6344485625dcd","6bcddff9e4459ebe"]]},{"id":"e8932288657b06b0","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"GetRoomInstance","func":"// Hole den Raumnamen aus `msg.area`\nconst room = msg.topic;\n\n// Lade die Instanz der OpenGrowBox für den Raum\nconst roomInstance = global.get(room);\nif (!roomInstance) {\n    node.warn(`Keine Instanz für Raum ${room} gefunden.`);\n    return null;\n}\nmsg.payload = [roomInstance]\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":670,"y":680,"wires":[["c806a9566fb660e3"]]},{"id":"216fd3f0b8d840e8","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"RoomObject","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":910,"y":680,"wires":[]},{"id":"43d31f16658453c9","type":"ha-api","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"devices","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/device_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"devices","propertyType":"msg","value":"","valueType":"results"}],"x":820,"y":400,"wires":[["830ae29ab82e7324"]]},{"id":"ec276734748d6829","type":"inject","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":490,"y":80,"wires":[["04f5f1cb8930332f"]]},{"id":"04f5f1cb8930332f","type":"function","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"ClearGlobals","func":"// Alle globalen Schlüssel abrufen\nconst keys = global.keys();\n\nif (keys.length === 0) {\n    node.warn(\"Keine globalen Variablen vorhanden, nichts zu löschen.\");\n    return null; // Keine Variablen zum Löschen\n}\n\n// Alle globalen Schlüssel löschen\nkeys.forEach(key => {\n    global.set(key, undefined); // Setzt den Schlüssel auf undefined, was ihn effektiv löscht\n    node.warn(`Globale Variable gelöscht: ${key}`);\n});\n\nnode.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: `Alle ${keys.length} globalen Variablen gelöscht`\n});\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":630,"y":80,"wires":[[]]},{"id":"2ab6344485625dcd","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"CombinedUpdated_RoomData","func":"// Hole die gespeicherten Basisdaten aus dem globalen Speicher\nlet tentsData = global.get(\"tentsData\") || {};\n\n// Prüfen, ob die Nachricht ein Update enthält (msg.update = true)\nif (msg.update === true) {\n    const { room, device, entity_id, newState } = msg.payload;\n\n    // Validierung: Prüfen, ob alle benötigten Felder vorhanden sind\n    if (!room || !device || !entity_id || newState === undefined) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid update payload\" });\n        return null;\n    }\n\n    // Sicherstellen, dass der Raum in den Daten existiert\n    if (tentsData[room]?.[device]?.[entity_id] !== undefined) {\n        const oldValue = tentsData[room][device][entity_id];\n\n        // Aktualisieren, wenn der Wert unterschiedlich ist\n        if (oldValue !== newState) {\n            tentsData[room][device][entity_id] = newState;\n            node.status({ fill: \"green\", shape: \"dot\", text: `Updated: ${room} -> ${device} -> ${entity_id}` });\n        } else {\n            node.status({ fill: \"blue\", shape: \"ring\", text: `No change: ${room} -> ${device} -> ${entity_id}` });\n        }\n    } else {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: `Entity not found: ${room} -> ${device} -> ${entity_id}` });\n    }\n\n    // Setze den msg.topic auf den Raum-Namen\n    msg.topic = room;\n\n    // Gib nur den aktualisierten Raum zurück\n    msg.payload = { [room]: tentsData[room] };\n} else {\n    // Basisdaten speichern\n    const newTentsData = msg.payload;\n\n    // Räume in die globale Datenstruktur hinzufügen oder aktualisieren\n    Object.keys(newTentsData).forEach(room => {\n        if (!tentsData[room]) {\n            tentsData[room] = {};\n        }\n        Object.keys(newTentsData[room]).forEach(device => {\n            tentsData[room][device] = {\n                ...tentsData[room][device],\n                ...newTentsData[room][device]\n            };\n        });\n    });\n\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Base data updated\" });\n\n    // Setze den msg.topic auf \"all_rooms\"\n    msg.topic = \"all_rooms\";\n\n    // Gib die gesamte Struktur zurück\n    msg.payload = tentsData;\n}\n\n// Speichere die aktualisierten Daten im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":620,"wires":[["30e734dbde9b993e","ef80caba76d3b5d2"]]},{"id":"46fe411f25a067ab","type":"inject","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":110,"y":80,"wires":[["40afa2a7ef46e38a"]]},{"id":"6fe72eaf1d2902f0","type":"link out","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"MasterLink","mode":"link","links":["02701e85ddace028","e9fc73b86d447581"],"x":1095,"y":620,"wires":[]},{"id":"5b6a82d0293eb58e","type":"inject","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Load Data on Start","props":[],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","x":150,"y":140,"wires":[[]]},{"id":"9e924b8b3bf85b05","type":"file in","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Read from File","filename":"/data/openGrowBox.json","filenameType":"str","format":"utf8","chunk":false,"sendError":false,"encoding":"none","x":400,"y":140,"wires":[["a43ba85d9f0563c4"]]},{"id":"a43ba85d9f0563c4","type":"function","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"Initialize Instances","func":"// Prüfen, ob die Klasse OpenGrowBox im globalen Kontext verfügbar ist\nconst OpenGrowBox = global.get(\"OpenGrowBox\");\nif (!OpenGrowBox) {\n    node.error(\"OpenGrowBox class not found in global context\");\n    return null;\n} \nif (msg.payload) {\n    const storedData = JSON.parse(msg.payload);\n    storedData.forEach(roomData => {\n        const roomName = roomData.roomName;\n        const roomInstance = new OpenGrowBox(roomName);\n        roomInstance.tentData = roomData.tentData;\n        global.set(roomName, roomInstance);\n    });\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Instances Loaded\" });\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"No Data Found\" });\n}\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":590,"y":140,"wires":[[]]},{"id":"fabadc4d4be7d4e0","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Prepare Data","func":"const allInstances = global.keys().map(roomName => {\n    const roomInstance = global.get(roomName);\n    return {\n        roomName: roomName,\n        tentData: roomInstance ? roomInstance.tentData : null\n    };\n});\n\nmsg.payload = JSON.stringify(allInstances, null, 2);\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":870,"y":720,"wires":[["99978d5c67470d93"]]},{"id":"99978d5c67470d93","type":"file","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Write to File","filename":"/data/openGrowBox.json","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"utf8","x":1030,"y":720,"wires":[[]]},{"id":"4760488940785c7b","type":"function","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"RoomManager","func":"// Hole aktuelle Räume aus Home Assistant\nconst currentAreas = msg.areas; // Räume von Home Assistant\nconst currentAreaIds = currentAreas.map(area => area.area_id.toLowerCase()); // IDs der aktuellen Räume\n\n// Hole gespeicherte Räume aus tentsData\nlet tentsData = global.get(\"tentsData\") || {};\nlet removedRooms = [];\n\n// Iteriere über gespeicherte Räume und entferne verwaiste\nfor (let roomName in tentsData) {\n    if (!currentAreaIds.includes(roomName)) {\n        // Raum aus tentsData entfernen\n        delete tentsData[roomName];\n        removedRooms.push(roomName);\n\n        // Globale Rauminstanz entfernen\n        global.set(roomName, null);\n    }\n}\n\n// Aktualisiere tentsData im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\n// Logge die entfernten Räume\nif (removedRooms.length > 0) {\n    node.warn(`Removed orphaned rooms: ${removedRooms.join(', ')}`);\n} else {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"No orphaned rooms found\" });\n}\n\n// Rückgabe der aktualisierten Daten\nmsg.payload = { removedRooms, remainingRooms: Object.keys(tentsData) };\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":660,"y":380,"wires":[[]]},{"id":"47e4915877639ef5","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"GroupFilledRoom","mode":"link","links":["d5304206f52a55b7"],"x":1415,"y":300,"wires":[]},{"id":"d5304206f52a55b7","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"link in 87","links":["47e4915877639ef5"],"x":495,"y":600,"wires":[["2ab6344485625dcd"]]},{"id":"10e3067fe685efa7","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"CollectedRooms","mode":"link","links":["d55ff9409b336801"],"x":1415,"y":420,"wires":[]},{"id":"d55ff9409b336801","type":"link in","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"link in 88","links":["10e3067fe685efa7"],"x":235,"y":600,"wires":[["002d11c9c357103a"]]},{"id":"cfef77bffb098c25","type":"link out","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DataNeededRoom","mode":"link","links":["21dd9af34945132e"],"x":1415,"y":380,"wires":[]},{"id":"21dd9af34945132e","type":"link in","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"DataNeededRoom","links":["cfef77bffb098c25"],"x":835,"y":320,"wires":[["ff31217e40ad4b05"]]},{"id":"40afa2a7ef46e38a","type":"function","z":"5b9485aa95f0d129","g":"ef62895c84290225","name":"OpenGrowBox","func":"class OpenGrowBox {\n    constructor(tentName = \"\", plantStage = \"\", tentMode = \"\", perfectionTolerance = 0.025) {\n\n        // Tent Environment        \n        this.tentName = tentName;\n        this.tentMode = tentMode;\n        this.plantStage = plantStage;\n        this.controlSet = \"\";\n\n        this.devices = [];\n        this.ownSetttetDevices = []\n\n        this.needchange = false\n        this.previousActions = [];\n\n        this.controls = {\n            ownWeights: false,\n            weights: {\n                temp: null,\n                hum: null,\n            },\n            co2Control: false,\n            co2ppm: {\n                minPPM: 400,\n                maxPPM: 1200,\n            },\n            ownDeviceSetup: false,\n            experimental: false,\n            modes: {\n                vpdPerfection: \"VPD Perfection\",\n                inRangeVPD: \"IN-VPD-Range\",\n                targetedVDP: \"Targeted VPD\",\n                drying: \"Drying\",\n                experimentel: \"Experimentel\",\n                disabled: \"Disabled\"\n            }\n        }\n\n        this.expMods = {\n            current: \"\",\n            plantType: \"\",\n        }\n\n        this.isPlantDay = {\n            nightVPDHold: false,\n            lightOn: false,\n            lightOnTime: \"\",\n            lightOffTime: \"\",\n            lightbyOGBControl: false,\n            sunRiseTimes: \"\",\n            sunSetTimes: \"\",\n        }\n\n        this.enviorment = {\n            ambientTemp: 0.0,\n            ambientHumidity: 0.0,\n            ambientDewpoint: 0.0,\n            outsiteTemp: 0.0,\n            outsiteHumidity: 0.0,\n            outsiteDewpoint: 0.0,\n        };\n\n        this.tentData = {\n            temperature: null,\n            humidity: null,\n            leafTempOffset: 0,\n            dewpoint: 0.0,\n            maxTemp: 0,\n            minTemp: 0,\n            maxHumidity: 0,\n            minHumidity: 0,\n            co2Level: 400,\n        };\n\n        this.plantStages = {\n            Germination: { vpdRange: [0.412, 0.7], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            Clones: { vpdRange: [0.42, 0.75], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            EarlyVeg: { vpdRange: [0.7, 0.85], minTemp: 20, maxTemp: 28, minHumidity: 55, maxHumidity: 70 },\n            MidVeg: { vpdRange: [0.85, 1.1], minTemp: 20, maxTemp: 30, minHumidity: 50, maxHumidity: 65 },\n            LateVeg: { vpdRange: [0.933, 1.2], minTemp: 20, maxTemp: 30, minHumidity: 50, maxHumidity: 60 },\n            EarlyFlower: { vpdRange: [1.0, 1.25], minTemp: 22, maxTemp: 28, minHumidity: 45, maxHumidity: 60 },\n            MidFlower: { vpdRange: [1.1, 1.4], minTemp: 22, maxTemp: 26, minHumidity: 40, maxHumidity: 55 },\n            LateFlower: { vpdRange: [1.3, 1.7], minTemp: 20, maxTemp: 24, minHumidity: 40, maxHumidity: 50 }\n        };\n\n        this.vpd = {\n            current: null,\n            // RANGE VPD\n            range: [],\n            rangeTolerance: 0.0,\n            diffRange: null,\n            // VPD PERFECTION\n            perfection: 0.0,\n            perfectMin: 0.0,\n            perfectMax: 0.0,\n            perfectTolerance: perfectionTolerance,\n            diffPerfection: null,\n            // TARGETED VPD\n            targeted: 0.0,\n            targetedTolerance: 0.0,\n            diffTargeted: null,\n            ecotarget: [0.55, 0.88],\n            lightControl:false,\n        };\n\n        this.watering = {\n            autoWatering: false,\n            isRunning: false,\n            pumpInvervall: \"\",\n            pumpTime: \"\",\n            nextPumpAction: \"\",\n            waterTemp: 0,\n            nutrients: {\n                PH: 0,\n                PPM: 0,\n                EC: 0,\n                Temp: 0,\n                N: 0,\n                P: 0,\n                K: 0,\n            }\n        }\n\n        this.dryStartTime = null;\n        this.drying = {\n            currentDryMode: \"\",\n            isEnabled: false,\n            isRunning: false,\n            waterActivity: 0.0,\n            dewpointVPD: 0.0,\n            vaporPressureActual: 0.0,\n            vaporPressureSaturation: 0.0,\n            sharkMouseVPD: 0.0,\n            modes: {\n                elClassico: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetHumidity: 62, durationHours: 72\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetHumidity: 60, durationHours: 72\n                        },\n                        endTime: {\n                            targetTemp: 20, targetHumidity: 58, durationHours: 72\n                        }\n                    }\n                },\n                SharkMouse: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 22.2, targetHumidity: 55, targetVPD: 1.2, durationHours: 48\n                        },\n                        halfTime: {\n                            maxTemp: 23.3, targetHumidity: 52, targetVPD: 1.39, durationHours: 24\n                        },\n                        endTime: {\n                            maxTemp: 23.9, targetHumidity: 50, targetVPD: 1.5, durationHours: 48\n                        }\n                    }\n                },\n                dewBased: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetDewPoint: 12.25, durationHours: 96\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 96\n                        },\n                        endTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 48\n                        }\n                    }\n                }\n            }\n\n        }\n\n        this.addons = {\n            GasLanternRoutine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnPhase: 8,\n                        LightOffPhase: 16,\n                    },\n                    Indica: {\n                        LightOnPhase: 6,\n                        LightOffPhase: 18,\n                    }\n                }\n            },\n            GLR_NaturalSunshine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 8,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    },\n                    Indica: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 6,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    }\n                }\n            }\n        }\n\n        //Actions\n        this.actions = {\n            Increased: {\n                exhaust: \"increased\",\n                humidifier: \"reduced\",\n                dehumidifier: \"increased\",\n                heater: \"increased\",\n                cooler: \"reduced\",\n                ventilation: \"increased\",\n                light: this.vpd.lightControl ? \"increased\" : \"unchanged\",\n                co2: \"increased\",\n                climate: {\n                    cool: \"reduced\",\n                    dry: \"increased\",\n                    heat: \"increased\",\n                }\n            },\n            Reduced: {\n                exhaust: \"reduced\",\n                humidifier: \"increased\",\n                dehumidifier: \"reduced\",\n                heater: \"reduced\",\n                cooler: \"increased\",\n                ventilation: \"reduced\",\n                light: this.vpd.lightControl ? \"reduced\" : \"unchanged\",\n                co2: \"reduced\",\n                climate: {\n                    cool: \"increased\",\n                    dry: \"reduced\",\n                    heat: \"reduced\",\n                }\n            },\n            Unchanged: {\n                exhaust: \"unchanged\",\n                humidifier: \"unchanged\",\n                dehumidifier: \"unchanged\",\n                heater: \"unchanged\",\n                cooler: \"unchanged\",\n                ventilation: \"unchanged\",\n                light: \"unchanged\",\n                climate: {\n                    cool: \"unchanged\",\n                    dry: \"unchanged\",\n                    heat: \"unchanged\"\n                }\n            },\n        }\n\n        this.init();\n    }\n\n    init() {\n\n    }\n\n    // DATA SETTER/GETTER ******************************\n    setTentName(tentName = \"\") {\n        if (tentName !== this.tentName) {\n            this.tentName = tentName;\n        }\n\n    }\n\n    // Setze ob Ausleih funktion für Ambient aktiv ist. \n    setControlSet(controlSet) {\n        if (this.controlSet !== controlSet) {\n            this.controlSet = controlSet\n        }\n    }\n\n    // erhalte ob Ambient Steuerung aktiv ist.\n    getControlSet() {\n        return this.controlSet\n    }\n\n    // Setze Aktiven ZeltMode\n    setTentMode(tentMode = \"\") {\n        if (this.tentMode !== tentMode) { // Vergleiche auf Gleichheit\n            node.warn(`TentMode geändert von ${this.tentMode} auf ${tentMode} in ${this.tentName}`);\n\n            // Prüfe, ob der neue Modus nicht \"Drying\" ist\n            if (tentMode !== \"Drying\") {\n                this.drying.isRunning = false;\n                this.drying.isEnabled = false;\n                this.drying.currentDryMode = \"\"; // Drying-Mode zurücksetzen\n                this.dryStartTime = null;        // Timer zurücksetzen\n                node.warn(\"Drying-Modus deaktiviert und Timer zurückgesetzt.\");\n            }\n\n            this.tentMode = tentMode; // Neuen Modus setzen\n        } else {\n            return; // Keine Änderung notwendig\n        }\n    }\n\n    getTentMode() {\n        return this.tentMode\n    }\n\n    // Setze Targeted VPD wenn Mode aktiv!\n    setTargetedVPD(targetVPD) {\n        if (targetVPD !== this.vpd.targeted) {\n            if (this.tentMode === \"Targeted VPD\") {\n                this.vpd.targeted = parseFloat(targetVPD)\n            }\n        }\n    }\n\n    // Ehalte Targeted VPD wenn Mode aktiv!\n    getTargetedVPD() {\n        return this.vpd.targeted;\n    }\n\n    // Setze Plant Stage\n    setPlantStageValue(plantStage = \"\") {\n        if (this.plantStages.hasOwnProperty(plantStage)) {\n            const stage = this.plantStages[plantStage];\n            this.vpd.range = stage.vpdRange;\n            this.tentData.maxTemp = stage.maxTemp;\n            this.tentData.minTemp = stage.minTemp;\n            this.tentData.maxHumidity = stage.maxHumidity;\n            this.tentData.minHumidity = stage.minHumidity;\n            this.calculatePerfectVPD();\n            this.plantStage = plantStage; // Stelle sicher, dass plantStage gesetzt wird\n            //node.warn(`PlantStage innerhalb der Instanz aktualisiert: ${this.plantStage}`);\n        } else {\n            //node.warn(`Ungültige PlantStage: ${plantStage}`);\n        }\n    }\n\n    getPlantStageValue() {\n        return this.plantStage\n    }\n\n    // Setze aktuelle Temp\n    setCurrentTemp(temp) {\n        let newTemp = null;\n\n        // Überprüfen, ob temp ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(temp)) {\n            newTemp = parseFloat(this.calculateAvgValue(temp));\n        } else if (typeof temp === 'number') {\n            newTemp = temp;\n        } else if (typeof temp === 'string') {\n            newTemp = parseFloat(temp);\n        } else {\n            throw new Error(\"Invalid temperature data. Must be an array, number, or string.\");\n        }\n\n        if (newTemp === this.tentData.temperature) return;\n\n        this.tentData.temperature = newTemp;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Blatt Temp Offset\n    setLeafOffset(offset) {\n        if (parseFloat(offset) !== parseFloat(this.tentData.leafTempOffset)) {\n            this.tentData.leafTempOffset = parseFloat(offset)\n        }\n    }\n\n    getLeafOffset() {\n        return this.tentData.leafTempOffset\n    }\n\n    // Setze aktuelle Feuchtigkeit\n    setCurrentHumidity(humidity) {\n        let newHumidity = null;\n\n        // Überprüfen, ob humidity ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(humidity)) {\n            newHumidity = parseFloat(this.calculateAvgValue(humidity));\n        } else if (typeof humidity === 'number') {\n            newHumidity = humidity;\n        } else if (typeof humidity === 'string') {\n            newHumidity = parseFloat(humidity);\n        } else {\n            throw new Error(\"Invalid humidity data. Must be an array, number, or string.\");\n        }\n\n        if (newHumidity === this.tentData.humidity) return;\n\n        this.tentData.humidity = newHumidity;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Ambient Raum Daten (WO DAS ZELT STEHT!!!!)\n    setAmbientData(ambTemp, ambHum, ambDew = null) {\n        // Exit if any value is null\n        if (ambTemp === null || ambHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = ambDew !== null ? ambDew : this.calculateDewPoint(ambTemp, ambHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.ambientTemp !== ambTemp ||\n            this.enviorment.ambientHumidity !== ambHum ||\n            this.enviorment.ambientDewpoint !== dewpoint\n        ) {\n            this.enviorment.ambientTemp = ambTemp;\n            this.enviorment.ambientHumidity = ambHum;\n            this.enviorment.ambientDewpoint = dewpoint;\n        }\n    }\n\n    // Setze Temp von Außen \n    setOutsiteData(outTemp, outHum, outDew = null) {\n        // Exit if any value is null\n        if (outTemp === null || outHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = outDew !== null ? outDew : this.calculateDewPoint(outTemp, outHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.outsiteTemp !== outTemp ||\n            this.enviorment.outsiteHumidity !== outHum ||\n            this.enviorment.outsiteDewpoint !== dewpoint\n        ) {\n            this.enviorment.outsiteTemp = outTemp;\n            this.enviorment.outsiteHumidity = outHum;\n            this.enviorment.outsiteDewpoint = dewpoint;\n        }\n    }\n\n    // Setze aktuellen Dewpoint\n    setCurrentDewPoint(dewpoint) {\n        if (dewpoint !== this.tentData.dewpoint) {\n            this.tentData.dewpoint = this.calculateDewPoint(dewpoint)\n        }\n    }\n\n    // Aktiviere Nacht VPD Ignoranz\n    setVPDNightHold(nightHold) {\n        if (nightHold != this.helperYesTrue(this.isPlantDay.nightVPDHold)) {\n            this.isPlantDay.nightVPDHold = this.helperYesTrue(nightHold)\n        }\n    }\n\n    getVPDNightHold() {\n        return this.helperYesTrue(this.isPlantDay.nightVPDHold)\n    }\n\n    // Aktiviere Gewicht für Feinjustierung\n    activateOwnWeights(activ) {\n        if (activ !== this.controls.ownWeights) {\n            this.controls.ownWeights = this.helperYesTrue(activ)\n            if (!this.controls.ownWeights) {\n                this.controls.weights.temp = null\n                this.controls.weights.hum = null\n            }\n        }\n    }\n\n    // Erhatel Gewicht Aktivi Status\n    getifOwnWeightsActive() {\n        return this.helperYesTrue(this.controls.ownWeights)\n    }\n\n    // Setze Gewicht für Feinjustierung\n    setOwnWeights(name, weight) {\n        if (!this.controls.ownWeights) {\n            // Wenn `ownWeights` deaktiviert oder nicht definiert ist\n            if (!this.controls.ownWeights) {\n                return { ownWeights: \"Disabled\" }; // Gebe zurück, dass `ownWeights` deaktiviert ist\n            }\n            // Falls `ownWeights` undefined oder nicht initialisiert ist\n            this.controls.ownWeights = null;\n            return { ownWeights: \"Disabled\" };\n        } else {\n            // Wenn `ownWeights` aktiviert ist\n            if (name.includes(\"hum\")) {\n                // Feuchtigkeitsgewicht setzen\n                this.controls.weights.hum = parseFloat(weight);\n            } else if (name.includes(\"temp\")) {\n                // Temperaturgewicht setzen\n                this.controls.weights.temp = parseFloat(weight);\n            } else {\n                // Ungültiger Name\n                console.warn(`Unrecognized weight type: ${name}`);\n                return { error: `Invalid weight type: ${name}` };\n            }\n\n            return { ownWeights: \"Enabled\" }; // Gebe zurück, dass `ownWeights` aktiviert ist\n        }\n    }\n\n    // Erhalte Gewicht für Feinjustierung\n    getOwnWeights() {\n        if (this.controls.ownWeights) {\n            return { tempWeight: this.controls.weights.temp, humWweight: this.controls.weights.hum }\n        } else {\n            return { Data: \"NotNeeded\" }\n        }\n    }\n\n    // EXPRIMENTEL\n    setGLSControl(glscControl) {\n        if (glscControl !== this.controls.experimental) {\n            this.controls.experimental = this.helperYesTrue(glscControl)\n        }\n    }\n\n    // EXPRIMENTEL\n    getGLSControl() {\n        return this.helperYesTrue(this.controls.experimental)\n    }\n\n    // EXPRIMENTEL\n    setGLSPlantType(plantType) {\n        if (this.controls.experimental) {\n            if (plantType !== this.controls.experimental) {\n                this.expMods.plantType = plantType\n            }\n        } else {\n            if (this.expMods.plantType != \"\") {\n                this.expMods.plantType = \"\"\n\n            }\n\n        }\n\n    }\n\n    // EXPRIMENTEL\n    getGLSPlantType() {\n        return this.expMods.plantType\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    setOwnDeviceSetup(deviceControl) {\n        if (deviceControl !== this.controls.ownDeviceSetup) {\n            this.controls.ownDeviceSetup = this.helperYesTrue(deviceControl)\n        }\n        return\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    getOwnDeviceSetup() {\n        return this.helperYesTrue(this.controls.ownDeviceSetup)\n    }\n\n    // Aktiviere CO2 Steuerung\n    setCO2Control(co2Control) {\n        if (co2Control !== this.controls.co2Control) {\n            this.controls.co2Control = this.helperYesTrue(co2Control)\n        }\n    }\n\n    // COS Status\n    getCO2Control() {\n        return this.helperYesTrue(this.controls.co2Control)\n    }\n\n    // Aktiviere Kontorlle für Licht\n    setLightControlByOGB(wantsControl) {\n        if (wantsControl !== this.isPlantDay.lightbyOGBControl) {\n            this.isPlantDay.lightbyOGBControl = this.helperYesTrue(wantsControl)\n        }\n    }\n\n    // Licht Controll Status\n    getLightControlByOGB() {\n        return this.helperYesTrue(this.isPlantDay.lightbyOGBControl)\n    }\n\n    setVPDLightControl(lightControl){\n        if (lightControl !== this.vpd.lightControl) {\n            this.vpd.lightControl = this.helperYesTrue(lightControl)\n        }\n        return\n    }\n\n    getVPDLightControl(){\n        return this.helperYesTrue(this.vpd.lightControl)  \n    }\n\n    // Setze lichtzeiten wenn Kontrolle AKTIV \n    setLightTimes(startTime = \"\", endTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (startTime !== this.isPlantDay.lightOnTime || endTime !== this.isPlantDay.lightOffTime) {\n            this.isPlantDay.lightOnTime = startTime;\n            this.isPlantDay.lightOffTime = endTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${startTime}, Ende: ${endTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setLightTimes(startTime, endTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n\n            this.updateLightState(); // Aktualisiere den Lichtstatus\n        }\n    }\n\n    // Setze Sonnen Auf/Untergang \n    setSunTimes(sunRiseTime = \"\", sunSetTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (sunRiseTime !== this.isPlantDay.sunRiseTimes || sunSetTime !== this.isPlantDay.sunSetTimes) {\n            this.isPlantDay.sunRiseTimes = sunRiseTime;\n            this.isPlantDay.sunSetTimes = sunSetTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${sunRiseTime}, Ende: ${sunSetTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setSunTimes(sunRiseTime, sunSetTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n        }\n    }\n\n    // HELPERS ******************************\n    helperYesTrue(input) {\n        if (typeof input === \"string\") {\n            // Convert string to boolean\n            const upperInput = input.toUpperCase(); // Normalize case\n            if (upperInput === \"YES\") return true;\n            if (upperInput === \"NO\") return false;\n        } else if (typeof input === \"boolean\") {\n            // Convert boolean to string\n            return input ? \"YES\" : \"NO\";\n        }\n        // Handle invalid input\n        throw new Error(\"Invalid input: expected a string ('YES'/'NO') or boolean (true/false).\");\n    }\n\n    // Aktualisierung des Lichtstatus basierend auf der aktuellen Zeit\n    updateLightState(currentTime = new Date()) {\n        // Hole die aktuelle Zeit in Sekunden\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        // Konvertiere Lichtzeiten in Sekunden\n        const lightOnSeconds = this.parseTime(this.isPlantDay.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.isPlantDay.lightOffTime);\n\n        let lightOn;\n\n        if (lightOffSeconds < lightOnSeconds) {\n            // Lichtzyklus über Mitternacht: Licht an, wenn aktuelle Zeit nach Startzeit oder vor Endzeit\n            lightOn = currentSeconds >= lightOnSeconds || currentSeconds < lightOffSeconds;\n        } else {\n            // Lichtzyklus innerhalb eines Tages: Licht an, wenn aktuelle Zeit zwischen Start- und Endzeit\n            lightOn = currentSeconds >= lightOnSeconds && currentSeconds < lightOffSeconds;\n        }\n\n        // Setze den Lichtstatus in isPlantDay.lightOn\n        if (this.isPlantDay.lightOn !== lightOn) {\n            this.isPlantDay.lightOn = lightOn;\n\n            // Logge Änderungen für Debugging\n            node.warn(\n                `${this.tentName}: Lichtstatus aktualisiert - ${lightOn ? \"Licht AN\" : \"Licht AUS\"\n                } (Aktuelle Zeit: ${currentTime.toTimeString()}, On: ${this.isPlantDay.lightOnTime\n                }, Off: ${this.isPlantDay.lightOffTime})`\n            );\n\n            // Überprüfe, ob ein Lichtgerät vorhanden ist, und aktualisiere es\n        }\n    }\n\n    // Hilfsfunktion zur Zeitumrechnung (HH:MM:SS → Sekunden)\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    /// DEVCIES ******************************\n    // Methode zum Abrufen der passenden Geräteklasse\n    getDeviceClass(deviceType) {\n        const deviceClasses = {\n            humidifier: Humidifier,\n            dehumidifier: Dehumidifier,\n            exhaust: Exhaust,\n            ventilation: Ventilation,\n            heater: Heater,\n            cooler: Cooler,\n            light: Light,\n            pump: Pump,\n            climate: Climate,\n            switch: GenericSwitch,\n            sensor: Sensor,\n        };\n\n        return deviceClasses[deviceType] || Device;\n    }\n\n    // Gerät direkt zur Instanz hinzufügen und in entities speichern\n    addDevice(deviceName, deviceData, context) {\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n    }\n\n    // Geräte Identifizierung\n    identifyDevice(deviceName, deviceData) {\n        const deviceTypeMapping = {\n            \"sensor\": [\"mode\", \"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"h5179\"],\n            \"humidifier\": [\"humidifier\", \"mist\", \"befeuchter\",],\n            \"dehumidifier\": [\"dehumidifier\", \"drying\", \"dryer\", \"entfeuchter\", \"removehumidity\"],\n            \"exhaust\": [\"exhaust\", \"abluft\", \"ruck\"],\n            \"ventilation\": [\"vent\", \"vents\", \"venti\", \"ventilation\", \"inlet\", \"outlet\"],\n            \"heater\": [\"heater\", \"heizung\", \"warm\"],\n            \"cooler\": [\"cooler\", \"kühler\", \"klima\"],\n            \"light\": [\"light\", \"lamp\", \"led\", \"switch.light\"],\n            \"climate\": [\"climate\", \"klima\",],\n            \"co2\": [\"co2\", \"carbon\"],\n            \"switch\": [\"generic\", \"switch\"],\n            \"pump\": [\"pump\", \"waterpump\", \"pumpe\"],\n            //\"sensor\": [\"sensor\", \"mode\",\"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"flower\", \"veggi\", \"vegi\", \"dutycycle\", \"duty\", \"h5179\"],\n        };\n\n        // Prüfen, ob der Gerätename einen bekannten Typ enthält\n        // Überprüfen des Gerätetyps\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (keywords.some(keyword => deviceName.toLowerCase().includes(keyword))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                node.warn(`Device ${deviceName} identified as ${deviceType}`);\n                return new DeviceClass(deviceName, deviceType, deviceData);\n            }\n        }\n\n        // Prüfen, ob deviceData Schlüssel enthält, die auf einen Typ hindeuten\n        const entityKeys = Object.keys(deviceData || {});\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (entityKeys.some(key => keywords.some(keyword => key.toLowerCase().includes(keyword)))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                return new DeviceClass(deviceName, deviceType); // Gerät erstellen\n            }\n        }\n\n        node.warn(`Device ${deviceName} not recognized, returning unknown device.`);\n        return new Device(deviceName, \"unknown\");\n    }\n\n    // Registierung Caps ( noch nicht in nutzung)\n    registerDevices(device) {\n        // Sensoren ignorieren\n        if (device.deviceType.includes(\"sensor\")) return;\n        let capabilities\n        // Bestimme die Fähigkeiten des Geräts\n        capabilities = {\n            canHeat: device.deviceType === \"heater\" || device.deviceType === \"climate\" || device.deviceType === \"light\",\n            canCool: device.deviceType === \"cooler\" || device.deviceType === \"climate\",\n            canHumidify: device.deviceType === \"humidifier\",\n            canDehumidify: device.deviceType === \"dehumidifier\" || device.deviceType === \"climate\",\n            canVentilate: device.deviceType === \"ventilation\",\n            canExhaust: device.deviceType === \"exhaust\",\n            canLight: device.deviceType === \"light\",\n        };\n\n        // Entferne alle Fähigkeiten, die das Gerät nicht besitzt\n        capabilities = Object.fromEntries(\n            Object.entries(capabilities).filter(([key, value]) => value)\n        );\n\n        // Füge die bereinigten Fähigkeiten zum Gerät hinzu\n\n\n        // Füge das Gerät zum `registeredDevices`-Array hinzu\n        if (!this.devices) this.devices = [];\n        device.capabilities = { ...capabilities }\n\n        node.warn(`Device registered: ${device.name} with capabilities: ${Object.keys(capabilities).join(\", \")}`);\n    }\n\n    // Erhalte alle geräte \n    listDevices() {\n        return this.devices;\n    }\n\n    // Gerät sperren\n    lockDevice(device, roomName) {\n        if (!device.isLocked) {\n            device.isLocked = true;\n            device.lockedFor = roomName;\n            this.updateDevice(device);\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät entsperren\n    unlockDevice(device) {\n        if (device.isLocked) {\n            device.isLocked = false;\n            device.lockedFor = \"\";\n            console.warn(`Gerät entsperrt: ${device.name}`);\n            return true;\n        }\n        console.warn(`Gerät war nicht gesperrt: ${device.name}`);\n        return false;\n    }\n\n    // Gerät ausleihen\n    borrowDevice(device, fromTent) {\n        if (this.lockDevice(device, fromTent)) {\n            const borrowedIndex = this.devices.findIndex(d => d.name === device.name);\n            if (borrowedIndex === -1) {\n                this.devices.push(device);\n            }\n            device.inRoomName = this.tentName; // Setze den Raumnamen des geliehenen Geräts\n            device.isfromAmbient = false; // Markiere, dass es nicht mehr von Ambient kommt\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät aktualisieren\n    updateDevice(updatedDevice) {\n        const index = this.devices.findIndex(d => d.name === updatedDevice.name);\n        if (index !== -1) {\n            this.devices[index] = updatedDevice;\n        } else {\n            this.devices.push(updatedDevice);\n        }\n    }\n\n    // Gerät zurückgeben\n    returnDevice(device) {\n        if (this.unlockDevice(device)) {\n            // Entferne alle Instanzen des Geräts aus dem Array\n            device.action = \"off\";\n            device.mode = \"off\";\n            let offAction = device.turnOFF();\n            this.devices = this.devices.filter(d => d.name !== device.name);\n            console.warn(`Alle Instanzen von ${device.name} entfernt.`);\n\n            device.inRoomName = \"ambient\"; // Setze den Raumnamen zurück auf Ambient\n            device.isfromAmbient = true; // Markiere, dass es wieder zu Ambient gehört\n            device.action = \"off\";\n            node.warn(`OFF_Action_ROOM: ${JSON.stringify(offAction, null, 2)}`);\n            return offAction\n        }\n        console.warn(`Gerät konnte nicht entsperrt werden: ${device.name}`);\n        return false;\n    }\n\n    // Calc Funks ******************************\n    // Calc Dewpoint\n    calculateDewPoint(temperature = this.tentData.temperature, humidity = this.tentData.humidity) {\n        const temp = parseFloat(temperature);\n        const hum = parseFloat(humidity);\n        if (isNaN(temp) || isNaN(hum)) {\n            return \"unavailable\";\n        }\n\n        const a = 17.27;\n        const b = 237.7;\n\n        // Berechnung der Hilfsvariable γ(T, RH)\n        const gamma = (a * temp) / (b + temp) + Math.log(hum / 100);\n\n        // Berechnung des Taupunkts\n        const dewPoint = (b * gamma) / (a - gamma);\n        this.tentData.dewpoint = parseFloat(dewPoint.toFixed(2))\n        return parseFloat(dewPoint.toFixed(2));\n    }\n\n    // Calc Aktellen VPD ( Based TEMP-HUM-EAFTEMP)\n    calculateCurrentVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.leafTempOffset) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.vpd.current = parseFloat(vpd.toFixed(2));\n        return this.vpd.current;\n    }\n\n    // Calc Aktellen VPD Mittelwert aus aktuellen Plantstage min/max werten \n    calculatePerfectVPD(vpdRange = this.vpd.range) {\n        const averageVPD = (vpdRange[0] + vpdRange[1]) / 2;\n        this.vpd.perfection = parseFloat(averageVPD.toFixed(2));\n\n        this.vpd.perfectMin = parseFloat((this.vpd.perfection - this.vpd.perfectTolerance).toFixed(3));\n        this.vpd.perfectMax = parseFloat((this.vpd.perfection + this.vpd.perfectTolerance).toFixed(3));\n    }\n\n    // Berechne aus array/string/number/object den avg wert.\n    calculateAvgValue(temps = []) {\n        let sum = 0;\n        let count = 0;\n\n        // Prüfen, ob es ein Array von Zahlen ist oder ein Array von Objekten mit `value`\n        temps.forEach((entry) => {\n            let temp = parseFloat(entry.value);\n\n            if (!isNaN(temp)) {\n                sum += temp;\n                count++;\n            }\n        });\n\n        if (count === 0) {\n            return \"unavailable\";\n        }\n\n        const avg = sum / count;\n        return avg.toFixed(2);\n    }\n\n    // DRYING ******************************\n    // Setze aktuellen DryMode\n    setDryingMode(dryMode) {\n        if (this.tentMode !== \"Drying\") return\n        node.warn(`DryingModeINcome:${dryMode}`);\n        const normalizedMode = Object.keys(this.drying.modes).find(\n            mode => mode.toLowerCase() === dryMode.toLowerCase()\n        );\n\n        if (!normalizedMode) {\n            node.warn(`Ungültiger Trocknungsmodus: ${dryMode}. Standardmodus 'elClassico' wird verwendet.`);\n            this.drying.currentDryMode = \"elClassico\"; // Standardmodus setzen\n        } else {\n            this.drying.currentDryMode = normalizedMode;\n        }\n\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date)) {\n            this.setDryingStartTime();\n        }\n\n        this.drying.isEnabled = true;\n        this.drying.isRunning = true;\n        node.warn(`Trocknungsmodus aktiviert: ${this.drying.currentDryMode}`);\n    }\n\n    // Erhalte aktulle DryPhase nach Zeitpunkt\n    getDryingPhase() {\n        // Sicherstellen, dass dryStartTime gültig ist\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            node.error(\"Startzeit ist ungültig. Setze Startzeit neu.\");\n            this.setDryingStartTime();\n        }\n\n        // Sicherstellen, dass ein gültiger Drying-Mode gesetzt ist\n        if (!this.drying.currentDryMode || !this.drying.modes.hasOwnProperty(this.drying.currentDryMode)) {\n            node.error(\"Kein gültiger Drying-Mode gesetzt! Setze Standardmodus 'elClassico'.\");\n            this.setDryingMode(\"elClassico\");\n        }\n\n        const startTimeInSeconds = Math.floor(this.dryStartTime.getTime() / 1000);\n        const nowInSeconds = Math.floor(Date.now() / 1000);\n        const elapsedSeconds = nowInSeconds - startTimeInSeconds;\n\n        node.warn(`Verstrichene Zeit: ${elapsedSeconds} Sekunden`);\n\n        // Phasen abrufen und in Sekunden umrechnen\n        const currentMode = this.drying.modes[this.drying.currentDryMode];\n        const { start, halfTime, endTime } = currentMode.phase;\n\n        const startDuration = start.durationHours * 3600;\n        const halfTimeDuration = halfTime.durationHours * 3600;\n        const endTimeDuration = endTime.durationHours * 3600;\n\n        if (elapsedSeconds < startDuration) return \"start\";\n        if (elapsedSeconds < startDuration + halfTimeDuration) return \"halfTime\";\n        if (elapsedSeconds < startDuration + halfTimeDuration + endTimeDuration) return \"endTime\";\n\n        node.warn(\"Trocknung abgeschlossen.\");\n        return \"completed\";\n    }\n\n    // Erhalte aktuellen DryMode\n    getDryingMode() {\n        return this.drying.currentDryMode\n    }\n\n    // Setze Initale Zeit für DryZeitpunkt\n    setDryingStartTime() {\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            this.dryStartTime = new Date(); // Erstelle gültiges Date-Objekt\n            node.warn(`Startzeit wurde gesetzt: ${this.dryStartTime.toISOString()}`);\n        }\n    }\n\n    // Berechne Wasseraktivität\n    calcWatteractiviy(humidity = this.tentData.humidity) {\n        let hum = parseFloat(humidity);\n\n        if (isNaN(hum)) {\n            console.error(\"Invalid humidity value. Water activity cannot be calculated.\");\n            this.drying.waterActivity = null; // Setze den Wert explizit auf null bei Fehler\n            return null;\n        }\n\n        let wa = hum / 100; // Wasseraktivität berechnet als Verhältnis von Luftfeuchtigkeit\n        this.drying.waterActivity = parseFloat(wa.toFixed(2)); // Auf zwei Dezimalstellen runden\n        return this.drying.waterActivity;\n    }\n\n    // Berechne DewPointVPD (Based on Dewpoint/TEMP)\n    calcDewVPD(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for VPD calculation.\");\n            this.drying.dryingVPD = null;\n            return null;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * airTemp) / (airTemp + 237.3));\n        let adp = 0.6108 * Math.exp((17.27 * dewPoint) / (dewPoint + 237.3));\n\n        let dewVPD = sdpLuft - adp;\n        this.drying.dewpointVPD = parseFloat(dewVPD.toFixed(2)); // Rundet den VPD-Wert auf zwei Dezimalstellen\n        return this.drying.dewpointVPD;\n    }\n\n    // Berechne SharkMouse VPD (Based on TERMP/HUM/VPD)\n    calcSharkMouseVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.temperature) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.drying.sharkMouseVPD = parseFloat(vpd.toFixed(2));\n        return this.drying.sharkMouseVPD;\n    }\n\n    // Setze Aktuelle Vapor Pressure Werte\n    calcDryingVPs(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for vapor pressure calculation.\");\n            this.drying.vaporPressureActual = null;\n            this.drying.vaporPressureSaturation = null;\n            return null;\n        }\n\n        // Berechnung des tatsächlichen Dampfdrucks (ADP) am Taupunkt\n        let vaporPressureActual = 6.11 * Math.pow(10, (7.5 * dewPoint) / (237.3 + dewPoint));\n        this.drying.vaporPressureActual = parseFloat(vaporPressureActual.toFixed(2)); // Runden\n\n        // Berechnung des Sättigungsdampfdrucks (SDP) für Lufttemperatur\n        let vaporPressureSaturation = 6.11 * Math.pow(10, (7.5 * airTemp) / (237.3 + airTemp));\n        this.drying.vaporPressureSaturation = parseFloat(vaporPressureSaturation.toFixed(2)); // Runden\n\n        return {\n            vaporPressureActual: this.drying.vaporPressureActual,\n            vaporPressureSaturation: this.drying.vaporPressureSaturation,\n        };\n    }\n\n    //MODES ******************************\n    // MASTER MODE\n    ultraAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n\n        if (currentVPD < perfectVPD - tolerance) {\n            action = this.actions.Increased;\n        } else if (currentVPD > perfectVPD + tolerance) {\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"Ultra Perfection\",\n            currentVPD: currentVPD,\n            targetVPD: perfectVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            perfectMin: this.vpd.perfectMin,\n            perfectMax: this.vpd.perfectMax,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // MITTEL wert ziel aus range vpd werten\n    perfectionAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n        let isUnchanged = false; \n\n        if (currentVPD < perfectVPD - tolerance) {\n            action = this.actions.Increased;\n            isUnchanged = false;\n        } else if (currentVPD > perfectVPD + tolerance) {\n            action = this.actions.Reduced;\n            isUnchanged = false;        \n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: isUnchanged ? \"Unchanged\" : this.tentMode, // Wenn unverändert, setzen wir \"Unchanged\"\n            inMode: \"VPD Perfection\",\n            currentVPD: currentVPD,\n            targetVPD: perfectVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            perfectMin: this.vpd.perfectMin,\n            perfectMax: this.vpd.perfectMax,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Jumper zwishen min und max werten.\n    rangeAdjustments(currentVPD = this.vpd.current, targetVPDRange = this.vpd.range, tolerance = this.vpd.rangeTolerance) {\n        let action;\n        let vpdDiffPercent;\n\n        if (currentVPD < targetVPDRange[0] - tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[0]) / targetVPDRange[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n        } else if (currentVPD > targetVPDRange[1] + tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[1]) / targetVPDRange[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"VPD Range\",\n            currentVPD: currentVPD,\n            targetVPDMin: targetVPDRange[0],\n            targetVPDMax: targetVPDRange[1],\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Targeted VPD Ziel mit Targed VPD\n    targetAdjustment(currentVPD = this.vpd.current, targetVPD = this.vpd.targeted, tolerance = this.vpd.targetedTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - targetVPD) / targetVPD) * 100)); // Korrektur der Berechnung\n\n        if (currentVPD < targetVPD + tolerance) {\n            action = this.actions.Increased;\n        } else if (currentVPD > targetVPD + tolerance) {\n            action = this.actions.Reduced;\n        }\n        \n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: currentVPD,\n            targetedVPD: targetVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // DryingModeChecks \n    dryAdjustments() {\n        if (!this.drying.isEnabled || !this.drying.isRunning) {\n            this.drying.isEnabled = true;\n            this.drying.isRunning = true;\n            this.setDryingStartTime();\n            node.warn(\"Trocknung gestartet und Status aktualisiert.\");\n        }\n\n        const currentPhase = this.getDryingPhase();\n        if (!currentPhase) {\n            node.error(\"Keine Phase berechnet, Startzeit fehlt.\");\n            return { error: \"Phase konnte nicht berechnet werden.\" };\n        }\n\n        if (currentPhase === \"completed\") {\n            node.warn(\"Trocknung abgeschlossen.\");\n            this.drying.isRunning = false;\n            return { status: \"completed\" };\n        }\n\n        // Wasseraktivität und VPD berechnen\n        this.calcWatteractiviy(this.tentData.humidity);\n        this.calcDewVPD(this.tentData.temperature, this.tentData.dewpoint);\n        this.calcDryingVPs(this.tentData.temperature, this.tentData.dewpoint)\n        this.calcSharkMouseVPD(this.tentData.temperature, this.tentData.humidity)\n\n        node.warn(`CURRENTPHASE: ${currentPhase}`);\n\n\n        // Phase-spezifische Aktionen ausführen\n        switch (this.drying.currentDryMode) {\n            case \"elClassico\":\n                return this.dryElClassico(currentPhase);\n            case \"SharkMouse\":\n                return this.drySharkMouse(currentPhase);\n            case \"dewBased\":\n                return this.dryDewBased(currentPhase);\n            default:\n                node.error(\"Unbekannter Drying-Mode!\");\n                return { error: \"Unbekannter Drying-Mode\" };\n        }\n    }\n\n    // DRYMODE Classic\n    dryElClassico(currentPhase) {\n        const phaseConfig = this.drying.modes.elClassico.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const tempTolerance = 0.5; // Toleranz in °C\n        const humTolerance = 2;   // Toleranz in %\n\n        // Anpassungen basierend auf Temperatur\n        if (Math.abs(this.tentData.temperature - phaseConfig.targetTemp) > tempTolerance) {\n            if (this.tentData.temperature < phaseConfig.targetTemp) {\n                dryAction.heater = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        // Anpassungen basierend auf Feuchtigkeit\n        if (Math.abs(this.tentData.humidity - phaseConfig.targetHumidity) > humTolerance) {\n            if (this.tentData.humidity < phaseConfig.targetHumidity) {\n                dryAction.humidifier = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"unchanged\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"increased\" };\n            }\n        }\n\n        // Konfliktlösung: Priorisierung von Temperatur\n        if (dryAction.dehumidifier === \"increased\" && this.tentData.temperature < phaseConfig.targetTemp) {\n            dryAction.heater = \"increased\";\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE VPD Based\n    drySharkMouse(currentPhase) {\n        const phaseConfig = this.drying.modes.SharkMouse.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const vpdTolerance = 0.05; // Toleranz für VPD\n\n        // Anpassungen basierend auf VPD\n        const currentVPD = this.calculateCurrentVPD();\n        if (Math.abs(currentVPD - phaseConfig.targetVPD) > vpdTolerance) {\n            if (currentVPD < phaseConfig.targetVPD) {\n                dryAction.heater = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetVPD: phaseConfig.targetVPD,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE DewPoint Based\n    // DRYMODE DewPoint Based\n    dryDewBased(currentPhase) {\n        const phaseConfig = this.drying.modes.dewBased.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const dewPointTolerance = 0.5; // Toleranz für Taupunkt\n\n        // Anpassungen basierend auf Vapor Pressure (Taupunkt, tatsächlicher Dampfdruck und Sättigungsdampfdruck)\n        const currentDewPoint = this.calculateDewPoint();\n        const vaporPressureActual = this.drying.vaporPressureActual;\n        const vaporPressureSaturation = this.drying.vaporPressureSaturation;\n\n        // Sicherstellen, dass currentDewPoint eine Zahl ist\n        if (typeof currentDewPoint !== \"number\" || isNaN(currentDewPoint)) {\n            console.warn(\"Current Dew Point is unavailable or invalid.\");\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetDewPoint: phaseConfig.targetDewPoint,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction,\n                warning: \"Dew Point data is invalid or unavailable.\",\n            };\n        }\n\n        // Überprüfen, ob die aktuellen Werte im Zielbereich liegen\n        if (\n            Math.abs(currentDewPoint - phaseConfig.targetDewPoint) > dewPointTolerance ||\n            vaporPressureActual < 0.9 * vaporPressureSaturation ||\n            vaporPressureActual > 1.1 * vaporPressureSaturation\n        ) {\n            if (currentDewPoint < phaseConfig.targetDewPoint || vaporPressureActual < 0.9 * vaporPressureSaturation) {\n                dryAction.humidifier = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"unchanged\", cool: \"unchanged\", heat: \"increased\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"increased\", cool: \"unchanged\", heat: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetDewPoint: phaseConfig.targetDewPoint,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction,\n        };\n    }\n\n    // EXPERIMENTEL\n    ecoAdjustments(currentVPD = this.vpd.current, ecoTarget = this.vpd.ecotarget) {\n        let action;\n        let vpdECOPercent;\n\n        if (currentVPD < ecoTarget[0]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[0]) / ecoTarget[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n        } else if (currentVPD > ecoTarget[1]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[1]) / ecoTarget[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: currentVPD,\n            targetVPDMin: ecoTarget[0],\n            targetVPDMax: ecoTarget[1],\n            vpdDiffPercent: vpdECOPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // NIGHTHOLD VPD OUTPUT\n    inDontCareMode() {\n        let action = {\n            exhaust: \"maximal\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"maximal\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        // NEED TO TEST ON LIGHT OFF PHASE\n        node.warn(`Ignore VPD on NightTime run minimal Actions`);\n        return {\n            tentName: this.tentName,\n            tentMode: \"I DONT CARE MODE\",\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    /// DISABELD \n    disabledMode() {\n        node.log(\"Disabled mode active\");\n        let action = {\n            exhaust: \"Unchanged\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"Unchanged\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        return {\n            TentName: this.tentName,\n            tentMode: this.tentMode,\n            actions: action,\n        };\n    }\n\n    /// ACTIONS ******************************\n    selectAction() {\n        let preparedDevices = []; // Speicher für Geräteaktionen\n        let actionData;\n        let limitAdjustments\n        \n        // Prüfen, ob der Zustand seit der letzten Aktion unverändert ist\n        if (this.checkIfActionNeeded()) {\n            this.needchange = true;\n        } else {\n            this.needchange = false;\n            actionData = {\n                tentName: this.tentName,\n                tentMode: \"Unchanged\",\n                currentVPD: this.vpd.current,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n                Humidities: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity,\n                },\n                actions: this.actions.Unchanged,\n                deviceActions: preparedDevices,\n            };\n        }\n\n        // Modusabhängige Logik\n        if (this.needchange) {\n            switch (this.tentMode) {\n                case \"VPD Perfection\":\n                    actionData = this.perfectionAdjustments(\n                        this.vpd.current,\n                        this.vpd.perfection,\n                        this.vpd.perfectTolerance\n                    );\n                    break;\n                case \"IN-VPD-Range\":\n                    actionData = this.rangeAdjustments(\n                        this.vpd.current,\n                        this.vpd.range,\n                        this.vpd.rangeTolerance\n                    );\n                    break;\n                case \"Targeted VPD\":\n                    actionData = this.targetAdjustment(\n                        this.vpd.current,\n                        this.vpd.targeted,\n                        this.vpd.targetedTolerance\n                    );\n                    break;\n                case \"ECO-VPD\":\n                    actionData = this.ecoAdjustments(\n                        this.vpd.current,\n                        this.vpd.ecotarget,\n                    );\n                    break;\n                case \"Drying\":\n                    actionData = this.dryAdjustments();\n                    break;\n                case \"Disabled\":\n                    actionData = this.disabledMode();\n                    break;\n\n                default:\n                    throw new Error(\"Unknown mode: \" + this.tentMode);\n            }\n            if (this.isPlantDay.lightOn === false && this.isPlantDay.nightVPDHold === false) {\n                actionData = this.inDontCareMode()\n            }\n\n            // Vorzeitige Anpassungen\n            limitAdjustments = this.checkLimits();\n        }\n\n        // Kombiniere alle Aktionen\n        const finalActions = {\n            ...actionData.actions || null,\n            ...limitAdjustments || null,\n        };\n\n        this.devices.forEach((device) => {\n\n            // Prüfen, ob das Gerät korrekt initialisiert wurde\n            if (device.switches.length === 0) return\n            if (device && typeof device.prepareAction === \"function\") {\n                if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n\n                device = device.prepareAction(finalActions);\n\n                let actions = device.runAction()\n\n                //node.warn(`FinalAction: ${JSON.stringify(actions, null, 2)}`);\n\n                preparedDevices.push(actions)\n\n            } else {\n                // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n            }\n        });\n\n\n        if(this.needchange){\n            // Aktion speichern\n        this.dataSetter({\n                ...actionData || null,\n                actions: finalActions || null,\n                devices: this.devices || null,\n                deviceActions: preparedDevices || null,\n            });\n            // Rückgabe der Aktion mit den angepassten Geräten\n        }\n\n        // Rückgabe der Aktion mit den angepassten Geräten\n        return {\n            ...actionData || null,\n            actions: finalActions || null,\n            devices: this.devices || null,\n            deviceActions: preparedDevices || null,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp,\n            },\n            Humidities: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity,\n                },\n        };\n\n    }\n\n    checkLimits() {\n        let adjustments = {};\n\n        // Sicherstellen, dass der Modus nicht \"Drying\" ist\n        if (this.tentMode === \"Drying\") return;\n\n        // Keine Änderungen erforderlich, wenn kein Bedarf besteht\n        if (!this.needchange) return adjustments;\n\n        // Dynamische Gewichtung basierend auf Plant Stage\n        let humidityWeight, temperatureWeight;\n\n        if (this.controls.ownWeights) {\n            humidityWeight = this.controls.weights.hum || 1.0;\n            temperatureWeight = this.controls.weights.temp || 1.0;\n        } else {\n            if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                humidityWeight = 1.25; // Feuchtigkeit ist wichtiger\n                temperatureWeight = 1.0; // Temperatur ist weniger wichtig\n            } else {\n                humidityWeight = 1.0; // Standardgewichtung\n                temperatureWeight = 1.0;\n            }\n        }\n\n        // Initialisierung von Abweichungen\n        let tempDeviation = 0;\n        let humDeviation = 0;\n\n        // Abweichungen nur berechnen, wenn außerhalb der Grenzen\n        if (this.tentData.temperature > this.tentData.maxTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n        } else if (this.tentData.temperature < this.tentData.minTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.minTemp) * temperatureWeight;\n        }\n\n        if (this.tentData.humidity > this.tentData.maxHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n        } else if (this.tentData.humidity < this.tentData.minHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.minHumidity) * humidityWeight;\n        }\n\n        // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n        if (tempDeviation > 0 && humDeviation > 0 && this.isPlantDay.lightOn) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n            // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation > 0 && humDeviation < 0 && this.isPlantDay.lightOn) {\n            adjustments.humidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n            // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation > 0 && this.isPlantDay.lightOn) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n            // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation < 0 && this.isPlantDay.lightOn) {\n            adjustments.humidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.ventilation = \"reduced\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n        }\n\n        // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp + 5 && this.isPlantDay.lightOn) {\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n        if (this.tentData.temperature < this.tentData.minTemp - 5 && this.isPlantDay.lightOn) {\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            \n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n\n        }\n\n        // **7. Lichtsteuerung basierend auf Temperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"reduced\" : \"unchanged\"\n            node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n            \n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n        }\n\n        // **8. CO₂-Management**\n        if (this.tentData.co2Level < 400 && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            adjustments.co2 = \"increased\";\n            adjustments.exhaust = \"minimum\";\n            node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n\n        } else if (this.tentData.co2Level > 1200 && this.isPlantDay.lightOn) {\n            adjustments.light = this.vpd.lightControl ? \"increased\" : \"unchanged\"\n            adjustments.co2 = \"reduced\";\n            adjustments.exhaust = \"increased\";\n            node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n\n        }\n\n        // **9. Taupunkt- und Kondensationsschutz**\n        if (this.tentData.dewpoint >= this.tentData.temperature - 1 && this.isPlantDay.lightOn) {\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n\n        }\n\n        // **10. Nachtmodus (Licht aus, maximale Abluft)**\n        if (!this.isPlantDay.lightOn) {\n            adjustments.light = \"off\";\n            //adjustments.exhaust = \"maximum\";\n            //adjustments.ventilation = \"increased\";\n            //adjustments.co2 = \"minimum\";\n\n            // Ambient-Integration\n            const ambientInfluence = this.analyzeAmbientInfluence();\n            adjustments = { ...adjustments, ...ambientInfluence };\n\n            node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n        }\n\n        return adjustments;\n    }\n\n    checkLimits2() {\n        let adjustments = {};\n\n        // Sicherstellen, dass der Modus nicht \"Drying\" ist\n        if (this.tentMode === \"Drying\") return;\n\n        // Keine Änderungen erforderlich, wenn kein Bedarf besteht\n        if (!this.needchange) return adjustments;\n\n        // Dynamische Gewichtung basierend auf Plant Stage\n        let humidityWeight, temperatureWeight;\n\n        if (this.controls.ownWeights) {\n            humidityWeight = this.controls.weights.hum || 1.0;\n            temperatureWeight = this.controls.weights.temp || 1.0;\n        } else {\n            if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                humidityWeight = 1.25; // Feuchtigkeit ist wichtiger\n                temperatureWeight = 1.0; // Temperatur ist weniger wichtig\n            } else {\n                humidityWeight = 1.0; // Standardgewichtung\n                temperatureWeight = 1.0;\n            }\n        }\n\n        // Initialisierung von Abweichungen\n        let tempDeviation = 0;\n        let humDeviation = 0;\n\n        // Abweichungen nur berechnen, wenn außerhalb der Grenzen\n        if (this.tentData.temperature > this.tentData.maxTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n        } else if (this.tentData.temperature < this.tentData.minTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.minTemp) * temperatureWeight;\n        }\n\n        if (this.tentData.humidity > this.tentData.maxHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n        } else if (this.tentData.humidity < this.tentData.minHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.minHumidity) * humidityWeight;\n        }\n\n        // **Initialisiere climate innerhalb von adjustments**\n        adjustments.climate = {\n            cool: \"unchanged\",\n            heat: \"unchanged\",\n            dry: \"unchanged\",\n        };\n\n        // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n        if (tempDeviation > 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n            // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation > 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n            // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n            // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.ventilation = \"reduced\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n        }\n\n        // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp + 5) {\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n        if (this.tentData.temperature < this.tentData.minTemp - 5) {\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.heat = \"increased\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"maximum\"\n            }\n            node.warn(`${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **7. Lichtsteuerung basierend auf Temperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n        }\n\n        // **8. CO₂-Management**\n        if (this.tentData.co2Level < 400) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"increased\";\n                adjustments.exhaust = \"minimum\";\n                node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n            }\n\n        } else if (this.tentData.co2Level > 1200) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"reduced\";\n                adjustments.exhaust = \"increased\";\n                node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n            }\n            adjustments.co2 = \"reduced\";\n            adjustments.exhaust = \"increased\";\n            node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n        }\n\n        // **9. Taupunkt- und Kondensationsschutz**\n        if (this.tentData.dewpoint >= this.tentData.temperature - 1) {\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n        }\n\n        // **10. Nachtmodus (Licht aus, maximale Abluft)**\n        if (!this.isPlantDay.lightOn) {\n            adjustments.light = \"off\";\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.co2 = \"minimum\";\n            node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n        }\n\n        return adjustments;\n    }\n\n    analyzeAmbientInfluence() {\n        let ambientAdjustments = {};\n\n        // Temperaturdifferenz berechnen\n        const ambientTempDiff = this.tentData.temperature - this.enviorment.ambientTemp;\n\n        if (!isNaN(ambientTempDiff)) {\n            if (ambientTempDiff > 2) {\n                // Zelt ist wärmer -> Nutze Umgebungsluft zum Kühlen\n                ambientAdjustments.cooler = \"increased\";\n                ambientAdjustments.exhaust = \"increased\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, cool: \"increased\" };\n            } else if (ambientTempDiff < -2) {\n                // Zelt ist kälter -> Reduziere Abluft\n                ambientAdjustments.cooler = \"reduced\";\n                ambientAdjustments.exhaust = \"reduced\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, cool: \"reduced\" };\n            }\n        }\n\n        // Feuchtigkeitsdifferenz berechnen\n        const ambientHumDiff = this.tentData.humidity - this.enviorment.ambientHumidity;\n\n        if (!isNaN(ambientHumDiff)) {\n            if (ambientHumDiff > 5) {\n                // Zelt ist feuchter -> Nutze Umgebungsluft zum Entfeuchten\n                ambientAdjustments.dehumidifier = \"increased\";\n                ambientAdjustments.exhaust = \"increased\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, dry: \"increased\" };\n            } else if (ambientHumDiff < -5) {\n                // Zelt ist trockener -> Reduziere Abluft, erhöhe Befeuchtung\n                ambientAdjustments.humidifier = \"increased\";\n                ambientAdjustments.exhaust = \"reduced\";\n                ambientAdjustments.climate = { ...ambientAdjustments.climate, dry: \"reduced\" };\n            }\n        }\n\n        return ambientAdjustments;\n    }\n\n    // Experimentel ( use outsite and ambient data)\n    analyzeTrends() {\n        let trend = {\n            temperature: this.enviorment.outsiteTemp - this.enviorment.ambientTemp,\n            humidity: this.enviorment.outsiteHumidity - this.enviorment.ambientHumidity,\n        };\n\n        if (trend.temperature > 0) {\n            // Außentemperatur steigt -> Vorzeitig lüften\n            this.actionsIncreased.exhaust = \"preemptively increased\";\n        } else if (trend.temperature < 0) {\n            // Außentemperatur sinkt -> Lüftung reduzieren\n            this.actionsReduced.exhaust = \"preemptively reduced\";\n        }\n\n        if (trend.humidity > 0) {\n            // Außenfeuchtigkeit steigt -> Entfeuchter verstärken\n            this.actionsIncreased.dehumidifier = \"preemptively increased\";\n        } else if (trend.humidity < 0) {\n            // Außenfeuchtigkeit sinkt -> Befeuchter anpassen\n            this.actionsReduced.humidifier = \"preemptively reduced\";\n        }\n    }\n\n    // DATA SETTER FAKE DB ******************************\n    dataSetter(data) {\n        const time = new Date().toISOString();\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n        // Definiere eine Schwelle für Änderungen\n        const vpdThreshold = 0.005;\n\n        if (data.tentMode === \"Unchanged\" || this.tentMode === \"Unchanged\" || this.tentMode === \"Disabled\" || this.tentMode === \"I DONT CARE MODE\") {\n            return;\n        }\n\n        // Filter für aktive oder relevante Geräte\n        // Filter für aktive oder relevante Geräte\n        const relevantDevices = this.devices.filter(\n            (device) => (device.switches.length > 0) || device.isRunning\n        );\n\n        // Erstelle das Datenobjekt\n        const enrichedData = {\n            time,\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: this.vpd.current,\n            targetVPD: data.targetVPD,\n            targetVPDMin: this.vpd.range[0],\n            targetVPDMax: this.vpd.range[1],\n            vpdDiffPercent: data.vpdDiffPercent || 0,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp,\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity,\n            },\n            Dewpoint: this.tentData.dewpoint,\n            Environment: {\n                ambientTemp: this.enviorment.ambientTemp,\n                ambientHumidity: this.enviorment.ambientHumidity,\n                ambientDewpoint: this.enviorment.ambientDewpoint,\n            },\n            Outside: {\n                outsiteTemp: this.enviorment.outsiteTemp,\n                outsiteHumidity: this.enviorment.outsiteHumidity,\n                outsiteDewpoint: this.enviorment.outsiteDewpoint,\n            },\n            actions: data.actions,\n            devices: relevantDevices.map((device) => ({\n                ...device\n            })),\n            deviceActions: data.deviceActions\n        };\n\n        // Bedingung für signifikante Änderungen\n        const significantChange =\n            !lastAction ||\n            Math.abs(lastAction.currentVPD - this.vpd.current) > vpdThreshold ||\n            lastAction.Temps.Temperature !== enrichedData.Temps.Temperature ||\n            lastAction.Humditys.Humidity !== enrichedData.Humditys.Humidity ||\n            lastAction.Dewpoint !== enrichedData.Dewpoint;\n\n        if (significantChange) {\n            this.previousActions.push(enrichedData);\n            node.log(`Neue Aktion gespeichert:\", ${enrichedData}`);\n            return enrichedData\n        } else {\n            node.log(\"Änderung nicht signifikant - Keine Aktion gespeichert.\");\n        }\n\n        // Begrenze die Anzahl der gespeicherten Aktionen\n        if (this.previousActions.length > 250) {\n            this.previousActions = this.previousActions.slice(-250);\n        }\n\n    }\n\n    // Check if action is needed to chagnes in vpd \n    checkIfActionNeeded() {\n        if (this.previousActions.length === 0) return true;\n\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n\n       \n\n        // Prüfen, ob der aktuelle Zustand identisch mit dem letzten gespeicherten Zustand ist\n        if (lastAction && lastAction.currentVPD === this.vpd.current) {\n            //node.warn(\"VPD hat sich nicht geändert. Keine Aktion notwendig.\");\n            return false;\n        }else{\n            node.warn(`CurrentVPD:${this.vpd.current}, LastActionVPD:${lastAction.currentVPD}`)\n            return true;\n        }\n\n    }\n}\n\nclass Device{\n    constructor(deviceName, deviceType = \"generic\") {\n        this.name = deviceName;\n        this.deviceType = deviceType;\n        this.isRunning = false;\n        this.isLocked = false\n        this.lockedFor = \"\"\n        this.needChange = false\n        this.inRoomName = \"\"\n        this.isfromAmbient = false\n        this.action = \"\"\n        this.switches = [];\n        this.sensors = [];\n        this.data = {};\n\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n    }\n\n    /**\n     * Aktualisiert nur die geänderten Daten in einem Objekt.\n     * @param {Object} currentData - Das aktuelle Datenobjekt.\n     * @param {Object} newData - Das neue Datenobjekt.\n     * @returns {Object} - Die geänderten Werte (Key-Value-Paare).\n     */\n    updateChangedData(currentData, newData) {\n        if (!newData || typeof newData !== \"object\") return {};\n        if (!currentData || typeof currentData !== \"object\") currentData = {};\n\n        var changedData = {};\n\n        Object.keys(newData).forEach(function (key) {\n            var newValue = newData[key];\n            var currentValue = currentData[key];\n\n            // Nur geänderte Werte in das Ergebnis aufnehmen\n            if (currentValue !== newValue) {\n                changedData[key] = newValue;\n                currentData[key] = newValue; // Update den aktuellen Wert\n            }\n        });\n        return changedData;\n    }\n\n    setFromtent(roomName) {\n        if (roomName != this.inRoomName) {\n            this.inRoomName = roomName\n        }\n    }\n\n    identifyIfFromAmbient() {\n        if (typeof this.inRoomName === \"string\" &&\n            (this.inRoomName.toLowerCase().includes(\"ambient\"))) {\n            this.isfromAmbient = true;\n        } else {\n            this.isfromAmbient = false;\n        }\n    }\n\n    identifySwitchesAndSensors() {\n        if (!this.data || typeof this.data !== \"object\") return;\n\n        const keys = Object.keys(this.data);\n        this.switches = keys.filter((key) =>\n            key.startsWith(\"switch.\") || key.startsWith(\"light.\") || key.startsWith(\"fan.\") || key.startsWith(\"climate.\")\n        );\n        this.sensors = keys.filter((key) =>\n            key.startsWith(\"sensor.\") || key.startsWith(\"select.\") || key.startsWith(\"number.\") || key.startsWith(\"text.\") || key.startsWith(\"time.\")\n        );\n    }\n\n    updateIsRunningState() {\n        // Standardmäßig ist das Gerät nicht laufend\n        this.isRunning = false;\n\n        if (!this.data || typeof this.data !== \"object\") {\n            return;\n        }\n\n        // 1. Prüfen, ob ein Fan eingeschaltet ist\n        const fanKeys = Object.keys(this.data).filter((key) => key.startsWith(\"fan.\"));\n        if (fanKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        } else {\n            this.isRunning = false;\n        }\n\n        // 2. Prüfen, ob ein Light eingeschaltet ist\n        const lightKeys = Object.keys(this.data).filter((key) => key.startsWith(\"light.\"));\n        if (lightKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        } else {\n            this.isRunning = false;\n        }\n\n        // 3. Prüfen, ob eine Klimaanlage eingeschaltet ist\n        const climateKeys = Object.keys(this.data).filter((key) => key.startsWith(\"climate.\"));\n        if (climateKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        } else {\n            this.isRunning = false;\n        }\n\n        // 4. Prüfung Switches\n        const switchKeys = Object.keys(this.data).filter((key) => key.startsWith(\"switch.\"));\n        if (switchKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        } else {\n            this.isRunning = false;\n        }\n\n        // 5. Prüfung Humdifier\n        const humhKeys = Object.keys(this.data).filter((key) => key.startsWith(\"humidifier.\"));\n        if (humhKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        } else {\n            this.isRunning = false;\n        }\n\n        // 5. Prüfen, ob ein gültiger Duty-Cycle-Wert vorhanden ist\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"duty_cycle\") ||\n            key.toLowerCase().includes(\"dutycycle\") ||\n            key.toLowerCase().includes(\"duty\") ||\n            key.toLowerCase().includes(\"number.\") ||\n            key.toLowerCase().includes(\"voltage\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue) && dutyCycleValue > 0) {\n                //this.isRunning = true;\n                return;\n            }\n        }\n\n        // 6. Prüfen, ob Sensor-Werte anzeigen, dass das Gerät läuft\n        if (Array.isArray(this.sensors) && this.sensors.length > 0) {\n            const sensorKey = this.sensors.find((key) =>\n                key.toLowerCase().includes(\"duty_cycle\") || key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty\")\n            );\n            if (sensorKey && parseInt(this.data[sensorKey], 10) > 0) {\n                //this.isRunning = true;\n                return;\n            }\n        }\n    }\n\n    prepareAction(finalActions) {\n        if (finalActions.hasOwnProperty(this.deviceType)) {\n            const actionValue = finalActions[this.deviceType];\n\n            // Spezielles Verhalten für \"light\"-Geräte\n            if (this.deviceType === \"light\") {\n                if (actionValue !== \"unchanged\") {\n                    this.needChange = true;\n                    this.action = actionValue;\n                } else {\n                    this.needChange = false;\n                    this.action = actionValue;\n                }\n\n\n                // Sonderfall für \"climate\" Geräte\n            } else if (this.deviceType === \"climate\") {\n                //node.warn(`IN Climate Aciton Value: ${JSON.stringify(finalActions, actionValue)}`);\n                if (finalActions.climate && typeof finalActions.climate === \"object\") {\n                    for (const [mode, action] of Object.entries(finalActions.climate)) {\n                        if (action !== \"unchanged\") {\n                            this.needChange = true;\n                            this.action = { mode, action }; // Speichere den gefundenen Modus und die Aktion\n                            break; // Beende die Schleife, sobald der erste gültige Wert gefunden wurde\n                        }\n                    }\n                } else {\n                    this.action = \"unchanged\"; // Standardwert, falls keine gültigen Climate-Aktionen vorhanden sind\n                }\n            } else {\n                // Standard-Verhalten für andere Gerätetypen\n                if (actionValue === \"unchanged\") {\n                    this.needChange = false;\n                    this.action = actionValue;\n                } else if (\n                    [\"maximum\", \"reduced\", \"increased\", \"minimum\", \"on\", \"off\"].includes(actionValue)\n                ) {\n                    node.warn(`FoundAction: ${actionValue} for ${this.name} in ${this.inRoomName}`);\n                    this.needChange = true;\n                    this.action = actionValue;\n                }\n            }\n        } else {\n            // Falls keine Aktion definiert ist, logge Warnung\n            node.warn(`No actions defined for device type: ${this.deviceType}`);\n            this.needChange = false;\n            this.action = \"unchanged\";\n        }\n\n        // Debugging-Ausgabe zur Überprüfung der finalen Aktionen\n        //node.warn(`Prepared action for ${this.name}: ${JSON.stringify(this.action, null, 2)}, needChange: ${this.needChange}`);\n\n        return this;\n    }\n\n    evalAction() {\n        // Generische Prüfungen für alle Geräte\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction() {\n        // Falls keine Änderung notwendig ist, abbrechen\n        if (this.needChange === false) return;\n        if (!this.evalAction()) {\n            return { Device: `${this.switches[0]}`, Action: \"noChangesNeeded\", State: \"unchanged\" };\n        }\n\n        //node.warn(`Running Action for ${this.name} in ${this.inRoomName} `);\n        //node.warn(`Action State:${this.action}`);\n\n\n        // Aktion: increased\n        if (this.action === \"increased\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(50);\n                        node.warn(`${this.name} Duty-Cycle wurde auf 50% gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle + 5}% erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle + 5); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n\n            // Aktion: reduced\n        } else if (this.action === \"reduced\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät aus, falls es läuft\n                if (this.isRunning) {\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return this.turnOFF();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready OFF\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (this.dutyCycle === 5) {\n                    node.warn(`${this.name} ist auf Minimum gestellt in ${this.inRoomName} .`);\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return { entity_id: this.switches[0], action: \"Minium Reached\" }\n                } else {\n                    node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle - 5}% reduziert in ${this.inRoomName} .`);\n                    return this.changeDuty(this.dutyCycle - 5); // Beispiel: Reduziere Duty-Cycle um 10%\n                }\n            }\n\n            // Aktion: unchanged\n        } else if (this.action === \"maximum\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(100);\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX %gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX % erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(100); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n        } else if (this.action === \"minimum\") {\n\n        } else if (this.action === \"unchanged\") {\n            //node.warn(`${this.name} bleibt unverändert.`);\n            return { entity_id: this.switches[0], action: \"UNCHANGED\" }\n            // Fehlerfall\n        } else {\n            node.warn(`Etwas Ungewöhnliches ist passiert: ${this.name} hat eine unbekannte Aktion. Bitte Support kontaktieren.`);\n\n        }\n    }\n\n    turnOFF() {\n        let enitiy = this.switches[0]\n        if (this.isRunning === true) {\n            this.isRunning = false\n            return { \"entity_id\": enitiy, \"action\": \"off\" }\n        }\n\n    }\n\n    turnON() {\n        let enitiy = this.switches[0]\n        if (this.isRunning == false) {\n            this.isRunning = true\n            return { \"entity_id\": enitiy, \"action\": \"on\" }\n        }\n\n    }\n}\n\nclass Exhaust extends Device {\n    constructor(name, dutyCycle = 0) {\n        super(name, \"exhaust\");\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        this.minDuty = 10;\n        this.maxDuty = 95;\n        this.hasDuty = false;\n        this.isRuckEC = false;\n\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyIfRuckEC(); // RuckEC zuerst prüfen\n        this.findDutyCycle();    // Danach Duty Cycle suchen\n    }\n\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    identifyIfRuckEC() {\n        this.isRuckEC = this.name.toLowerCase().includes(\"ruck\");\n        if (this.isRuckEC) {\n            this.hasDuty = true\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten vorhanden.`);\n            this.dutyCycle = this.minDuty;\n            this.hasDuty = false;\n            return;\n        }\n\n        // Suche nach einem Schlüssel, der dutycycle oder duty_cycle enthält\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n\n            // Parse den Wert des gefundenen dutycycle-Keys\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                this.hasDuty = true;\n            } else {\n                this.dutyCycle = this.minDuty;\n                this.hasDuty = false;\n            }\n        } else {\n            this.dutyCycle = this.minDuty;\n            this.hasDuty = false;\n        }\n    }\n\n\n\n    setDutyCycle(dutyCycle) {\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        node.warn(`${this.name}: Duty Cycle auf ${this.dutyCycle}% gesetzt.`);\n        return this.dutyCycle;\n    }\n\n    changeDuty(duty) {\n        const newDuty = this.clampDutyCycle(duty);\n        if (this.switches?.[0]) {\n            const switchId = this.switches[0];\n            if (newDuty !== this.dutyCycle) {\n                const clampedDuty = this.clampDutyCycle(duty);\n                this.dutyCycle = clampedDuty;\n            } else {\n                return { entity_id: switchId, action: \"SameDuty\", dutycycle: newDuty };\n            }\n\n            node.warn(`${this.name}: Duty Cycle ${this.dutyCycle} an Abluft ${switchId} gesendet.`);\n            return { entity_id: switchId, action: \"dutycycle\", dutycycle: newDuty };\n        } else {\n            return { error: \"No switch available\" };\n        }\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { Exhaust: `${this.name}`, Action: \"NoChangeNeeded\" };\n        }\n\n        const switchId = this.switches?.[0];\n        if (!switchId) {\n            return { error: \"No switch available\" };\n        }\n\n        switch (this.action) {\n            case \"maximum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.maxDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"minimum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.minDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"increased\":\n                if (this.hasDuty) {\n                    const increasedDuty = Math.min(this.dutyCycle + 5, this.maxDuty);\n                    return this.changeDuty(increasedDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"reduced\":\n                if (this.hasDuty) {\n                    const reducedDuty = Math.max(this.dutyCycle - 5, this.minDuty);\n                    return this.changeDuty(reducedDuty);\n                } else {\n                    return this.turnOFF(switchId);\n                }\n\n\n            case \"on\":\n                return this.turnON(switchId);\n\n            case \"off\":\n                return this.turnOFF(switchId);\n\n            case \"unchanged\":\n                return { entity_id: switchId, action: \"UNCHANGED\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Exhaust: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Lüfter eingeschaltet in ${this.inRoomName}.`);\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Lüfter ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n}\n\nclass Ventilation extends Device {\n    constructor(name) {\n        super(name, \"ventilation\");\n        this.dutyCycle = 75; // Startwert\n        this.dutyMin = 75;   // Minimalwert\n        this.dutyMax = 100;  // Maximalwert\n        this.hasDuty = true; // Immer Duty Cycle verfügbar\n        this.isTasmota = false;\n        this.isInitialized = false; // Verhindert doppelte Initialisierung\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n\n        this.identifyIfTasmota(); // Prüfe, ob es ein Tasmota-Gerät ist\n\n        if (this.isTasmota) {\n            // Für Tasmota-Geräte initialisiere Duty Cycle und überspringe findDutyCycle\n            if (!this.isInitialized) {\n                this.initializeDutyCycle();\n                this.isInitialized = true;\n            }\n            return;\n        }\n\n        // Für Nicht-Tasmota-Geräte den Duty Cycle aus den Daten suchen\n        if (!this.isInitialized) {\n            this.initializeDutyCycle();\n            this.isInitialized = true;\n        } else {\n            this.findDutyCycle();\n        }\n    }\n\n    initializeDutyCycle() {\n        if (this.isTasmota) return\n        node.warn(`${this.name}: Initialisiere Duty Cycle auf ${this.dutyCycle}%.`);\n        this.dutyCycle = this.dutyMin; // Initialisiere auf 50%\n    }\n\n    identifyIfTasmota() {\n        if (Array.isArray(this.switches)) {\n            this.isTasmota = this.switches.some(\n                (switchDevice) => typeof switchDevice === \"string\" && switchDevice.startsWith(\"light.\")\n            );\n\n            if (this.isTasmota && !this.isInitialized) {\n                node.warn(`${this.name}: Tasmota-Ventilation erkannt. Duty Cycle wird auf 50% gesetzt.`);\n                this.dutyCycle = this.dutyMin; // Tasmota-Geräte starten mit 50%\n                this.isInitialized = true;\n            }\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                node.warn(`${this.name}: Duty Cycle aus Daten gesetzt auf ${this.dutyCycle}%.`);\n            }\n        } else {\n            node.warn(`${this.name}: Kein Duty Cycle-Schlüssel gefunden.`);\n        }\n    }\n\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.dutyMin, Math.min(this.dutyMax, dutyCycle));\n    }\n\n    setDutyCycle(dutyCycle) {\n        const clampedDuty = this.clampDutyCycle(dutyCycle);\n        this.dutyCycle = clampedDuty;\n        return clampedDuty;\n    }\n\n    changeDuty(switchId, duty) {\n        this.setDutyCycle(duty);\n        return { entity_id: switchId, action: \"dutycycle\", dutycycle: this.dutyCycle };\n    }\n\n    runAction() {\n        if (!this.needChange) return { Ventilation: `${this.switches[0]}`, Action: \"NoChangeNeeded\" };\n\n        const results = [];\n        const applyActionToSwitches = (actionCallback) => {\n            return this.switches.map((switchId) => {\n                const result = actionCallback(switchId);\n                results.push(result);\n                return result;\n            });\n        };\n\n        switch (this.action) {\n            case \"maximum\":\n                node.warn(`${this.name}: Duty Cycle auf Maximum (${this.dutyMax}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMax));\n\n            case \"minimum\":\n                node.warn(`${this.name}: Duty Cycle auf Minimum (${this.dutyMin}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMin));\n\n            case \"reduced\":\n                const reducedDuty = Math.max(this.dutyCycle - 5, this.dutyMin);\n                node.warn(`${this.name}: Duty Cycle reduziert auf ${reducedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, reducedDuty));\n\n            case \"increased\":\n                const increasedDuty = Math.min(this.dutyCycle + 5, this.dutyMax);\n                node.warn(`${this.name}: Duty Cycle erhöht auf ${increasedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, increasedDuty));\n\n            case \"on\":\n                return applyActionToSwitches((switchId) => this.turnON(switchId));\n\n            case \"off\":\n                return applyActionToSwitches((switchId) => this.turnOFF(switchId));\n\n            case \"unchanged\":\n                node.warn(`${this.name}: Keine Änderung erforderlich.`);\n                return applyActionToSwitches((switchId) => ({ entity_id: switchId, action: \"UNCHANGED\" }));\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Ventilation: `${this.switches[0]}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n}\n\nclass Climate extends Device {\n    constructor(name) {\n        super(name, \"climate\");\n        this.currentHAVOC = \"off\"; // Standardzustand\n        this.havocs = {\n            dry: \"dry\",\n            cool: \"cool\",\n            hot: \"hot\",\n            heat: \"heat\",\n            wind: \"wind\",\n            off: \"off\",\n        };\n        this.isRunning = false; // Status der Klimaanlage\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyCurrentHavoc();\n    }\n\n    identifyCurrentHavoc() {\n        const havocDevice = this.switches[0];\n        if (!havocDevice) {\n            console.warn(`${this.name}: Keine Switches definiert, um HAVOC zu identifizieren.`);\n            return;\n        }\n\n        const havocValue = this.data[havocDevice];\n\n        if (havocValue && Object.values(this.havocs).includes(havocValue)) {\n            this.currentHAVOC = havocValue;\n            console.warn(`${this.name}: HAVOC-Modus gesetzt auf \"${this.currentHAVOC}\".`);\n        } else {\n            console.warn(`${this.name}: Ungültiger HAVOC-Wert \"${havocValue}\", Standardwert \"off\" wird verwendet.`);\n        }\n    }\n\n    runAction() {\n        if (!this.needChange || !this.action || typeof this.action !== \"object\") {\n            console.warn(`${this.name}: Keine Änderungen erforderlich.`);\n            return null;\n        }\n\n        const { mode, action } = this.action;\n        const lowerMode = mode.toLowerCase(); // Konvertiere in Kleinbuchstaben\n        const validMode = this.havocs[lowerMode]; // Vergleiche mit `havocs` Mapping\n\n        console.warn(`Aktion empfangen: Mode = \"${mode}\", Action = \"${action}\", ValidMode = \"${validMode}\", CurrentHAVOC = \"${this.currentHAVOC}\"`);\n\n        // Prüfen, ob der Modus ungültig ist\n        if (!validMode) {\n            console.warn(`${this.name}: Ungültiger Modus \"${mode}\" erhalten. Standardwert \"off\" wird verwendet.`);\n            return { entity_id: this.switches[0], action: \"invalid_mode\", received_mode: mode };\n        }\n\n        // Prüfen, ob der Modus bereits läuft\n        if (this.isRunning && this.currentHAVOC.toLowerCase() === validMode) {\n            console.warn(`${this.name}: Keine Änderungen notwendig. Der Modus \"${validMode}\" ist bereits aktiv.`);\n            return { entity_id: this.switches[0], action: \"AllReady_ON\", climate_mode: this.currentHAVOC };\n        }\n\n        if (action === \"off\") {\n            return this.turnOFF();\n        }\n\n        if (!this.isRunning) {\n            return this.turnON(validMode);\n        }\n\n        return this.changeMode(validMode);\n    }\n\n    turnON(mode) {\n        this.isRunning = true;\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_Running\", climate_mode: mode };\n        }\n\n    }\n\n    turnOFF() {\n        if (this.isRunning) {\n            const previousMode = this.currentHAVOC;\n\n            if (this.isRunning === true) {\n                this.isRunning = false;\n                this.currentHAVOC = \"off\";\n                return { entity_id: this.switches[0], action: \"off\", previous_mode: previousMode };\n            } else {\n                return { entity_id: this.switches[0], action: \"AllreadyOFF\", previous_mode: previousMode };\n            }\n        }\n        return { entity_id: this.switches[0], action: \"already_off\" };\n    }\n\n    changeMode(mode) {\n\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_OFF\", climate_mode: mode };\n        }\n\n    }\n}\n\nclass Light extends Device {\n    constructor(name) {\n        super(name, \"light\");\n        this.hasDuty = false;\n        this.dutyCycle = null;\n        this.minDuty = 20;\n        this.maxDuty = 100;\n        this.lastSentDutyCycle = null;\n        this.voltage = 0.0;\n        this.sunriseMin = 2.0;\n        this.sunsetMin = 2.0;\n        this.stepSize = 1; // Schrittweite für Änderungen\n        this.sunRiseTime = \"\";\n        this.sunSetTime = \"\";\n        this.isSunrise = false;\n        this.isSunset = false;\n        this.lightOnTime = \"\"; // Startzeit des Lichts\n        this.lightOffTime = \"\"; // Endzeit des Lichts\n        this.isScheduled = false; // Ob das Licht Zeitpläne berücksichtigt\n        this.controlOverVoltage = false;\n        this.controledOverOGB = true\n        this.worksWithCO2 = false;\n        this.currentPlantPhase = {\n            min: 0,\n            max: 0,\n        };\n        this.PlantStageMinMax = {\n            Germ: {\n                min: 20,\n                max: 30,\n            },\n            Veg: {\n                min: 30,\n                max: 50,\n            },\n            Flower: {\n                min: 70,\n                max: 100,\n            },\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.setCurrenPlantPhaseName(context);\n        this.findDutyCycle(); // Initialisiere den Duty-Cycle, falls vorhanden\n        this.identifyIfControledByOGB(context.isPlantDay.lightbyOGBControl)\n        this.setLightTimes(context);\n        this.setSunTimes(context.isPlantDay.sunRiseTimes, context.isPlantDay.sunSetTimes);\n    }\n\n    identifyIfControledByOGB(controledBY) {\n        if (typeof controledBY !== \"boolean\") {\n            console.log(`${this.name}: Ungültiger Wert für controledBY.`);\n            return;\n        }\n\n        if (this.controlOverVoltage !== controledBY) {\n            this.controlOverVoltage = controledBY;\n            console.log(`${this.name}: controlOverVoltage wurde auf ${controledBY} gesetzt.`);\n        }\n    }\n\n    voltageFactorToDutyCycle(voltage) {\n        return Math.floor(voltage * 10);\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            console.log(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        const voltageKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n        );\n\n        if (voltageKey) {\n            const voltageValue = parseFloat(this.data[voltageKey]);\n            console.log(`DEBUG: VoltageKey gefunden: ${voltageKey}, VoltageValue: ${voltageValue}`);\n            if (!isNaN(voltageValue)) {\n                const calculatedDuty = this.voltageFactorToDutyCycle(voltageValue);\n\n                // Beschränke den Duty-Cycle auf Min- und Max-Werte\n                this.dutyCycle = Math.max(this.minDuty, Math.min(this.maxDuty, calculatedDuty));\n                this.voltage = voltageValue;\n                this.hasDuty = true;\n\n                console.log(`${this.name}: Duty-Cycle berechnet: ${this.dutyCycle}, Voltage: ${this.voltage}`);\n            } else {\n                this.hasDuty = false;\n                console.log(`${this.name}: Voltage-Wert ist ungültig.`);\n            }\n        } else {\n            console.log(`${this.name}: Kein Voltage-Key gefunden.`);\n            this.hasDuty = false;\n        }\n    }\n\n    setCurrenPlantPhaseName(context) {\n        if (!context) return;\n        if (context.plantStage !== this.currentPlantPhase) {\n            this.currentPlantPhase = context.plantStage;\n            this.setForPlantLightPhase();\n        }\n    }\n\n    setForPlantLightPhase() {\n        const phase = this.currentPlantPhase;\n        if (phase.includes(\"Germination\") || phase.includes(\"Clones\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Germ };\n        } else if (phase.includes(\"Veg\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Veg };\n        } else if (phase.includes(\"Flower\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Flower };\n        }\n        this.minDuty = this.currentPlantPhase.min;\n        this.maxDuty = this.currentPlantPhase.max;\n    }\n\n    setLightTimes(context) {\n        if (!context) return;\n        const { lightOnTime, lightOffTime } = context.isPlantDay || {};\n        this.lightOnTime = lightOnTime;\n        this.lightOffTime = lightOffTime;\n\n        if (this.lightOnTime && this.lightOffTime !== \"\") {\n            this.isScheduled = true;\n        }\n    }\n\n    setSunTimes(sunRiseTime, sunSetTime) {\n        if (this.hasDuty) {\n            if (sunRiseTime || sunSetTime !== \"\") {\n                this.sunRiseTime = sunRiseTime;\n                this.sunSetTime = sunSetTime;\n            }\n        } else {\n            return { ERROR: \"NoDuty\" }\n        }\n\n    }\n\n    parseTime(timeString) {\n        if (!timeString || typeof timeString !== \"string\") {\n            console.log(\"DEBUG: Invalid time string provided:\", timeString);\n            return 0; // Fallback auf Mitternacht\n        }\n\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return (hours * 3600) + (minutes * 60) + seconds;\n    }\n\n    checkforStartStop() {\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n        const startTime = this.parseTime(this.lightOnTime);\n        const endTime = this.parseTime(this.lightOffTime);\n    \n        console.log(`DEBUG: Current Time: ${currentSeconds}, Start Time: ${startTime}, End Time: ${endTime}`);\n    \n        let isLightOn;\n    \n        if (endTime < startTime) {\n            isLightOn = currentSeconds >= startTime || currentSeconds <= endTime;\n        } else {\n            isLightOn = currentSeconds >= startTime && currentSeconds <= endTime;\n        }\n    \n        console.log(`DEBUG: Is Light On: ${isLightOn}, Is Running: ${this.isRunning}`);\n    \n        if (!isLightOn && this.isRunning) {\n            console.log(`${this.name}: Turning light OFF as current time is outside schedule.`);\n            this.action = \"off\";\n            return this.turnOFF();\n        }\n    \n        if (isLightOn && !this.isRunning) {\n            console.log(`${this.name}: Turning light ON as current time is within schedule.`);\n            this.action = \"on\";\n            return this.turnON();\n        }\n    \n        console.log(`${this.name}: No changes needed for light schedule.`);\n        return null;\n    }\n    \n\n    checkforPhase() {\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n    \n        const lightOnSeconds = this.parseTime(this.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.lightOffTime);\n        const sunRiseSeconds = this.parseTime(this.sunRiseTime);\n        const sunSetSeconds = this.parseTime(this.sunSetTime);\n        const sunriseEndSeconds = lightOnSeconds + sunRiseSeconds;\n        const sunsetStartSeconds = lightOffSeconds - sunSetSeconds;\n    \n        const actions = [];\n        const tolerance = 1; // Kleiner Puffer (1% oder 0.1 bei Voltage)\n    \n        console.log(`DEBUG: Current Time (Seconds): ${currentSeconds}`);\n        console.log(`DEBUG: Light On Time: ${lightOnSeconds}, Light Off Time: ${lightOffSeconds}`);\n        console.log(`DEBUG: Sunrise End: ${sunriseEndSeconds}, Sunset Start: ${sunsetStartSeconds}`);\n        console.log(`DEBUG: Current Duty Cycle: ${this.dutyCycle}, Last Sent Duty Cycle: ${this.lastSentDutyCycle}`);\n        console.log(`DEBUG: Current Voltage: ${this.voltage}, Last Sent Voltage: ${this.lastSentVoltage}`);\n    \n        // **Sonnenaufgang (Sunrise Phase)**\n        if (currentSeconds >= lightOnSeconds && currentSeconds < sunriseEndSeconds) {\n            console.log(`${this.name}: Sunrise phase active.`);\n    \n            const elapsedSunrise = currentSeconds - lightOnSeconds;\n            const totalSunriseDuration = sunRiseSeconds;\n    \n            console.log(`DEBUG: Elapsed Sunrise Seconds: ${elapsedSunrise}, Total Sunrise Duration: ${totalSunriseDuration}`);\n    \n            // **Berechnung des Anstiegs der Helligkeit (Duty-Cycle)**:\n            const totalIncrement = (this.currentPlantPhase.max || this.maxDuty) - this.sunriseMin * 10; // Maximal bis zur Phasen-Maximum\n            const incrementFactor = Math.min(elapsedSunrise / totalSunriseDuration, 1); // Verhindere Überschreitung\n    \n            console.log(`DEBUG: Increment Factor: ${incrementFactor}, Total Increment: ${totalIncrement}`);\n    \n            let dutyIncrement = totalIncrement * incrementFactor;\n    \n            // Füge einen minimalen Puffer hinzu, wenn wir am Ende der Sunrise-Phase sind:\n            if (elapsedSunrise >= totalSunriseDuration - 1) {\n                dutyIncrement += tolerance; // Erhöhe minimal\n            }\n    \n            const newDuty = Math.min(this.currentPlantPhase.max || this.maxDuty, Math.floor(this.sunriseMin * 10 + dutyIncrement)); // Clamp auf Maximalwert\n            const newVoltage = parseFloat((newDuty / 10).toFixed(1)); // Voltage = DutyCycle / 10\n    \n            if (this.lastSentDutyCycle !== newDuty || this.lastSentVoltage !== newVoltage) {\n                this.dutyCycle = newDuty;\n                this.voltage = newVoltage;\n                this.lastSentDutyCycle = newDuty;\n                this.lastSentVoltage = newVoltage;\n    \n                if (this.controlOverVoltage) {\n                    actions.push({\n                        entity_id: this.sensors.find((key) => key.toLowerCase().includes(\"voltage\")),\n                        action: \"number\",\n                        value: newVoltage,\n                    });\n                } else if (this.hasDuty && !this.controlOverVoltage) {\n                    actions.push({\n                        entity_id: this.switches[0],\n                        action: \"dutycycle\",\n                        dutycycle: this.dutyCycle,\n                    });\n                }\n    \n                console.log(`DEBUG: Sunrise Phase - New Duty Cycle: ${this.dutyCycle}, Voltage: ${newVoltage}`);\n            } else {\n                console.log(`DEBUG: No changes to Duty Cycle during Sunrise Phase.`);\n            }\n        }\n    \n        // **Sonnenuntergang (Sunset Phase)** - Unverändert\n        else if (currentSeconds >= sunsetStartSeconds && currentSeconds <= lightOffSeconds) {\n            console.log(`${this.name}: Sunset phase active.`);\n    \n            const elapsedSunset = currentSeconds - sunsetStartSeconds;\n            const totalSunsetDuration = sunSetSeconds;\n    \n            console.log(`DEBUG: Elapsed Sunset Seconds: ${elapsedSunset}, Total Sunset Duration: ${totalSunsetDuration}`);\n    \n            const totalDecrement = this.dutyCycle - this.sunsetMin * 10; // Bis zum `sunsetMin`\n            const decrementFactor = Math.min(elapsedSunset / totalSunsetDuration, 1); // Verhindere Überschreitung\n    \n            console.log(`DEBUG: Decrement Factor: ${decrementFactor}, Total Decrement: ${totalDecrement}`);\n    \n            const newDuty = Math.max(this.sunsetMin * 10, Math.floor(this.dutyCycle - totalDecrement * decrementFactor)); // Clamp auf sunsetMin\n            const newVoltage = parseFloat((newDuty / 10).toFixed(1)); // Voltage = DutyCycle / 10\n    \n            if (this.lastSentDutyCycle !== newDuty || this.lastSentVoltage !== newVoltage) {\n                this.dutyCycle = newDuty;\n                this.voltage = newVoltage;\n                this.lastSentDutyCycle = newDuty;\n                this.lastSentVoltage = newVoltage;\n    \n                if (this.controlOverVoltage) {\n                    actions.push({\n                        entity_id: this.sensors.find((key) => key.toLowerCase().includes(\"voltage\")),\n                        action: \"number\",\n                        value: newVoltage,\n                    });\n                } else if (this.hasDuty && !this.controlOverVoltage) {\n                    actions.push({\n                        entity_id: this.switches[0],\n                        action: \"dutycycle\",\n                        dutycycle: this.dutyCycle,\n                    });\n                }\n    \n                console.log(`DEBUG: Sunset Phase - New Duty Cycle: ${this.dutyCycle}, Voltage: ${newVoltage}`);\n            } else {\n                console.log(`DEBUG: No changes to Duty Cycle during Sunset Phase.`);\n            }\n        }\n    \n        return actions;\n    }\n    \n    throttledUpdate(intervalInMs) {\n        const now = Date.now();\n        if (this.lastActionTime && now - this.lastActionTime < intervalInMs) {\n            console.log(`${this.name}: Übersprungen, da weniger als ${intervalInMs} ms vergangen sind.`);\n            return false;\n        }\n        this.lastActionTime = now;\n        return true;\n    }\n\n    resetPhaseAndTimes() {\n        this.action = \"Unchanged\"\n        this.currentPlantPhase.max = 0\n        this.currentPlantPhase.min = 0\n        this.dutyCycle = null\n        this.minDuty = null\n        this.maxDuty = null\n        this.lightOnTime = \"\"\n        this.lightOffTime = \"\"\n        this.sunRiseTime = \"\"\n        this.sunSetTime = \"\"\n\n        this.sunsetMin = null\n        this.sunriseMin = null\n    }\n\n\n    handleGeneralControl() {\n        if (!this.hasDuty) {\n            // Kein Duty-Modus: Schalte das Gerät einfach ein oder aus\n            if (this.action === \"on\" && !this.isRunning) {\n                return this.turnLightON();\n            } else if (this.action === \"off\" && this.isRunning) {\n                return this.turnLightOFF();\n            }\n        } else {\n            // Duty-Modus: Verwalte Duty-Cycle\n            let newDuty;\n            switch (this.action) {\n                case \"increased\":\n                    newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                    break;\n                case \"reduced\":\n                    newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                    break;\n                case \"reset\":\n                    newDuty = this.minDuty;\n                    break;\n                default:\n                    return null; // Unbekannte Aktion\n            }\n    \n            if (newDuty !== this.dutyCycle) {\n                return this.changeDuty(newDuty);\n            }\n        }\n    \n        return null; // Keine Änderungen notwendig\n    }\n    \n\n    handleGeneralControl2() {\n        if (!this.hasDuty) {\n            // Kein Duty-Modus: Schalte das Gerät einfach ein oder aus\n            if (this.action === \"on\" && !this.isRunning) {\n                return this.turnLightON();\n            } else if (this.action === \"off\" && this.isRunning) {\n                return this.turnLightOFF();\n            }\n        } else {\n            // Duty-Modus: Verwalte Duty-Cycle\n            let newDuty;\n            switch (this.action) {\n                case \"increased\":\n                    newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                    break;\n                case \"reduced\":\n                    newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                    break;\n                case \"maximum\":\n                    newDuty = this.maxDuty;\n                    break;\n                case \"minimum\":\n                    newDuty = this.minDuty;\n                    break;\n                default:\n                    return null; // Unbekannte Aktion\n            }\n\n            if (newDuty !== this.dutyCycle) {\n                return this.changeDuty(newDuty);\n            }\n        }\n\n        return null; // Keine Änderungen notwendig\n    }\n\n    runAction() {\n        if (!this.controledOverOGB) {\n            console.log(`${this.name}: Steuerung durch OGB deaktiviert.`);\n            return { Light: `${this.switches[0]}`, Action: \"NoControlForOGB\" };\n        }\n    \n        // Prüfen, ob Start/Stop-Logik angewendet werden muss\n        const startStopAction = this.checkforStartStop();\n        if (startStopAction) {\n            return [startStopAction]; // Priorisiere Start/Stop\n        }\n    \n        const actions = [];\n    \n        // Sunrise/Sunset-Logik prüfen\n        const phaseActions = this.checkforPhase();\n        if (phaseActions && phaseActions.length > 0) {\n            console.log(\"DEBUG: Phase actions found, skipping general actions.\");\n            actions.push(...phaseActions);\n        }\n    \n        // Allgemeine Steuerung ausführen, wenn keine Phase aktiv ist\n        if (!phaseActions || phaseActions.length === 0) {\n            console.log(\"DEBUG: No active phase. Executing general control.\");\n            const generalAction = this.handleGeneralControl();\n            if (generalAction) {\n                actions.push(generalAction);\n            }\n        }\n    \n        // Entfernen redundanter Aktionen\n        const filteredActions = actions.filter((action, index, self) =>\n            self.findIndex(a => a.entity_id === action.entity_id && a.action === action.action) === index\n        );\n    \n        console.log(`DEBUG: Actions nach Verarbeitung: ${JSON.stringify(filteredActions, null, 2)}`);\n        return filteredActions.length > 0 ? filteredActions : [];\n    }\n    \n    changeDuty(newDuty) {\n        if (!this.hasDuty) {\n            return { entity_id: this.switches[0], action: \"NoDutyCycle\" };\n        }\n\n        const clampedDuty = Math.max(this.minDuty, Math.min(this.maxDuty, newDuty));\n        const newVoltage = parseFloat((clampedDuty / 10).toFixed(1)); // Voltage ist Faktor 10 kleiner als DutyCycle\n\n        console.log(`DEBUG: Current DutyCycle: ${this.dutyCycle}, New DutyCycle: ${clampedDuty}`);\n        console.log(`DEBUG: Current Voltage: ${this.voltage}, New Voltage: ${newVoltage}`);\n\n        // **Fall 1: Kontrolle nur über Voltage**\n        if (this.controlOverVoltage) {\n            if (this.voltage !== newVoltage) {\n                this.voltage = newVoltage;\n                console.log(`${this.name}: Nur Voltage wird gesendet, da controlOverVoltage aktiviert ist.`);\n                const voltageEntity = this.sensors.find(key =>\n                    key.toLowerCase().includes(\"voltage\")\n                );\n                return [\n                    { entity_id: voltageEntity, action: \"number\", value: newVoltage }\n                ];\n            }\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n\n        // **Fall 2: Kontrolle über DutyCycle**\n        if (this.lastSentDutyCycle === clampedDuty && this.voltage === newVoltage) {\n            console.log(`${this.name}: Keine Änderung nötig. Duty-Cycle und Voltage bleiben gleich.`);\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n\n        // Aktualisiere Werte\n        this.dutyCycle = clampedDuty;\n        this.voltage = newVoltage;\n        this.lastSentDutyCycle = clampedDuty;\n\n        const voltageEntity = this.sensors.find(key =>\n            key.toLowerCase().includes(\"voltage\")\n        );\n\n        return [\n            { entity_id: this.switches[0], action: \"dutycycle\", dutycycle: clampedDuty }\n        ];\n    }\n\n    turnLightON() {\n        const entity = this.switches[0];\n\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Gerät wurde eingeschaltet in ${this.inRoomName}.`);\n\n            if (this.hasDuty) {\n                const newVoltage = parseFloat((this.dutyCycle / 10).toFixed(1));\n                this.voltage = newVoltage;\n\n                const voltageEntity = this.sensors.find(key =>\n                    key.toLowerCase().includes(\"voltage\")\n                );\n\n                console.log(`${this.name}: Voltage auf ${newVoltage}V gesetzt basierend auf Duty-Cycle ${this.dutyCycle}.`);\n                return [\n                    { entity_id: entity, action: \"on\" },\n                    { entity_id: voltageEntity, action: \"number\", value: newVoltage }\n                ];\n            }\n\n            return { entity_id: entity, action: \"on\" };\n        } else {\n            console.log(`${this.name}: Gerät ist bereits eingeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"AlreadyON\" };\n        }\n    }\n\n    turnLightOFF() {\n        const entity = this.switches[0]; // Dynamische Entität\n        if (this.isRunning) {\n            this.isRunning = false;\n            console.log(`${this.name}: Gerät wurde ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"off\" };\n        } else {\n            console.log(`${this.name}: Gerät ist bereits ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"AlreadyOFF\" };\n        }\n    }\n\n}\n\nclass Humidifier extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.targetHumidity = 0; // Ziel-Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n        this.realHumidifier = false; // Erkennung eines echten Luftbefeuchters\n        this.hasModes = false; // Erkennung von Modis\n        this.isSimpleSwitch = true; // Gerät ist nur ein einfacher Schalter\n        this.modes = {\n            interval: true,\n            small: false,\n            large: false,\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyIfHasModes();\n    }\n\n    identifyMode() {\n        if (!this.sensors || !Array.isArray(this.sensors)) {\n            console.log(`${this.name}: Keine Sensoren definiert.`);\n            return;\n        }\n\n        // Suche nach einem passenden Sensor (select.* und mode im Namen)\n        const modeSensor = this.sensors.find(sensor => sensor.startsWith(\"select.\") && sensor.includes(\"mode\"));\n\n        if (!modeSensor) {\n            console.log(`${this.name}: Kein passender Modus-Sensor gefunden.`);\n            return;\n        }\n\n        // Moduswert aus den Daten extrahieren\n        const modeValue = this.data[modeSensor];\n\n        if (!modeValue || modeValue === \"unavailable\") {\n            console.log(`${this.name}: Kein gültiger Moduswert verfügbar für Sensor \"${modeSensor}\".`);\n            return;\n        }\n\n        // Alle Modi zurücksetzen\n        this.modes = {\n            interval: false,\n            small: false,\n            large: false,\n        };\n\n        // Modus basierend auf dem Wert setzen\n        switch (modeValue) {\n            case \"interval\":\n                this.modes.interval = true;\n                break;\n            case \"small\":\n                this.modes.small = true;\n                break;\n            case \"large\":\n                this.modes.large = true;\n                break;\n            default:\n                console.log(`${this.name}: Unbekannter Moduswert \"${modeValue}\" für Sensor \"${modeSensor}\".`);\n                break;\n        }\n\n        //console.log(`${this.name}: Modus erkannt: ${modeValue}`);\n    }\n\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.isSimpleSwitch = true;\n                this.realHumidifier = false;\n            } else {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n            }\n        } else {\n            console.log(`${this.name}: Keine Daten vorhanden, Standard: Einfacher Schalter.`);\n            this.realHumidifier = false;\n            this.isSimpleSwitch = true;\n        }\n    }\n\n    identifyIfHasModes() {\n        if (this.data && this.data[\"select.humidifier_mode\"]) {\n            this.realHumidifier = true;\n            this.hasModes = true;\n            this.isSimpleSwitch = false;\n            this.identifyMode()\n        } else {\n            this.hasModes = false;\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) {\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n        const entity = this.sensors[0];\n        this.targetHumidity = humlevel;\n        console.log(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        // Wenn es ein einfacher Schalter ist\n        if (this.isSimpleSwitch) {\n            return this.action === \"increased\" || this.action === \"on\"\n                ? this.turnON()\n                : this.turnOFF();\n        }\n\n        // Für komplexe Geräte mit Modi\n        if (this.hasModes && this.realHumidifier) {\n            const actions = [];\n\n            // Gerät einschalten, falls es aus ist\n            if (!this.isRunning) {\n                const turnOnAction = this.turnON();\n                actions.push(turnOnAction);\n            }\n\n            // Modusänderung basierend auf der Aktion\n            if (this.action === \"increased\") {\n                const modeActions = this.changeMode(\"increase\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"reduced\") {\n                const modeActions = this.changeMode(\"decrease\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"off\") {\n                const turnOffAction = this.turnOFF();\n                actions.push(turnOffAction);\n            }\n\n            return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Action Found\" };\n        }\n\n        console.log(`${this.name}: Keine passenden Aktionen gefunden.`);\n        return { entity_id: this.switches[0], action: \"No Action Found\" };\n    }\n\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            this.closeModes()\n            console.log(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    closeModes(){\n        this.modes.small = true\n        this.modes.interval = false\n        this.modes.large = false\n    }\n\n    changeMode(direction) {\n        if (!this.hasModes) {\n            console.log(`${this.name}: Moduswechsel nicht unterstützt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n    \n        const actions = [];\n    \n        // Modusänderung basierend auf der Richtung\n        if (direction === \"increase\") {\n            // Wenn das Gerät aus ist und der Modus \"small\" ist, setze \"interval\"\n            if (!this.isRunning && this.modes.small) {\n                this.modes.interval = true;\n                this.modes.small = false;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n            // Wenn das Gerät läuft und im Modus \"small\" ist, wechsle direkt zu \"large\"\n            else if (this.isRunning && this.modes.small) {\n                this.modes.interval = false;\n                this.modes.small = false;\n                this.modes.large = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n            // Wenn der Modus \"interval\" ist, setze ihn auf \"small\"\n            else if (this.modes.interval) {\n                this.modes.interval = false;\n                this.modes.small = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            // Wenn der Modus \"small\" ist, setze ihn auf \"large\"\n            else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.large = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n        } else if (direction === \"decrease\") {\n            // Wenn der Modus \"large\" ist, setze ihn auf \"small\"\n            if (this.modes.large) {\n                this.modes.large = false;\n                this.modes.small = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            // Wenn der Modus \"small\" ist, setze ihn auf \"interval\"\n            else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n            // Wenn der Modus \"interval\" ist, schalte das Gerät aus\n            else if (this.modes.interval) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                this.modes.large = false;\n                actions.unshift({ entity_id: this.switches[0], action: \"off\" });\n                console.log(`${this.name}: Luftbefeuchter wird ausgeschaltet.`);\n            }\n        }\n    \n        // Gerät einschalten, wenn es aus ist\n        if (!this.isRunning) {\n            this.isRunning = true;\n            actions.unshift({ entity_id: this.switches[0], action: \"on\" });\n            console.log(`${this.name}: Luftbefeuchter wird eingeschaltet.`);\n        }\n    \n        // Rückgabe der Aktionen\n        return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Change\" };\n    }\n    \n\n    changeHumidity(delta) {\n        if (!this.realHumidifier) {\n            console.log(`${this.name}: Luftfeuchtigkeit kann nicht geändert werden, da es sich um einen einfachen Schalter handelt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            console.log(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        console.log(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"number\", value: newHumidity };\n    }\n}\n\nclass Humidifier1 extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.targetHumidity = 0; // Ziel-Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n        this.realHumidifier = false; // Erkennung eines echten Luftbefeuchters\n        this.hasModes = false; // Erkennung von Modis\n        this.isSimpleSwitch = true; // Gerät ist nur ein einfacher Schalter\n        this.modes = {\n            interval: false,\n            small: false,\n            large: false,\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyMode(); // Statt identifyIfHasModes\n    }\n\n\n    identifyMode() {\n        const modeSensor = this.sensors.find(sensor => sensor.startsWith(\"select.\") && sensor.includes(\"mode\"));\n        if (!modeSensor) {\n            node.warn(`${this.name}: Kein passender Modus-Sensor gefunden.`);\n            return;\n        }\n\n        const modeValue = this.data[modeSensor];\n        if (!modeValue || modeValue === \"unavailable\") {\n            node.warn(`${this.name}: Kein gültiger Moduswert verfügbar für Sensor \"${modeSensor}\".`);\n            return;\n        }\n\n        this.modes = { interval: false, small: false, large: false };\n\n        switch (modeValue) {\n            case \"interval\":\n                this.modes.interval = true;\n                break;\n            case \"small\":\n                this.modes.small = true;\n                break;\n            case \"large\":\n                this.modes.large = true;\n                break;\n            default:\n                node.warn(`${this.name}: Unbekannter Moduswert \"${modeValue}\" für Sensor \"${modeSensor}\".`);\n                break;\n        }\n    }\n\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            }\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) return { entity_id: this.switches[0], action: \"Unsupported\" };\n        const entity = this.sensors[0];\n        this.targetHumidity = humlevel;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n\n        if (this.isSimpleSwitch) {\n            return this.action === \"increased\" || this.action === \"on\" ? this.turnON() : this.turnOFF();\n        }   if (this.hasModes && this.realHumidifier) {\n            const actions = [];\n\n            // Gerät einschalten, falls es aus ist\n            if (!this.isRunning) {\n                const turnOnAction = this.turnON();\n                actions.push(turnOnAction);\n            }\n\n            // Modusänderung basierend auf der Aktion\n            if (this.action === \"increased\") {\n                const modeActions = this.changeMode(\"increase\");\n                actions.push(...modeActions); // Überprüfe, dass `modeActions` korrekt ist\n            } else if (this.action === \"reduced\") {\n                const modeActions = this.changeMode(\"decrease\");\n                actions.push(...modeActions); // Überprüfe, dass `modeActions` korrekt ist\n            } else if (this.action === \"off\") {\n                const turnOffAction = this.turnOFF();\n                actions.push(turnOffAction);\n            }\n\n            return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Action Found\" };\n            }\n\n\n            node.warn(`${this.name}: Keine passenden Aktionen gefunden.`);\n            return { entity_id: this.switches[0], action: \"No Action Found\" };\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            this.closeModes();\n            node.warn(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    closeModes() {\n        this.modes.small = true;\n        this.modes.interval = false;\n        this.modes.large = false;\n    }\n\n    changeMode(direction) {\n        if (!this.hasModes) {\n            node.warn(`${this.name}: Moduswechsel nicht unterstützt.`);\n            return [{ entity_id: this.switches[0], action: \"Unsupported\" }];\n        }\n\n        const actions = [];\n\n        // Gerät einschalten, wenn es aus ist\n        if (!this.isRunning) {\n            this.isRunning = true;\n            actions.push({ entity_id: this.switches[0], action: \"on\" });\n            node.warn(`${this.name}: Luftbefeuchter wird eingeschaltet.`);\n        }\n\n        // Modusänderung basierend auf der Richtung\n        if (direction === \"increase\") {\n            if (!this.modes.interval) {\n                this.modes.interval = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n            if (!this.modes.small) {\n                this.modes.small = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            if (!this.modes.large) {\n                this.modes.large = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n        } else if (direction === \"decrease\") {\n            if (this.modes.large) {\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            }\n            if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n        }\n\n        return actions.length > 0 ? actions : [{ entity_id: this.switches[0], action: \"No Change\" }];\n    }\n\n}\n\nclass Humidifier2 extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.targetHumidity = 0; // Ziel-Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n        this.realHumidifier = false; // Erkennung eines echten Luftbefeuchters\n        this.hasModes = false; // Erkennung von Modis\n        this.isSimpleSwitch = true; // Gerät ist nur ein einfacher Schalter\n        this.modes = {\n            interval: true,\n            small: false,\n            large: false,\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyIfHasModes();\n    }\n\n    identifyMode() {\n        if (!this.sensors || !Array.isArray(this.sensors)) {\n            node.warn(`${this.name}: Keine Sensoren definiert.`);\n            return;\n        }\n\n        // Suche nach einem passenden Sensor (select.* und mode im Namen)\n        const modeSensor = this.sensors.find(sensor => sensor.startsWith(\"select.\") && sensor.includes(\"mode\"));\n\n        if (!modeSensor) {\n            node.warn(`${this.name}: Kein passender Modus-Sensor gefunden.`);\n            return;\n        }\n\n        // Moduswert aus den Daten extrahieren\n        const modeValue = this.data[modeSensor];\n\n        if (!modeValue || modeValue === \"unavailable\") {\n            node.warn(`${this.name}: Kein gültiger Moduswert verfügbar für Sensor \"${modeSensor}\".`);\n            return;\n        }\n\n        // Alle Modi zurücksetzen\n        this.modes = {\n            interval: false,\n            small: false,\n            large: false,\n        };\n\n        // Modus basierend auf dem Wert setzen\n        switch (modeValue) {\n            case \"interval\":\n                this.modes.interval = true;\n                break;\n            case \"small\":\n                this.modes.small = true;\n                break;\n            case \"large\":\n                this.modes.large = true;\n                break;\n            default:\n                node.warn(`${this.name}: Unbekannter Moduswert \"${modeValue}\" für Sensor \"${modeSensor}\".`);\n                break;\n        }\n\n        //node.warn(`${this.name}: Modus erkannt: ${modeValue}`);\n    }\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.isSimpleSwitch = true;\n                this.realHumidifier = false;\n            } else {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n            }\n        } else {\n            node.warn(`${this.name}: Keine Daten vorhanden, Standard: Einfacher Schalter.`);\n            this.realHumidifier = false;\n            this.isSimpleSwitch = true;\n        }\n    }\n\n    identifyIfHasModes() {\n        if (this.data && this.data[\"select.humidifier_mode\"]) {\n            this.realHumidifier = true;\n            this.hasModes = true;\n            this.isSimpleSwitch = false;\n            this.identifyMode()\n        } else {\n            this.hasModes = false;\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) {\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n        const entity = this.sensors[0];\n        this.targetHumidity = humlevel;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        // Wenn es ein einfacher Schalter ist\n        if (this.isSimpleSwitch) {\n            return this.action === \"increased\" || this.action === \"on\"\n                ? this.turnON()\n                : this.turnOFF();\n        }\n\n        // Für komplexe Geräte mit Modi\n        if (this.hasModes && this.realHumidifier) {\n            const actions = [];\n\n            // Gerät einschalten, falls es aus ist\n            if (!this.isRunning) {\n                const turnOnAction = this.turnON();\n                actions.push(turnOnAction);\n            }\n\n            // Modusänderung basierend auf der Aktion\n            if (this.action === \"increased\") {\n                const modeActions = this.changeMode(\"increase\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"reduced\") {\n                const modeActions = this.changeMode(\"decrease\");\n                actions.push(...(Array.isArray(modeActions) ? modeActions : [modeActions]));\n            } else if (this.action === \"off\") {\n                const turnOffAction = this.turnOFF();\n                actions.push(turnOffAction);\n            }\n\n            return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Action Found\" };\n        }\n\n        node.warn(`${this.name}: Keine passenden Aktionen gefunden.`);\n        return { entity_id: this.switches[0], action: \"No Action Found\" };\n    }\n\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            this.closeModes()\n            node.warn(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    closeModes(){\n        this.modes.small = true\n        this.modes.interval = false\n        this.modes.large = false\n    }\n\n    changeMode(direction) {\n        if (!this.hasModes) {\n            node.warn(`${this.name}: Moduswechsel nicht unterstützt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const actions = [];\n\n        // Gerät einschalten, wenn es aus ist\n        if (!this.isRunning) {\n            this.isRunning = true;\n            actions.push({ entity_id: this.switches[0], action: \"on\" });\n            node.warn(`${this.name}: Luftbefeuchter wird eingeschaltet.`);\n        }\n\n        // Modusänderung basierend auf der Richtung\n        if (direction === \"increase\") {\n            if (this.modes.interval) {\n                this.modes.interval = false;\n                this.modes.small = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            } else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.large = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n        } else if (direction === \"decrease\") {\n            if (this.modes.large) {\n                this.modes.large = false;\n                this.modes.small = true;\n                this.modes.interval = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            } else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                this.modes.large = false;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            }\n        }\n\n        return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Change\" };\n    }\n\n\n    changeHumidity(delta) {\n        if (!this.realHumidifier) {\n            node.warn(`${this.name}: Luftfeuchtigkeit kann nicht geändert werden, da es sich um einen einfachen Schalter handelt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            node.warn(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        node.warn(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"number\", value: newHumidity };\n    }\n}\n\nclass Dehumidifier extends Device {\n    constructor(name) {\n        super(name, \"dehumidifier\");\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyIfHasModes();\n    }\n\n\n    identifyMode() {\n        if (!this.sensors || !Array.isArray(this.sensors)) {\n            node.warn(`${this.name}: Keine Sensoren definiert.`);\n            return;\n        }\n\n        // Suche nach einem passenden Sensor (select.* und mode im Namen)\n        const modeSensor = this.sensors.find(sensor => sensor.startsWith(\"select.\") && sensor.includes(\"mode\"));\n\n        if (!modeSensor) {\n            node.warn(`${this.name}: Kein passender Modus-Sensor gefunden.`);\n            return;\n        }\n\n        // Moduswert aus den Daten extrahieren\n        const modeValue = this.data[modeSensor];\n\n        if (!modeValue || modeValue === \"unavailable\") {\n            node.warn(`${this.name}: Kein gültiger Moduswert verfügbar für Sensor \"${modeSensor}\".`);\n            return;\n        }\n\n        // Alle Modi zurücksetzen\n        this.modes = {\n            dry: false\n\n        };\n\n        // Modus basierend auf dem Wert setzen\n        switch (modeValue) {\n            case \"dry\":\n                this.modes.interval = true;\n                break;\n            default:\n                node.warn(`${this.name}: Unbekannter Moduswert \"${modeValue}\" für Sensor \"${modeSensor}\".`);\n                break;\n        }\n\n        //node.warn(`${this.name}: Modus erkannt: ${modeValue}`);\n    }\n\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.isSimpleSwitch = true;\n                this.realHumidifier = false;\n            } else {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n            }\n        } else {\n            node.warn(`${this.name}: Keine Daten vorhanden, Standard: Einfacher Schalter.`);\n            this.realHumidifier = false;\n            this.isSimpleSwitch = true;\n        }\n    }\n\n    identifyIfHasModes() {\n        if (this.data && this.data[\"select.humidifier_mode\"]) {\n            this.realHumidifier = true;\n            this.hasModes = true;\n            this.isSimpleSwitch = false;\n            this.identifyMode()\n        } else {\n            this.hasModes = false;\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) {\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n        const entity = this.sensors[0];\n        this.targetHumidity = humlevel;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n}\n\nclass Heater extends Device {\n    constructor(name) {\n        super(name, \"heater\");\n    }\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\nclass Cooler extends Device {\n    constructor(name) {\n        super(name, \"cooler\");\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\n//NEED TO TEST THIS \nclass Pump extends Device {\n    constructor(name) {\n        super(name, \"pump\");\n        this.pumpInterval = 3600; // Mindestintervall zwischen Pumpzyklen (in Sekunden)\n        this.pumpDuration = 10; // Pumpdauer in Sekunden\n        this.isAutoRun = false; // Automatikmodus\n        this.OGBAutoMODE = false; // OpenGrowBox Steuerung\n        this.lastPumpTime = null; // Zeitpunkt des letzten Pumpvorgangs\n        this.soilMoisture = 0; // Bodenfeuchtigkeit\n        this.soilEC = 0; // Elektrische Leitfähigkeit\n        this.minSoilMoisture = 25; // Mindestbodenfeuchte\n        this.maxSoilEC = 2.5; // Maximaler EC-Wert\n    }\n\n    // Gerätedaten setzen und Bodenwerte aktualisieren\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        //this.data = { ...this.data, ...data };\n        this.updateChangedData(this.data, data);\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.evaluateStateFromData();\n        this.identifyIfOGBControlled(context);\n\n        // Aktualisiere Sensorwerte\n        if (data.soilmoisture) this.soilMoisture = parseFloat(data.soilmoisture);\n        if (data.soilec) this.soilEC = parseFloat(data.soilec);\n    }\n\n    // Prüfe OpenGrowBox Steuerung\n    identifyIfOGBControlled(context) {\n        this.OGBAutoMODE = !!context.controls.co2Control;\n    }\n\n    // Status aus Gerätedaten evaluieren\n    evaluateStateFromData() {\n        if (this.data) {\n            const pumpOnKey = Object.keys(this.data).find(key => key.includes(\"pump_on\"));\n            if (pumpOnKey) this.isRunning = this.data[pumpOnKey] === \"on\";\n\n            const autoRunKey = Object.keys(this.data).find(key => key.includes(\"pump_autorun\"));\n            if (autoRunKey) this.isAutoRun = this.data[autoRunKey] === \"on\";\n        }\n    }\n\n    // Mindestintervall prüfen\n    canPumpNow() {\n        const now = new Date();\n        const elapsedTime = this.lastPumpTime\n            ? (now.getTime() - this.lastPumpTime.getTime()) / 1000\n            : this.pumpInterval;\n\n        return elapsedTime >= this.pumpInterval;\n    }\n\n    // Prüfe, ob Bewässerung notwendig ist\n    needsWatering() {\n        return this.soilMoisture < this.minSoilMoisture && this.soilEC < this.maxSoilEC;\n    }\n\n    // Geräteaktionen ausführen\n    runAction(context) {\n        // Prüfe ob AutoModus aktiv ist\n        if (this.isAutoRun) {\n            return this.runAutoMode();\n        }\n\n        switch (this.action) {\n            case \"on\":\n                return this.runPump(\"on\");\n            case \"off\":\n                return this.runPump(\"off\");\n            case \"autorun-on\":\n                return this.setAutoMode(true);\n            case \"autorun-off\":\n                return this.setAutoMode(false);\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { entity_id: this.switches[0], action: \"UnknownAction\" };\n        }\n    }\n\n    // Automatische Steuerung der Pumpe\n    runAutoMode() {\n        if (!this.canPumpNow()) {\n            node.warn(`${this.name}: Intervall nicht erreicht.`);\n            return { entity_id: this.switches[0], action: \"wait_interval\" };\n        }\n\n        if (!this.needsWatering()) {\n            node.warn(`${this.name}: Keine Bewässerung notwendig (Moisture: ${this.soilMoisture}, EC: ${this.soilEC}).`);\n            return { entity_id: this.switches[0], action: \"no_water_needed\" };\n        }\n\n        this.lastPumpTime = new Date();\n        this.isRunning = true;\n\n        node.warn(`${this.name}: Starte automatische Bewässerung.`);\n        return { entity_id: this.switches[0], action: \"on\", duration: this.pumpDuration };\n    }\n\n    // Manuelle Pumpaktion ausführen\n    runPump(state) {\n        if (state === \"on\" && !this.isRunning) {\n            this.isRunning = true;\n            this.lastPumpTime = new Date();\n            node.warn(`${this.name}: Pumpe manuell eingeschaltet.`);\n            return { entity_id: this.switches[0], action: \"on\" };\n        } else if (state === \"off\" && this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Pumpe manuell ausgeschaltet.`);\n            return { entity_id: this.switches[0], action: \"off\" };\n        } else {\n            return { entity_id: this.switches[0], action: `Already ${state.toUpperCase()}` };\n        }\n    }\n\n    // AutoModus setzen\n    setAutoMode(state) {\n        this.isAutoRun = state;\n        const action = state ? \"on\" : \"off\";\n        node.warn(`${this.name}: Automatikmodus ${state ? \"aktiviert\" : \"deaktiviert\"}.`);\n        return { entity_id: this.switches[1], action: action };\n    }\n}\n\nclass CO2 extends Device {\n    constructor(name) {\n        super(name, \"co2\"); // Setze den Gerätetyp auf \"co2\"\n        this.targetCO2 = 0; // Zielwert für CO2 (ppm)\n        this.currentCO2 = 0; // Aktueller CO2-Wert (ppm)\n        this.autoRegulate = false; // Automatische Steuerung\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    setTargetCO2(target) {\n        if (target !== this.targetCO2) {\n            this.targetCO2 = target;\n        }\n    }\n\n    enableAutoRegulation() {\n        if (!this.enableAutoRegulation) {\n            this.autoRegulate = true;\n        }\n    }\n\n    disableAutoRegulation() {\n        if (this.enableAutoRegulation) {\n            this.autoRegulate = false;\n        }\n    }\n\n    updateCurrentCO2(value) {\n        if (value !== this.currentCO2) {\n            this.currentCO2 = value;\n        }\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") return false;\n\n        if (this.autoRegulate && this.currentCO2 < this.targetCO2) {\n            this.action = \"increased\";\n            return true;\n        } else if (this.autoRegulate && this.currentCO2 > this.targetCO2) {\n            this.action = \"reduced\";\n            return true;\n        }\n\n        return this.action !== \"unchanged\";\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { CO2: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"increased\":\n                node.warn(`${this.name}: CO2-Zufuhr wird erhöht.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"reduced\":\n                node.warn(`${this.name}: CO2-Zufuhr wird gestoppt.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"on\":\n                node.warn(`${this.name}: CO2-Zufuhr wird aktiviert.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: CO2-Zufuhr wird deaktiviert.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { CO2: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass GenericSwitch extends Device {\n    constructor(name) {\n        super(name, \"switch\"); // Setze den Gerätetyp auf \"switch\"\n        this.isRunning = false; // Status des Schalters\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Switch: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                if (!this.isRunning) {\n                    this.isRunning = true;\n                    node.warn(`${this.name}: Switch wird eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"on\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already ON\" };\n                }\n\n            case \"off\":\n                if (this.isRunning) {\n                    this.isRunning = false;\n                    node.warn(`${this.name}: Switch wird ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"off\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already OFF\" };\n                }\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Switch: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\n//// UNTIL HERE\n\nclass Sensor extends Device {\n    constructor(name) {\n        super(name, \"sensor\");\n        this.readings = []; // Speichert Sensordaten\n    }\n\n    addReading(reading) {\n        this.readings.push(reading);\n        return this.readings;\n    }\n\n    getLastReading() {\n        return this.readings.length > 0 ? this.readings[this.readings.length - 1] : null;\n    }\n\n    clearReadings() {\n        this.readings = [];\n    }\n}\n\n// Instanziiere die VPDControl-Klasse und speichere sie in der globalen Node-RED-Variablen\nglobal.set(\"OpenGrowBox\", OpenGrowBox);\nnode.status({ fill: \"green\", shape: \"ring\", text: \"OpenGrowBox Started\" });\nmsg.topic = \"Init\"\nreturn msg\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":280,"y":80,"wires":[[]]},{"id":"6bcddff9e4459ebe","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"event","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":350,"y":580,"wires":[]},{"id":"30e734dbde9b993e","type":"function","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Manager","func":"// Hole oder initialisiere die globale Variable für Räume\nif (msg.topic === \"all_rooms\") return null;\n\n// Prüfen, ob die Klasse OpenGrowBox im globalen Kontext verfügbar ist\nconst OpenGrowBox = global.get(\"OpenGrowBox\");\nif (!OpenGrowBox) {\n    node.error(\"OpenGrowBox class not found in global context\");\n    return null;\n}\n\nconst room = msg.topic;\n\n// Hole die aktuelle Instanz des Raums\nlet roomInstance = global.get(room);\n\n// Instanz für den Raum erstellen, falls sie nicht existiert\nif (!roomInstance) {\n    roomInstance = new OpenGrowBox(room);\n    global.set(room, roomInstance);\n    node.warn(`Created new room instance for: ${room}`);\n}\n\n// Prüfen, ob Payload-Daten vorhanden sind\nif (msg.payload && typeof msg.payload === \"object\") {\n    const data = msg.payload;\n\n    // Iteriere über die Räume (Gruppen) und Geräte\n    for (const roomKey in data) {\n        const group = data[roomKey];\n\n        // Iteration über die Geräte in der Gruppe\n        for (const deviceName in group) {\n            const deviceData = group[deviceName];\n            const currentRoomDevs = roomInstance.devices || []; // Geräte aus der Instanz abrufen oder leeres Array initialisieren\n\n            // Überprüfen, ob das Gerät bereits existiert\n            const existingDevice = currentRoomDevs.find((device) => device.name === deviceName);\n\n            if (existingDevice) {\n                // Gerät existiert: Aktualisieren\n                existingDevice.setData(deviceData, roomInstance);\n            } else {\n                // Gerät existiert nicht: Neues Gerät hinzufügen\n                roomInstance.addDevice(deviceName, deviceData, roomInstance);\n                //node.warn(`Added new device: ${deviceName}`);\n            }\n\n            // Iteration über die inneren Daten des Geräts für weitere Verarbeitung\n            for (const entity in deviceData) {\n                try {\n                    let currentValue = deviceData[entity];\n                    updateTentEnvs(entity, currentValue, roomInstance);\n                } catch (err) {\n                    node.error(`Error processing entity: ${entity} - ${err.message}`);\n                }\n            }\n        }\n    }\n\n    // Nach Verarbeitung die aktualisierte Instanz in den globalen Kontext zurückschreiben\n    global.set(room, roomInstance);\n}\n\n\n// Update-Funktion für TentEnvs\nfunction updateTentEnvs(entity, value, roomInstance) {\n    if (!roomInstance) return;\n\n    if (entity.toLowerCase().includes(\"ogb_dryingmodes\")) {\n        if(roomInstance.tentMode !== \"Drying\")return\n        let currentObjState = roomInstance.getDryingMode();\n        if(currentObjState === value) return\n        node.warn(`DryingMode geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setDryingMode(value);\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_plantstage\")) {\n        if (value === \"unknown\")return\n        let currentObjState = roomInstance.getPlantStageValue();\n        if(currentObjState === value)return \n        node.warn(`PlantStage geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setPlantStageValue(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_tentmode\")) {\n        let currentObjState = roomInstance.getTentMode() ;\n        if(currentObjState === value) return\n        node.warn(`TentMode geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setTentMode(value);\n\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_holdvpdnight\")) {\n        let currentObjState = roomInstance.getVPDNightHold();\n        if(currentObjState === value)return\n        node.warn(`VPD Night Hold geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setVPDNightHold(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_controlset\")) {\n        let currentObjState = roomInstance.getControlSet();\n        if(currentObjState === value) return\n        node.warn(`ControlSet geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setControlSet(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_vpdlightcontrol\")) {\n        let currentObjState = roomInstance.getVPDLightControl();\n        if(currentObjState === value) return\n        node.warn(`Control Light VPD geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setVPDLightControl(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_lightontime\")) {\n        \n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n        if (currentObjState !== value) {\n            let stopTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n            roomInstance.setLightTimes(value, stopTime);\n        }\n        roomInstance.updateLightState();\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_lightofftime\")) {\n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n        if (currentObjState !== value) {\n            let startTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n            roomInstance.setLightTimes(startTime, value);\n        }\n        roomInstance.updateLightState();\n    }\n    if (entity.toLowerCase().includes(\"ogb_sunrisetime\")) {\n        let currentObjState = roomInstance.isPlantDay.sunRiseTimes;\n        if (currentObjState !== value) {\n            node.warn(`Sunrise Value Verändert: ${currentObjState} -> ${value}`);\n            roomInstance.isPlantDay.sunRiseTimes = value\n        }\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_sunsettime\")) {\n        let currentObjState = roomInstance.isPlantDay.sunSetTimes;\n        if (currentObjState !== value) {\n            node.warn(`Sunset Value Verändert: ${currentObjState} -> ${value}`);\n            roomInstance.isPlantDay.sunSetTimes = value\n        }\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_vpdtarget\")) {\n        if(value === null)return\n        let currentObjState = parseFloat(roomInstance.getTargetedVPD());\n        if (parseFloat(currentObjState) === parseFloat(value)) return\n        node.warn(`Targeted VPD geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setTargetedVPD(parseFloat(value));\n\n    }   \n\n    if (entity.toLowerCase().includes(\"ogb_leaftemp\")) {\n        let currentObjState = parseFloat(roomInstance.getLeafOffset()) ;\n        if (parseFloat(currentObjState) === parseFloat(value)) return\n        node.warn(`LeafOffSet geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setLeafOffset(parseFloat(value));\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_co2_control\")) {\n        let currentObjState = roomInstance.getCO2Control();\n        if (currentObjState === value) return\n        node.warn(`CO2 Control geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setCO2Control(value);\n    }\n\n    if (entity.toLowerCase().includes(\"ogb_lightcontrol\")) {\n        let currentObjState = roomInstance.getLightControlByOGB();\n        if (currentObjState === value) return\n        node.warn(`OGBLightControl geändert: ${currentObjState} -> ${value}`);\n        roomInstance.setLightControlByOGB(value);\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_ownweights\")) {\n        let currentObjState = roomInstance.getifOwnWeightsActive();\n        if (currentObjState === value) return\n        node.warn(`OwnWeights geändert: ${currentObjState} -> ${value}`);\n        roomInstance.activateOwnWeights(value);\n    }\n    \n    if (entity.toLowerCase().includes(\"ogb_temperatureweight\") || entity.toLowerCase().includes(\"ogb_humidityweight\")) {\n        let currentObjState = roomInstance.getOwnWeights ? roomInstance.getOwnWeights() : \"\";\n\n        if (currentObjState !== value) {\n            roomInstance.setOwnWeights(entity, value);\n        }\n    }\n}\n\n// Rückgabe der aktualisierten Rauminstanz\nglobal.set(`${room}`, roomInstance);\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":900,"y":620,"wires":[["e8932288657b06b0","6fe72eaf1d2902f0","9243695e03284f5a"]]},{"id":"9243695e03284f5a","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"Manager","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":900,"y":580,"wires":[]},{"id":"ef80caba76d3b5d2","type":"debug","z":"5b9485aa95f0d129","g":"3523f89ec9c2c676","name":"debug 477","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":690,"y":580,"wires":[]},{"id":"139015f29bc3dd89","type":"debug","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"debug 481","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":710,"y":260,"wires":[]},{"id":"090ae69011847e65","type":"debug","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"debug 482","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":1050,"y":260,"wires":[]},{"id":"06edd4eb472d3731","type":"debug","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"debug 483","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":1310,"y":260,"wires":[]},{"id":"f539391e66f50ccf","type":"debug","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"debug 484","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":1290,"y":360,"wires":[]},{"id":"3173745ac1f6be42","type":"debug","z":"5b9485aa95f0d129","g":"43457bccef542a7d","name":"debug 485","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":1310,"y":440,"wires":[]},{"id":"a082b3fbdd22f46f","type":"function","z":"5b9485aa95f0d129","name":"OpenGrowBox","func":"class OpenGrowBox {\n    constructor(tentName = \"\", plantStage = \"\", tentMode = \"\", perfectionTolerance = 0.025) {\n\n        // Tent Environment        \n        this.tentName = tentName;\n        this.tentMode = tentMode;\n        this.plantStage = plantStage;\n        this.controlSet = \"\";\n\n        this.devices = [];\n        this.ownSetttetDevices = []\n\n        this.needchange = false\n        this.previousActions = [];\n\n        this.controls = {\n            ownWeights: false,\n            weights: {\n                temp: null,\n                hum: null,\n            },\n            co2Control: false,\n            co2ppm: {\n                minPPM: 400,\n                maxPPM: 1200,\n            },\n            ownDeviceSetup: false,\n            experimental: false,\n            modes: {\n                vpdPerfection: \"VPD Perfection\",\n                inRangeVPD: \"IN-VPD-Range\",\n                targetedVDP: \"Targeted VPD\",\n                drying: \"Drying\",\n                experimentel: \"Experimentel\",\n                disabled: \"Disabled\"\n            }\n        }\n\n        this.expMods = {\n            current: \"\",\n            plantType: \"\",\n        }\n\n        this.isPlantDay = {\n            nightVPDHold: false,\n            lightOn: false,\n            lightOnTime: \"\",\n            lightOffTime: \"\",\n            lightbyOGBControl: false,\n            sunRiseTimes: \"\",\n            sunSetTimes: \"\",\n        }\n\n        this.enviorment = {\n            ambientTemp: 0.0,\n            ambientHumidity: 0.0,\n            ambientDewpoint: 0.0,\n            outsiteTemp: 0.0,\n            outsiteHumidity: 0.0,\n            outsiteDewpoint: 0.0,\n        };\n\n        this.tentData = {\n            temperature: null,\n            humidity: null,\n            leafTempOffset: 0,\n            dewpoint: 0.0,\n            maxTemp: 0,\n            minTemp: 0,\n            maxHumidity: 0,\n            minHumidity: 0,\n            co2Level: 400,\n        };\n\n        this.plantStages = {\n            Germination: { vpdRange: [0.412, 0.7], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            Clones: { vpdRange: [0.42, 0.75], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            EarlyVeg: { vpdRange: [0.7, 0.85], minTemp: 20, maxTemp: 28, minHumidity: 55, maxHumidity: 70 },\n            MidVeg: { vpdRange: [0.85, 1.1], minTemp: 22, maxTemp: 30, minHumidity: 50, maxHumidity: 65 },\n            LateVeg: { vpdRange: [0.933, 1.2], minTemp: 22, maxTemp: 30, minHumidity: 50, maxHumidity: 60 },\n            EarlyFlower: { vpdRange: [1.0, 1.25], minTemp: 22, maxTemp: 28, minHumidity: 45, maxHumidity: 60 },\n            MidFlower: { vpdRange: [1.1, 1.4], minTemp: 22, maxTemp: 26, minHumidity: 40, maxHumidity: 55 },\n            LateFlower: { vpdRange: [1.3, 1.7], minTemp: 20, maxTemp: 24, minHumidity: 40, maxHumidity: 50 }\n        };\n\n        this.vpd = {\n            current: null,\n            // RANGE VPD\n            range: [],\n            rangeTolerance: 0.0,\n            diffRange: null,\n            // VPD PERFECTION\n            perfection: 0.0,\n            perfectMin: 0.0,\n            perfectMax: 0.0,\n            perfectTolerance: perfectionTolerance,\n            diffPerfection: null,\n            // TARGETED VPD\n            targeted: 0.0,\n            targetedTolerance: 0.0,\n            diffTargeted: null,\n            ecotarget: [0.55, 0.88]\n        };\n\n        this.watering = {\n            autoWatering: false,\n            isRunning: false,\n            pumpInvervall: \"\",\n            pumpTime: \"\",\n            nextPumpAction: \"\",\n            waterTemp: 0,\n            nutrients: {\n                PH: 0,\n                PPM: 0,\n                EC: 0,\n                Temp: 0,\n                N: 0,\n                P: 0,\n                K: 0,\n            }\n        }\n\n        this.dryStartTime = null;\n        this.drying = {\n            currentDryMode: \"\",\n            isEnabled: false,\n            isRunning: false,\n            waterActivity: 0.0,\n            dewpointVPD: 0.0,\n            vaporPressureActual: 0.0,\n            vaporPressureSaturation: 0.0,\n            sharkMouseVPD:0.0,\n            modes: {\n                elClassico: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetHumidity: 62, durationHours: 72\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetHumidity: 60, durationHours: 72\n                        },\n                        endTime: {\n                            targetTemp: 20, targetHumidity: 58, durationHours: 72\n                        }\n                    }\n                },\n                sharkMouse: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 22.2, targetHumidity: 55, targetVPD: 1.2, durationHours: 48\n                        },\n                        halfTime: {\n                            maxTemp: 23.3, targetHumidity: 52, targetVPD: 1.39, durationHours: 24\n                        },\n                        endTime: {\n                            maxTemp: 23.9, targetHumidity: 50, targetVPD: 1.5, durationHours: 48\n                        }\n                    }\n                },\n                dewBased: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetDewPoint: 12.25, durationHours: 96\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 96\n                        },\n                        endTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 48\n                        }\n                    }\n                }\n            }\n\n        }\n\n        this.addons = {\n            GasLanternRoutine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnPhase: 8,\n                        LightOffPhase: 16,\n                    },\n                    Indica: {\n                        LightOnPhase: 6,\n                        LightOffPhase: 18,\n                    }\n                }\n            },\n            GLR_NaturalSunshine: {\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 8,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    },\n                    Indica: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 6,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    }\n                }\n            }\n        }\n\n        //Actions\n        this.actions = {\n            Increased: {\n                exhaust: \"increased\",\n                humidifier: \"reduced\",\n                dehumidifier: \"increased\",\n                heater: \"increased\",\n                cooler: \"reduced\",\n                ventilation: \"increased\",\n                light: \"increased\",\n                co2: \"increased\",\n                climate: {\n                    cool: \"reduced\",\n                    dry: \"increased\",\n                    heat: \"increased\",\n                }\n            },\n            Reduced: {\n                exhaust: \"reduced\",\n                humidifier: \"increased\",\n                dehumidifier: \"reduced\",\n                heater: \"reduced\",\n                cooler: \"increased\",\n                ventilation: \"reduced\",\n                light: \"reduced\",\n                co2: \"reduced\",\n                climate: {\n                    cool: \"increased\",\n                    dry: \"reduced\",\n                    heat: \"reduced\",\n                }\n            },\n            Unchanged: {\n                exhaust: \"unchanged\",\n                humidifier: \"unchanged\",\n                dehumidifier: \"unchanged\",\n                heater: \"unchanged\",\n                cooler: \"unchanged\",\n                ventilation: \"unchanged\",\n                light: \"unchanged\",\n                climate: {\n                    cool: \"unchanged\",\n                    dry: \"unchanged\",\n                    heat: \"unchanged\"\n                }\n            },\n        }\n\n        this.init();\n    }\n\n    init() {\n\n    }\n\n    // DATA SETTER/GETTER ******************************\n    setTentName(tentName = \"\") {\n        if (tentName !== this.tentName) {\n            this.tentName = tentName;\n        }\n\n    }\n\n    // Setze ob Ausleih funktion für Ambient aktiv ist. \n    setControlSet(controlSet) {\n        if (this.controlSet !== controlSet) {\n            this.controlSet = controlSet\n        }\n    }\n\n    // erhalte ob Ambient Steuerung aktiv ist.\n    getControlSet() {\n        return this.controlSet\n    }\n\n    // Setze Aktiven ZeltMode\n    setTentMode(tentMode = \"\") {\n        if (this.tentMode !== tentMode) { // Vergleiche auf Gleichheit\n            node.warn(`TentMode geändert von ${this.tentMode} auf ${tentMode} in ${this.tentName}`);\n\n            // Prüfe, ob der neue Modus nicht \"Drying\" ist\n            if (tentMode !== \"Drying\") {\n                this.drying.isRunning = false;\n                this.drying.isEnabled = false;\n                this.drying.currentDryMode = \"\"; // Drying-Mode zurücksetzen\n                this.dryStartTime = null;        // Timer zurücksetzen\n                node.warn(\"Drying-Modus deaktiviert und Timer zurückgesetzt.\");\n            }\n\n            this.tentMode = tentMode; // Neuen Modus setzen\n        } else {\n            return; // Keine Änderung notwendig\n        }\n    }\n\n    getTentMode() {\n        return this.tentMode\n    }\n\n    // Setze Targeted VPD wenn Mode aktiv!\n    setTargetedVPD(targetVPD) {\n        if (targetVPD !== this.vpd.targeted) {\n            if (this.tentMode === \"Targeted VPD\") {\n                this.vpd.targeted = parseFloat(targetVPD)\n            }\n        }\n    }\n\n    // Ehalte Targeted VPD wenn Mode aktiv!\n    getTargetedVPD() {\n        return this.vpd.targeted;\n    }\n\n\n\n    // Setze Plant Stage\n    setPlantStageValue(plantStage = \"\") {\n        if (this.plantStages.hasOwnProperty(plantStage)) {\n            const stage = this.plantStages[plantStage];\n            this.vpd.range = stage.vpdRange;\n            this.tentData.maxTemp = stage.maxTemp;\n            this.tentData.minTemp = stage.minTemp;\n            this.tentData.maxHumidity = stage.maxHumidity;\n            this.tentData.minHumidity = stage.minHumidity;\n            this.calculatePerfectVPD();\n            this.plantStage = plantStage; // Stelle sicher, dass plantStage gesetzt wird\n            //node.warn(`PlantStage innerhalb der Instanz aktualisiert: ${this.plantStage}`);\n        } else {\n            //node.warn(`Ungültige PlantStage: ${plantStage}`);\n        }\n    }\n\n    getPlantStageValue() {\n        return this.plantStage\n    }\n\n    // Setze aktuelle Temp\n    setCurrentTemp(temp) {\n        let newTemp = null;\n\n        // Überprüfen, ob temp ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(temp)) {\n            newTemp = parseFloat(this.calculateAvgValue(temp));\n        } else if (typeof temp === 'number') {\n            newTemp = temp;\n        } else if (typeof temp === 'string') {\n            newTemp = parseFloat(temp);\n        } else {\n            throw new Error(\"Invalid temperature data. Must be an array, number, or string.\");\n        }\n\n        if (newTemp === this.tentData.temperature) return;\n\n        this.tentData.temperature = newTemp;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Blatt Temp Offset\n    setLeafOffset(offset) {\n        if (parseFloat(offset) !== parseFloat(this.tentData.leafTempOffset)) {\n            this.tentData.leafTempOffset = parseFloat(offset)\n        }\n    }\n\n    getLeafOffset() {\n        return this.tentData.leafTempOffset\n    }\n\n    // Setze aktuelle Feuchtigkeit\n    setCurrentHumidity(humidity) {\n        let newHumidity = null;\n\n        // Überprüfen, ob humidity ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(humidity)) {\n            newHumidity = parseFloat(this.calculateAvgValue(humidity));\n        } else if (typeof humidity === 'number') {\n            newHumidity = humidity;\n        } else if (typeof humidity === 'string') {\n            newHumidity = parseFloat(humidity);\n        } else {\n            throw new Error(\"Invalid humidity data. Must be an array, number, or string.\");\n        }\n\n        if (newHumidity === this.tentData.humidity) return;\n\n        this.tentData.humidity = newHumidity;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Ambient Raum Daten (WO DAS ZELT STEHT!!!!)\n    setAmbientData(ambTemp, ambHum, ambDew = null) {\n        // Exit if any value is null\n        if (ambTemp === null || ambHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = ambDew !== null ? ambDew : this.calculateDewPoint(ambTemp, ambHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.ambientTemp !== ambTemp ||\n            this.enviorment.ambientHumidity !== ambHum ||\n            this.enviorment.ambientDewpoint !== dewpoint\n        ) {\n            this.enviorment.ambientTemp = ambTemp;\n            this.enviorment.ambientHumidity = ambHum;\n            this.enviorment.ambientDewpoint = dewpoint;\n        }\n    }\n\n    // Setze Temp von Außen \n    setOutsiteData(outTemp, outHum, outDew = null) {\n        // Exit if any value is null\n        if (outTemp === null || outHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = outDew !== null ? outDew : this.calculateDewPoint(outTemp, outHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.outsiteTemp !== outTemp ||\n            this.enviorment.outsiteHumidity !== outHum ||\n            this.enviorment.outsiteDewpoint !== dewpoint\n        ) {\n            this.enviorment.outsiteTemp = outTemp;\n            this.enviorment.outsiteHumidity = outHum;\n            this.enviorment.outsiteDewpoint = dewpoint;\n        }\n    }\n\n    // Setze aktuellen Dewpoint\n    setCurrentDewPoint(dewpoint) {\n        if (dewpoint !== this.tentData.dewpoint) {\n            this.tentData.dewpoint = this.calculateDewPoint(dewpoint)\n        }\n    }\n\n    // Aktiviere Nacht VPD Ignoranz\n    setVPDNightHold(nightHold) {\n        if (nightHold != this.helperYesTrue(this.isPlantDay.nightVPDHold)) {\n            this.isPlantDay.nightVPDHold = this.helperYesTrue(nightHold)\n        }\n    }\n\n    getVPDNightHold() {\n        return this.helperYesTrue(this.isPlantDay.nightVPDHold)\n    }\n\n    // Aktiviere Gewicht für Feinjustierung\n    activateOwnWeights(activ) {\n        if (activ !== this.controls.ownWeights) {\n            this.controls.ownWeights = this.helperYesTrue(activ)\n            if (!this.controls.ownWeights) {\n                this.controls.weights.temp = null\n                this.controls.weights.hum = null\n            }\n        }\n    }\n\n    // Erhatel Gewicht Aktivi Status\n    getifOwnWeightsActive() {\n        return this.helperYesTrue(this.controls.ownWeights)\n    }\n\n    // Setze Gewicht für Feinjustierung\n    setOwnWeights(name, weight) {\n        if (!this.controls.ownWeights) {\n            // Wenn `ownWeights` deaktiviert oder nicht definiert ist\n            if (!this.controls.ownWeights) {\n                return { ownWeights: \"Disabled\" }; // Gebe zurück, dass `ownWeights` deaktiviert ist\n            }\n            // Falls `ownWeights` undefined oder nicht initialisiert ist\n            this.controls.ownWeights = null;\n            return { ownWeights: \"Disabled\" };\n        } else {\n            // Wenn `ownWeights` aktiviert ist\n            if (name.includes(\"hum\")) {\n                // Feuchtigkeitsgewicht setzen\n                this.controls.weights.hum = parseFloat(weight);\n            } else if (name.includes(\"temp\")) {\n                // Temperaturgewicht setzen\n                this.controls.weights.temp = parseFloat(weight);\n            } else {\n                // Ungültiger Name\n                console.warn(`Unrecognized weight type: ${name}`);\n                return { error: `Invalid weight type: ${name}` };\n            }\n\n            return { ownWeights: \"Enabled\" }; // Gebe zurück, dass `ownWeights` aktiviert ist\n        }\n    }\n\n    // Erhalte Gewicht für Feinjustierung\n    getOwnWeights() {\n        if (this.controls.ownWeights) {\n            return { tempWeight: this.controls.weights.temp, humWweight: this.controls.weights.hum }\n        } else {\n            return { Data: \"NotNeeded\" }\n        }\n    }\n\n    // EXPRIMENTEL\n    setGLSControl(glscControl) {\n        if (glscControl !== this.controls.experimental) {\n            this.controls.experimental = this.helperYesTrue(glscControl)\n        }\n    }\n\n    // EXPRIMENTEL\n    getGLSControl() {\n        return this.helperYesTrue(this.controls.experimental)\n    }\n\n    // EXPRIMENTEL\n    setGLSPlantType(plantType) {\n        if (this.controls.experimental) {\n            if (plantType !== this.controls.experimental) {\n                this.expMods.plantType = plantType\n            }\n        } else {\n            if (this.expMods.plantType != \"\") {\n                this.expMods.plantType = \"\"\n\n            }\n\n        }\n\n    }\n\n    // EXPRIMENTEL\n    getGLSPlantType() {\n        return this.expMods.plantType\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    setOwnDeviceSetup(deviceControl) {\n        if (deviceControl !== this.controls.ownDeviceSetup) {\n            this.controls.ownDeviceSetup = this.helperYesTrue(deviceControl)\n        }\n        return\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    getOwnDeviceSetup() {\n        return this.helperYesTrue(this.controls.ownDeviceSetup)\n    }\n\n    // Aktiviere CO2 Steuerung\n    setCO2Control(co2Control) {\n        if (co2Control !== this.controls.co2Control) {\n            this.controls.co2Control = this.helperYesTrue(co2Control)\n        }\n    }\n\n    // COS Status\n    getCO2Control() {\n        return this.helperYesTrue(this.controls.co2Control)\n    }\n\n    // Aktiviere Kontorlle für Licht\n    setLightControlByOGB(wantsControl) {\n        if (wantsControl !== this.isPlantDay.lightbyOGBControl) {\n            this.isPlantDay.lightbyOGBControl = this.helperYesTrue(wantsControl)\n        }\n    }\n\n    // Licht Controll Status\n    getLightControlByOGB() {\n        return this.helperYesTrue(this.isPlantDay.lightbyOGBControl)\n    }\n\n    // Setze lichtzeiten wenn Kontrolle AKTIV \n    setLightTimes(startTime = \"\", endTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (startTime !== this.isPlantDay.lightOnTime || endTime !== this.isPlantDay.lightOffTime) {\n            this.isPlantDay.lightOnTime = startTime;\n            this.isPlantDay.lightOffTime = endTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${startTime}, Ende: ${endTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setLightTimes(startTime, endTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n\n            this.updateLightState(); // Aktualisiere den Lichtstatus\n        }\n    }\n    // Setze Sonnen Auf/Untergang \n    setSunTimes(sunRiseTime = \"\", sunSetTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (sunRiseTime !== this.isPlantDay.sunRiseTimes || sunSetTime !== this.isPlantDay.sunSetTimes) {\n            this.isPlantDay.sunRiseTimes = sunRiseTime;\n            this.isPlantDay.sunSetTimes = sunSetTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${sunRiseTime}, Ende: ${sunSetTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setSunTimes(sunRiseTime, sunSetTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n        }\n    }\n\n\n    // HELPERS ******************************\n    helperYesTrue(input) {\n        if (typeof input === \"string\") {\n            // Convert string to boolean\n            const upperInput = input.toUpperCase(); // Normalize case\n            if (upperInput === \"YES\") return true;\n            if (upperInput === \"NO\") return false;\n        } else if (typeof input === \"boolean\") {\n            // Convert boolean to string\n            return input ? \"YES\" : \"NO\";\n        }\n        // Handle invalid input\n        throw new Error(\"Invalid input: expected a string ('YES'/'NO') or boolean (true/false).\");\n    }\n\n    // Aktualisierung des Lichtstatus basierend auf der aktuellen Zeit\n    updateLightState(currentTime = new Date()) {\n        // Hole die aktuelle Zeit in Sekunden\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        // Konvertiere Lichtzeiten in Sekunden\n        const lightOnSeconds = this.parseTime(this.isPlantDay.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.isPlantDay.lightOffTime);\n\n        let lightOn;\n\n        if (lightOffSeconds < lightOnSeconds) {\n            // Lichtzyklus über Mitternacht: Licht an, wenn aktuelle Zeit nach Startzeit oder vor Endzeit\n            lightOn = currentSeconds >= lightOnSeconds || currentSeconds < lightOffSeconds;\n        } else {\n            // Lichtzyklus innerhalb eines Tages: Licht an, wenn aktuelle Zeit zwischen Start- und Endzeit\n            lightOn = currentSeconds >= lightOnSeconds && currentSeconds < lightOffSeconds;\n        }\n\n        // Setze den Lichtstatus in isPlantDay.lightOn\n        if (this.isPlantDay.lightOn !== lightOn) {\n            this.isPlantDay.lightOn = lightOn;\n\n            // Logge Änderungen für Debugging\n            node.warn(\n                `${this.tentName}: Lichtstatus aktualisiert - ${lightOn ? \"Licht AN\" : \"Licht AUS\"\n                } (Aktuelle Zeit: ${currentTime.toTimeString()}, On: ${this.isPlantDay.lightOnTime\n                }, Off: ${this.isPlantDay.lightOffTime})`\n            );\n\n            // Überprüfe, ob ein Lichtgerät vorhanden ist, und aktualisiere es\n        }\n    }\n\n    // Hilfsfunktion zur Zeitumrechnung (HH:MM:SS → Sekunden)\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n\n    /// DEVCIES ******************************\n    // Methode zum Abrufen der passenden Geräteklasse\n    getDeviceClass(deviceType) {\n        const deviceClasses = {\n            humidifier: Humidifier,\n            dehumidifier: Dehumidifier,\n            exhaust: Exhaust,\n            ventilation: Ventilation,\n            heater: Heater,\n            cooler: Cooler,\n            light: Light,\n            pump: Pump,\n            climate: Climate,\n            switch: GenericSwitch,\n            sensor: Sensor,\n        };\n\n        return deviceClasses[deviceType] || Device;\n    }\n\n    // Gerät direkt zur Instanz hinzufügen und in entities speichern\n    addDevice(deviceName, deviceData, context) {\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData, context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n    }\n\n    // Geräte Identifizierung\n    identifyDevice(deviceName, deviceData) {\n        const deviceTypeMapping = {\n            \"sensor\": [\"mode\", \"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"h5179\"],\n            \"humidifier\": [\"humidifier\", \"mist\",\"befeuchter\",],\n            \"dehumidifier\": [\"dehumidifier\", \"drying\", \"dryer\",\"entfeuchter\", \"removehumidity\"],\n            \"exhaust\": [\"exhaust\", \"abluft\", \"ruck\"],\n            \"ventilation\": [\"vent\", \"vents\", \"venti\", \"ventilation\", \"inlet\", \"outlet\"],\n            \"heater\": [\"heater\", \"heizung\", \"warm\"],\n            \"cooler\": [\"cooler\", \"kühler\",\"klima\"],\n            \"light\": [\"light\", \"lamp\", \"led\", \"switch.light\"],\n            \"climate\": [\"climate\",\"klima\",],\n            \"co2\": [\"co2\", \"carbon\"],\n            \"switch\": [\"generic\", \"switch\"],\n            \"pump\": [\"pump\", \"waterpump\", \"pumpe\"],\n            //\"sensor\": [\"sensor\", \"mode\",\"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"flower\", \"veggi\", \"vegi\", \"dutycycle\", \"duty\", \"h5179\"],\n        };\n\n        // Prüfen, ob der Gerätename einen bekannten Typ enthält\n        // Überprüfen des Gerätetyps\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (keywords.some(keyword => deviceName.toLowerCase().includes(keyword))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                node.warn(`Device ${deviceName} identified as ${deviceType}`);\n                return new DeviceClass(deviceName, deviceType, deviceData);\n            }\n        }\n\n        // Prüfen, ob deviceData Schlüssel enthält, die auf einen Typ hindeuten\n        const entityKeys = Object.keys(deviceData || {});\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (entityKeys.some(key => keywords.some(keyword => key.toLowerCase().includes(keyword)))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                return new DeviceClass(deviceName, deviceType); // Gerät erstellen\n            }\n        }\n\n        node.warn(`Device ${deviceName} not recognized, returning unknown device.`);\n        return new Device(deviceName, \"unknown\");\n    }\n\n    // Registierung Caps ( noch nicht in nutzung)\n    registerDevices(device) {\n        // Sensoren ignorieren\n        if (device.deviceType.includes(\"sensor\")) return;\n        let capabilities\n        // Bestimme die Fähigkeiten des Geräts\n        capabilities = {\n            canHeat: device.deviceType === \"heater\" || device.deviceType === \"climate\" || device.deviceType === \"light\",\n            canCool: device.deviceType === \"cooler\" || device.deviceType === \"climate\",\n            canHumidify: device.deviceType === \"humidifier\",\n            canDehumidify: device.deviceType === \"dehumidifier\" || device.deviceType === \"climate\",\n            canVentilate: device.deviceType === \"ventilation\",\n            canExhaust: device.deviceType === \"exhaust\",\n            canLight: device.deviceType === \"light\",\n        };\n\n        // Entferne alle Fähigkeiten, die das Gerät nicht besitzt\n        capabilities = Object.fromEntries(\n            Object.entries(capabilities).filter(([key, value]) => value)\n        );\n\n        // Füge die bereinigten Fähigkeiten zum Gerät hinzu\n\n\n        // Füge das Gerät zum `registeredDevices`-Array hinzu\n        if (!this.devices) this.devices = [];\n        device.capabilities = { ...capabilities }\n\n        node.warn(`Device registered: ${device.name} with capabilities: ${Object.keys(capabilities).join(\", \")}`);\n    }\n\n    // Erhalte alle geräte \n    listDevices() {\n        return this.devices;\n    }\n\n    // Gerät sperren\n    lockDevice(device, roomName) {\n        if (!device.isLocked) {\n            device.isLocked = true;\n            device.lockedFor = roomName;\n            this.updateDevice(device);\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät entsperren\n    unlockDevice(device) {\n        if (device.isLocked) {\n            device.isLocked = false;\n            device.lockedFor = \"\";\n            console.warn(`Gerät entsperrt: ${device.name}`);\n            return true;\n        }\n        console.warn(`Gerät war nicht gesperrt: ${device.name}`);\n        return false;\n    }\n\n    // Gerät ausleihen\n    borrowDevice(device, fromTent) {\n        if (this.lockDevice(device, fromTent)) {\n            const borrowedIndex = this.devices.findIndex(d => d.name === device.name);\n            if (borrowedIndex === -1) {\n                this.devices.push(device);\n            }\n            device.inRoomName = this.tentName; // Setze den Raumnamen des geliehenen Geräts\n            device.isfromAmbient = false; // Markiere, dass es nicht mehr von Ambient kommt\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät aktualisieren\n    updateDevice(updatedDevice) {\n        const index = this.devices.findIndex(d => d.name === updatedDevice.name);\n        if (index !== -1) {\n            this.devices[index] = updatedDevice;\n        } else {\n            this.devices.push(updatedDevice);\n        }\n    }\n\n    // Gerät zurückgeben\n    returnDevice(device) {\n        if (this.unlockDevice(device)) {\n            // Entferne alle Instanzen des Geräts aus dem Array\n            device.action = \"off\";\n            device.mode = \"off\";\n            let offAction = device.turnOFF();\n            this.devices = this.devices.filter(d => d.name !== device.name);\n            console.warn(`Alle Instanzen von ${device.name} entfernt.`);\n\n            device.inRoomName = \"ambient\"; // Setze den Raumnamen zurück auf Ambient\n            device.isfromAmbient = true; // Markiere, dass es wieder zu Ambient gehört\n            device.action = \"off\";\n            node.warn(`OFF_Action_ROOM: ${JSON.stringify(offAction, null, 2)}`);\n            return offAction\n        }\n        console.warn(`Gerät konnte nicht entsperrt werden: ${device.name}`);\n        return false;\n    }\n\n\n    // Calc Funks ******************************\n    // Calc Dewpoint\n    calculateDewPoint(temperature = this.tentData.temperature, humidity = this.tentData.humidity) {\n        const temp = parseFloat(temperature);\n        const hum = parseFloat(humidity);\n        if (isNaN(temp) || isNaN(hum)) {\n            return \"unavailable\";\n        }\n\n        const a = 17.27;\n        const b = 237.7;\n\n        // Berechnung der Hilfsvariable γ(T, RH)\n        const gamma = (a * temp) / (b + temp) + Math.log(hum / 100);\n\n        // Berechnung des Taupunkts\n        const dewPoint = (b * gamma) / (a - gamma);\n        this.tentData.dewpoint = parseFloat(dewPoint.toFixed(2))\n        return parseFloat(dewPoint.toFixed(2));\n    }\n\n    // Calc Aktellen VPD ( Based TEMP-HUM-EAFTEMP)\n    calculateCurrentVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.leafTempOffset) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.vpd.current = parseFloat(vpd.toFixed(2));\n        return this.vpd.current;\n    }\n\n    // Calc Aktellen VPD Mittelwert aus aktuellen Plantstage min/max werten \n    calculatePerfectVPD(vpdRange = this.vpd.range) {\n        const averageVPD = (vpdRange[0] + vpdRange[1]) / 2;\n        this.vpd.perfection = parseFloat(averageVPD.toFixed(2));\n\n        this.vpd.perfectMin = parseFloat((this.vpd.perfection - this.vpd.perfectTolerance).toFixed(3));\n        this.vpd.perfectMax = parseFloat((this.vpd.perfection + this.vpd.perfectTolerance).toFixed(3));\n    }\n\n    // Berechne aus array/string/number/object den avg wert.\n    calculateAvgValue(temps = []) {\n        let sum = 0;\n        let count = 0;\n\n        // Prüfen, ob es ein Array von Zahlen ist oder ein Array von Objekten mit `value`\n        temps.forEach((entry) => {\n            let temp = parseFloat(entry.value);\n\n            if (!isNaN(temp)) {\n                sum += temp;\n                count++;\n            }\n        });\n\n        if (count === 0) {\n            return \"unavailable\";\n        }\n\n        const avg = sum / count;\n        return avg.toFixed(2);\n    }\n\n    // DRYING ******************************\n    // Setze aktuellen DryMode\n    setDryingMode(dryMode) {\n        if (this.tentMode !== \"Drying\") return\n        const normalizedMode = Object.keys(this.drying.modes).find(\n            mode => mode.toLowerCase() === dryMode.toLowerCase()\n        );\n\n        if (!normalizedMode) {\n            node.warn(`Ungültiger Trocknungsmodus: ${dryMode}. Standardmodus 'elClassico' wird verwendet.`);\n            this.drying.currentDryMode = \"elClassico\"; // Standardmodus setzen\n        } else {\n            this.drying.currentDryMode = normalizedMode;\n        }\n\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date)) {\n            this.setDryingStartTime();\n        }\n\n        this.drying.isEnabled = true;\n        this.drying.isRunning = true;\n        node.warn(`Trocknungsmodus aktiviert: ${this.drying.currentDryMode}`);\n    }\n\n    // Erhalte aktulle DryPhase nach Zeitpunkt\n    getDryingPhase() {\n        // Sicherstellen, dass dryStartTime gültig ist\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            node.error(\"Startzeit ist ungültig. Setze Startzeit neu.\");\n            this.setDryingStartTime();\n        }\n\n        // Sicherstellen, dass ein gültiger Drying-Mode gesetzt ist\n        if (!this.drying.currentDryMode || !this.drying.modes.hasOwnProperty(this.drying.currentDryMode)) {\n            node.error(\"Kein gültiger Drying-Mode gesetzt! Setze Standardmodus 'elClassico'.\");\n            this.setDryingMode(\"elClassico\");\n        }\n\n        const startTimeInSeconds = Math.floor(this.dryStartTime.getTime() / 1000);\n        const nowInSeconds = Math.floor(Date.now() / 1000);\n        const elapsedSeconds = nowInSeconds - startTimeInSeconds;\n\n        node.warn(`Verstrichene Zeit: ${elapsedSeconds} Sekunden`);\n\n        // Phasen abrufen und in Sekunden umrechnen\n        const currentMode = this.drying.modes[this.drying.currentDryMode];\n        const { start, halfTime, endTime } = currentMode.phase;\n\n        const startDuration = start.durationHours * 3600;\n        const halfTimeDuration = halfTime.durationHours * 3600;\n        const endTimeDuration = endTime.durationHours * 3600;\n\n        if (elapsedSeconds < startDuration) return \"start\";\n        if (elapsedSeconds < startDuration + halfTimeDuration) return \"halfTime\";\n        if (elapsedSeconds < startDuration + halfTimeDuration + endTimeDuration) return \"endTime\";\n\n        node.warn(\"Trocknung abgeschlossen.\");\n        return \"completed\";\n    }\n\n    // Erhalte aktuellen DryMode\n    getDryingMode() {\n        return this.drying.currentDryMode\n    }\n\n    // Setze Initale Zeit für DryZeitpunkt\n    setDryingStartTime() {\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            this.dryStartTime = new Date(); // Erstelle gültiges Date-Objekt\n            node.warn(`Startzeit wurde gesetzt: ${this.dryStartTime.toISOString()}`);\n        }\n    }\n\n    // Berechne Wasseraktivität\n    calcWatteractiviy(humidity = this.tentData.humidity) {\n        let hum = parseFloat(humidity);\n\n        if (isNaN(hum)) {\n            console.error(\"Invalid humidity value. Water activity cannot be calculated.\");\n            this.drying.waterActivity = null; // Setze den Wert explizit auf null bei Fehler\n            return null;\n        }\n\n        let wa = hum / 100; // Wasseraktivität berechnet als Verhältnis von Luftfeuchtigkeit\n        this.drying.waterActivity = parseFloat(wa.toFixed(2)); // Auf zwei Dezimalstellen runden\n        return this.drying.waterActivity;\n    }\n\n    // Berechne DewPointVPD (Based on Dewpoint/TEMP)\n    calcDewVPD(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for VPD calculation.\");\n            this.drying.dryingVPD = null;\n            return null;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * airTemp) / (airTemp + 237.3));\n        let adp = 0.6108 * Math.exp((17.27 * dewPoint) / (dewPoint + 237.3));\n\n        let dewVPD = sdpLuft - adp;\n        this.drying.dewpointVPD = parseFloat(dewVPD.toFixed(2)); // Rundet den VPD-Wert auf zwei Dezimalstellen\n        return this.drying.dewpointVPD;\n    }\n\n    // Berechne SharkMouse VPD (Based on TERMP/HUM/VPD)\n    calcSharkMouseVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.temperature) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.drying.sharkMouseVPD = parseFloat(vpd.toFixed(2));\n        return this.drying.sharkMouseVPD;\n    }\n\n    // Setze Aktuelle Vapor Pressure Werte\n    calcDryingVPs(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for vapor pressure calculation.\");\n            this.drying.vaporPressureActual = null;\n            this.drying.vaporPressureSaturation = null;\n            return null;\n        }\n\n        // Berechnung des tatsächlichen Dampfdrucks (ADP) am Taupunkt\n        let vaporPressureActual = 6.11 * Math.pow(10, (7.5 * dewPoint) / (237.3 + dewPoint));\n        this.drying.vaporPressureActual = parseFloat(vaporPressureActual.toFixed(2)); // Runden\n\n        // Berechnung des Sättigungsdampfdrucks (SDP) für Lufttemperatur\n        let vaporPressureSaturation = 6.11 * Math.pow(10, (7.5 * airTemp) / (237.3 + airTemp));\n        this.drying.vaporPressureSaturation = parseFloat(vaporPressureSaturation.toFixed(2)); // Runden\n\n        return {\n            vaporPressureActual: this.drying.vaporPressureActual,\n            vaporPressureSaturation: this.drying.vaporPressureSaturation,\n        };\n    }\n\n    //MODES ******************************\n    // MASTER MODE\n    ultraAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n\n        if (currentVPD < perfectVPD - tolerance) {\n            action = this.actions.Increased;\n        } else if (currentVPD > perfectVPD + tolerance) {\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"Ultra Perfection\",\n            currentVPD: currentVPD,\n            targetVPD: perfectVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            perfectMin: this.vpd.perfectMin,\n            perfectMax: this.vpd.perfectMax,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // MITTEL wert ziel aus range vpd werten\n    perfectionAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n\n        if (currentVPD < perfectVPD - tolerance) {\n            action = this.actions.Increased;\n        } else if (currentVPD > perfectVPD + tolerance) {\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"VPD Perfection\",\n            currentVPD: currentVPD,\n            targetVPD: perfectVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            perfectMin: this.vpd.perfectMin,\n            perfectMax: this.vpd.perfectMax,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Jumper zwishen min und max werten.\n    rangeAdjustments(currentVPD = this.vpd.current, targetVPDRange = this.vpd.range, tolerance = this.vpd.rangeTolerance) {\n        let action;\n        let vpdDiffPercent;\n\n        if (currentVPD < targetVPDRange[0] - tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[0]) / targetVPDRange[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n        } else if (currentVPD > targetVPDRange[1] + tolerance) {\n            vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[1]) / targetVPDRange[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inMode: \"VPD Range\",\n            currentVPD: currentVPD,\n            targetVPDMin: targetVPDRange[0],\n            targetVPDMax: targetVPDRange[1],\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // Targeted VPD Ziel mit Targed VPD\n    targetAdjustment(currentVPD = this.vpd.current, targetVPD = this.vpd.targeted, tolerance = this.vpd.targetedTolerance) {\n        let action;\n        let vpdDiffPercent = parseFloat((((currentVPD - targetVPD) / targetVPD) * 100)); // Korrektur der Berechnung\n\n        if (currentVPD < targetVPD + tolerance) {\n            action = this.actions.Increased;\n        } else if (currentVPD > targetVPD + tolerance) {\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: currentVPD,\n            targetedVPD: targetVPD,\n            vpdDiffPercent: vpdDiffPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // DryingModeChecks \n    dryAdjustments() {\n        if (!this.drying.isEnabled || !this.drying.isRunning) {\n            this.drying.isEnabled = true;\n            this.drying.isRunning = true;\n            this.setDryingStartTime();\n            node.warn(\"Trocknung gestartet und Status aktualisiert.\");\n        }\n\n        const currentPhase = this.getDryingPhase();\n        if (!currentPhase) {\n            node.error(\"Keine Phase berechnet, Startzeit fehlt.\");\n            return { error: \"Phase konnte nicht berechnet werden.\" };\n        }\n\n        if (currentPhase === \"completed\") {\n            node.warn(\"Trocknung abgeschlossen.\");\n            this.drying.isRunning = false;\n            return { status: \"completed\" };\n        }\n\n        // Wasseraktivität und VPD berechnen\n        this.calcWatteractiviy(this.tentData.humidity);\n        this.calcDewVPD(this.tentData.temperature, this.tentData.dewpoint);\n        this.calcDryingVPs(this.tentData.temperature, this.tentData.dewpoint)\n        this.calcSharkMouseVPD(this.tentData.temperature, this.tentData.humidity)\n\n        node.warn(`CURRENTPHASE: ${currentPhase}`);\n\n\n        // Phase-spezifische Aktionen ausführen\n        switch (this.drying.currentDryMode) {\n            case \"elClassico\":\n                return this.dryElClassico(currentPhase);\n            case \"sharkMouse\":\n                return this.drySharkMouse(currentPhase);\n            case \"dewBased\":\n                return this.dryDewBased(currentPhase);\n            default:\n                node.error(\"Unbekannter Drying-Mode!\");\n                return { error: \"Unbekannter Drying-Mode\" };\n        }\n    }\n\n    // DRYMODE Classic\n    dryElClassico(currentPhase) {\n        const phaseConfig = this.drying.modes.elClassico.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const tempTolerance = 0.5; // Toleranz in °C\n        const humTolerance = 2;   // Toleranz in %\n\n        // Anpassungen basierend auf Temperatur\n        if (Math.abs(this.tentData.temperature - phaseConfig.targetTemp) > tempTolerance) {\n            if (this.tentData.temperature < phaseConfig.targetTemp) {\n                dryAction.heater = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        // Anpassungen basierend auf Feuchtigkeit\n        if (Math.abs(this.tentData.humidity - phaseConfig.targetHumidity) > humTolerance) {\n            if (this.tentData.humidity < phaseConfig.targetHumidity) {\n                dryAction.humidifier = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"unchanged\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { ...dryAction.climate, dry: \"increased\" };\n            }\n        }\n\n        // Konfliktlösung: Priorisierung von Temperatur\n        if (dryAction.dehumidifier === \"increased\" && this.tentData.temperature < phaseConfig.targetTemp) {\n            dryAction.heater = \"increased\";\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE VPD Based\n    drySharkMouse(currentPhase) {\n        const phaseConfig = this.drying.modes.sharkMouse.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const vpdTolerance = 0.05; // Toleranz für VPD\n\n        // Anpassungen basierend auf VPD\n        const currentVPD = this.calculateCurrentVPD();\n        if (Math.abs(currentVPD - phaseConfig.targetVPD) > vpdTolerance) {\n            if (currentVPD < phaseConfig.targetVPD) {\n                dryAction.heater = \"increased\";\n                dryAction.dehumidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"increased\", cool: \"unchanged\", dry: \"unchanged\" };\n            } else {\n                dryAction.cooler = \"increased\";\n                dryAction.humidifier = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { heat: \"unchanged\", cool: \"increased\", dry: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetHum: phaseConfig.targetHumidity,\n                targetVPD: phaseConfig.targetVPD,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction\n        };\n    }\n\n    // DRYMODE DewPoint Based\n    // DRYMODE DewPoint Based\n    dryDewBased(currentPhase) {\n        const phaseConfig = this.drying.modes.dewBased.phase[currentPhase];\n        const dryAction = { ...this.actions.Unchanged }; // Modus-spezifische Aktionen\n        const dewPointTolerance = 0.5; // Toleranz für Taupunkt\n\n        // Anpassungen basierend auf Vapor Pressure (Taupunkt, tatsächlicher Dampfdruck und Sättigungsdampfdruck)\n        const currentDewPoint = this.calculateDewPoint();\n        const vaporPressureActual = this.drying.vaporPressureActual;\n        const vaporPressureSaturation = this.drying.vaporPressureSaturation;\n\n        // Sicherstellen, dass currentDewPoint eine Zahl ist\n        if (typeof currentDewPoint !== \"number\" || isNaN(currentDewPoint)) {\n            console.warn(\"Current Dew Point is unavailable or invalid.\");\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetDewPoint: phaseConfig.targetDewPoint,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction,\n                warning: \"Dew Point data is invalid or unavailable.\",\n            };\n        }\n\n        // Überprüfen, ob die aktuellen Werte im Zielbereich liegen\n        if (\n            Math.abs(currentDewPoint - phaseConfig.targetDewPoint) > dewPointTolerance ||\n            vaporPressureActual < 0.9 * vaporPressureSaturation ||\n            vaporPressureActual > 1.1 * vaporPressureSaturation\n        ) {\n            if (currentDewPoint < phaseConfig.targetDewPoint || vaporPressureActual < 0.9 * vaporPressureSaturation) {\n                dryAction.humidifier = \"increased\";\n                dryAction.cooler = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"unchanged\", cool: \"unchanged\", heat: \"increased\" };\n            } else {\n                dryAction.dehumidifier = \"increased\";\n                dryAction.heater = \"unchanged\";\n                dryAction.exhaust = \"increased\";\n                dryAction.ventilation = \"increased\";\n                dryAction.climate = { dry: \"increased\", cool: \"unchanged\", heat: \"unchanged\" };\n            }\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            inDryMode: this.drying.currentDryMode,\n            startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n            currentPhase,\n            targetValues: {\n                targetTemp: phaseConfig.targetTemp,\n                targetDewPoint: phaseConfig.targetDewPoint,\n                targetDuration: phaseConfig.durationHours,\n            },\n            actions: dryAction,\n        };\n    }\n\n\n    // EXPERIMENTEL\n    ecoAdjustments(currentVPD = this.vpd.current, ecoTarget = this.vpd.ecotarget) {\n        let action;\n        let vpdECOPercent;\n\n        if (currentVPD < ecoTarget[0]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[0]) / ecoTarget[0]) * 100).toFixed(2));\n            action = this.actions.Increased;\n        } else if (currentVPD > ecoTarget[1]) {\n            vpdECOPercent = parseFloat((((currentVPD - ecoTarget[1]) / ecoTarget[1]) * 100).toFixed(2));\n            action = this.actions.Reduced;\n        }\n\n        return {\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: currentVPD,\n            targetVPDMin: ecoTarget[0],\n            targetVPDMax: ecoTarget[1],\n            vpdDiffPercent: vpdECOPercent,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    // NIGHTHOLD VPD OUTPUT\n    inDontCareMode() {\n        let action = {\n            exhaust: \"maximal\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"maximal\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        // NEED TO TEST ON LIGHT OFF PHASE\n        node.warn(`Ignore VPD on NightTime run minimal Actions`);\n        return {\n            tentName: this.tentName,\n            tentMode: \"I DONT CARE MODE\",\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity\n            },\n            actions: action\n        };\n    }\n\n    /// DISABELD \n    disabledMode() {\n        node.log(\"Disabled mode active\");\n        let action = {\n            exhaust: \"Unchanged\",\n            humidifier: \"Unchanged\",\n            dehumidifier: \"Unchanged\",\n            heater: \"Unchanged\",\n            cooler: \"Unchanged\",\n            ventilation: \"Unchanged\",\n            light: \"Unchanged\",\n            co2: \"Unchanged\",\n            climate: {\n                cool: \"Unchanged\",\n                dry: \"Unchanged\",\n                heat: \"Unchanged\",\n            }\n\n        }\n        return {\n            TentName: this.tentName,\n            tentMode: this.tentMode,\n            actions: action,\n        };\n    }\n\n    /// ACTIONS ******************************\n    selectAction(context) {\n        let preparedDevices = []; // Speicher für Geräteaktionen\n        let actionData;\n        let limitAdjustments\n\n        // Prüfen, ob der Zustand seit der letzten Aktion unverändert ist\n        if (this.checkLastState()) {\n            this.needchange = false;\n            actionData = {\n                tentName: this.tentName,\n                tentMode: \"Unchanged\",\n                currentVPD: this.vpd.current,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n                Humidities: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity,\n                },\n                actions: this.actions.Unchanged,\n                deviceActions: preparedDevices,\n            };\n        } else {\n            this.needchange = true;\n        }\n\n\n        // Modusabhängige Logik\n        if (this.needchange) {\n            switch (this.tentMode) {\n                case \"VPD Perfection\":\n                    actionData = this.perfectionAdjustments(\n                        this.vpd.current,\n                        this.vpd.perfection,\n                        this.vpd.perfectTolerance\n                    );\n                    break;\n                case \"IN-VPD-Range\":\n                    actionData = this.rangeAdjustments(\n                        this.vpd.current,\n                        this.vpd.range,\n                        this.vpd.rangeTolerance\n                    );\n                    break;\n                case \"Targeted VPD\":\n                    actionData = this.targetAdjustment(\n                        this.vpd.current,\n                        this.vpd.targeted,\n                        this.vpd.targetedTolerance\n                    );\n                    break;\n                case \"ECO-VPD\":\n                    actionData = this.ecoAdjustments(\n                        this.vpd.current,\n                        this.vpd.ecotarget,\n                    );\n                    break;\n                case \"Drying\":\n                    actionData = this.dryAdjustments();\n                    break;\n                case \"Disabled\":\n                    actionData = this.disabledMode();\n                    break;\n\n                default:\n                    throw new Error(\"Unknown mode: \" + this.tentMode);\n            }\n\n            if (this.isPlantDay.lightOn === false && this.isPlantDay.nightVPDHold === false) {\n                actionData = this.inDontCareMode()\n            }\n\n        }\n\n        if (this.needchange) {\n            limitAdjustments = this.checkLimits();\n        }\n        // Vorzeitige Anpassungen\n\n        // Kombiniere alle Aktionen\n        const finalActions = {\n            ...actionData.actions || null,\n            ...limitAdjustments || null,\n        };\n        //let absolutActions = this.evaluateDeviceEnvironment(finalActions)\n\n        this.devices.forEach((device) => {\n\n            // Prüfen, ob das Gerät korrekt initialisiert wurde\n            if (device.switches.length === 0) return\n            if (device && typeof device.prepareAction === \"function\") {\n                if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n\n                device = device.prepareAction(finalActions);\n\n                let actions = device.runAction(context)\n\n                //node.warn(`FinalAction: ${JSON.stringify(actions, null, 2)}`);\n\n                preparedDevices.push(actions)\n                //preparedDevices.push(device)\n            } else {\n                // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n            }\n        });\n\n\n        // Aktion speichern\n        this.dataSetter({\n            ...actionData || null,\n            actions: finalActions || null,\n            devices: this.devices || null,\n            deviceActions: preparedDevices || null,\n        });\n\n        // Rückgabe der Aktion mit den angepassten Geräten\n        return {\n            ...actionData || null,\n            actions: finalActions || null,\n            devices: this.devices || null,\n            deviceActions: preparedDevices || null,\n        };\n    }\n\n    checkLimits() {\n        let adjustments = {};\n\n        // Sicherstellen, dass der Modus nicht \"Drying\" ist\n        if (this.tentMode === \"Drying\") return;\n\n        // Keine Änderungen erforderlich, wenn kein Bedarf besteht\n        if (!this.needchange) return adjustments;\n\n        // Dynamische Gewichtung basierend auf Plant Stage\n        let humidityWeight, temperatureWeight;\n\n        if (this.controls.ownWeights) {\n            humidityWeight = this.controls.weights.hum || 1.0;\n            temperatureWeight = this.controls.weights.temp || 1.0;\n        } else {\n            if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                humidityWeight = 1.25; // Feuchtigkeit ist wichtiger\n                temperatureWeight = 1.0; // Temperatur ist weniger wichtig\n            } else {\n                humidityWeight = 1.0; // Standardgewichtung\n                temperatureWeight = 1.0;\n            }\n        }\n\n        // Initialisierung von Abweichungen\n        let tempDeviation = 0;\n        let humDeviation = 0;\n\n        // Abweichungen nur berechnen, wenn außerhalb der Grenzen\n        if (this.tentData.temperature > this.tentData.maxTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n        } else if (this.tentData.temperature < this.tentData.minTemp) {\n            tempDeviation = (this.tentData.temperature - this.tentData.minTemp) * temperatureWeight;\n        }\n\n        if (this.tentData.humidity > this.tentData.maxHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n        } else if (this.tentData.humidity < this.tentData.minHumidity) {\n            humDeviation = (this.tentData.humidity - this.tentData.minHumidity) * humidityWeight;\n        }\n\n        // **Initialisiere climate innerhalb von adjustments**\n        adjustments.climate = {\n            cool: \"unchanged\",\n            heat: \"unchanged\",\n            dry: \"unchanged\",\n        };\n\n        // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n        if (tempDeviation > 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n            // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation > 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n            // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation > 0) {\n            adjustments.dehumidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n            // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n        } else if (tempDeviation < 0 && humDeviation < 0) {\n            adjustments.humidifier = \"increased\";\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.climate.heat = \"increased\";\n            adjustments.ventilation = \"reduced\";\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n            }\n            node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n        }\n\n        // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp + 5) {\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.cooler = \"increased\";\n            adjustments.climate.cool = \"increased\";\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n        if (this.tentData.temperature < this.tentData.minTemp - 5) {\n            adjustments.heater = \"increased\";\n            adjustments.exhaust = \"reduced\";\n            adjustments.ventilation = \"increased\";\n            adjustments.climate.heat = \"increased\";\n            if (this.isPlantDay.lightOn){\n                adjustments.light = \"maximum\"\n            }\n            node.warn(`${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n        }\n\n        // **7. Lichtsteuerung basierend auf Temperatur**\n        if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n            adjustments.light = \"reduced\";\n            node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n        }\n\n        // **8. CO₂-Management**\n        if (this.tentData.co2Level < 400) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"increased\";\n                adjustments.exhaust = \"minimum\";\n                node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n            }\n\n        } else if (this.tentData.co2Level > 1200) {\n            if (this.isPlantDay.lightOn) {\n                adjustments.light = \"increased\"\n                adjustments.co2 = \"reduced\";\n                adjustments.exhaust = \"increased\";\n                node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n            }\n            adjustments.co2 = \"reduced\";\n            adjustments.exhaust = \"increased\";\n            node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n        }\n\n        // **9. Taupunkt- und Kondensationsschutz**\n        if (this.tentData.dewpoint >= this.tentData.temperature - 1) {\n            adjustments.exhaust = \"increased\";\n            adjustments.climate.dry = \"increased\";\n            adjustments.ventilation = \"increased\";\n            node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n        }\n\n        // **10. Nachtmodus (Licht aus, maximale Abluft)**\n        if (!this.isPlantDay.lightOn) {\n            adjustments.light = \"off\";\n            adjustments.exhaust = \"maximum\";\n            adjustments.ventilation = \"increased\";\n            adjustments.co2 = \"minimum\";\n            node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n        }\n\n        return adjustments;\n    }\n\n    // Experimentel ( use outsite and ambient data)\n    analyzeTrends() {\n        let trend = {\n            temperature: this.enviorment.outsiteTemp - this.enviorment.ambientTemp,\n            humidity: this.enviorment.outsiteHumidity - this.enviorment.ambientHumidity,\n        };\n\n        if (trend.temperature > 0) {\n            // Außentemperatur steigt -> Vorzeitig lüften\n            this.actionsIncreased.exhaust = \"preemptively increased\";\n        } else if (trend.temperature < 0) {\n            // Außentemperatur sinkt -> Lüftung reduzieren\n            this.actionsReduced.exhaust = \"preemptively reduced\";\n        }\n\n        if (trend.humidity > 0) {\n            // Außenfeuchtigkeit steigt -> Entfeuchter verstärken\n            this.actionsIncreased.dehumidifier = \"preemptively increased\";\n        } else if (trend.humidity < 0) {\n            // Außenfeuchtigkeit sinkt -> Befeuchter anpassen\n            this.actionsReduced.humidifier = \"preemptively reduced\";\n        }\n    }\n\n    // DATA SETTER FAKE DB ******************************\n    dataSetter(data) {\n        const time = new Date().toISOString();\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n        // Definiere eine Schwelle für Änderungen\n        const vpdThreshold = 0.005;\n\n        if (this.tentMode === \"Unchanged\" || this.tentMode === \"Disabled\" || this.tentMode === \"I DONT CARE MODE\") {\n            return;\n        }\n\n\n        // Filter für aktive oder relevante Geräte\n        // Filter für aktive oder relevante Geräte\n        const relevantDevices = this.devices.filter(\n            (device) => (device.switches.length > 0) || device.isRunning\n        );\n\n\n        // Erstelle das Datenobjekt\n        const enrichedData = {\n            time,\n            tentName: this.tentName,\n            tentMode: this.tentMode,\n            currentVPD: this.vpd.current,\n            targetVPDMin: this.vpd.range[0],\n            targetVPDMax: this.vpd.range[1],\n            vpdDiffPercent: data.vpdDiffPercent || 0,\n            Temps: {\n                Temperature: this.tentData.temperature,\n                MinTemperature: this.tentData.minTemp,\n                MaxTemperature: this.tentData.maxTemp,\n            },\n            Humditys: {\n                Humidity: this.tentData.humidity,\n                MinHumidity: this.tentData.minHumidity,\n                MaxHumidity: this.tentData.maxHumidity,\n            },\n            Dewpoint: this.tentData.dewpoint,\n            actions: data.actions,\n            Environment: {\n                ambientTemp: this.enviorment.ambientTemp,\n                ambientHumidity: this.enviorment.ambientHumidity,\n                ambientDewpoint: this.enviorment.ambientDewpoint,\n            },\n            Outside: {\n                outsiteTemp: this.enviorment.outsiteTemp,\n                outsiteHumidity: this.enviorment.outsiteHumidity,\n                outsiteDewpoint: this.enviorment.outsiteDewpoint,\n            },\n            devices: relevantDevices.map((device) => ({\n                name: device.name,\n                deviceType: device.deviceType,\n                isRunning: device.isRunning,\n                needChange: device.needChange,\n                action: device.action,\n                hasDuty: device.hasDuty,\n                dutyCycle: device.dutyCycle,\n                switches: device.switches,\n                sensors: device.sensors,\n                data: device.data,\n            })),\n            deviceActions: data.deviceActions\n        };\n\n        // Bedingung für signifikante Änderungen\n        const significantChange =\n            !lastAction ||\n            Math.abs(lastAction.currentVPD - this.vpd.current) > vpdThreshold ||\n            lastAction.Temps.Temperature !== enrichedData.Temps.Temperature ||\n            lastAction.Humditys.Humidity !== enrichedData.Humditys.Humidity ||\n            lastAction.Dewpoint !== enrichedData.Dewpoint;\n\n        if (significantChange) {\n            this.previousActions.push(enrichedData);\n            node.log(`Neue Aktion gespeichert:\", ${enrichedData}`);\n        } else {\n            node.log(\"Änderung nicht signifikant - Keine Aktion gespeichert.\");\n        }\n\n        // Begrenze die Anzahl der gespeicherten Aktionen\n        if (this.previousActions.length > 250) {\n            this.previousActions = this.previousActions.slice(-250);\n        }\n    }\n\n    // Check if action is needed to chagnes in vpd \n    checkLastState() {\n        if (this.previousActions.length === 0) return false;\n\n        const lastAction = this.previousActions[this.previousActions.length - 1];\n\n        // Prüfen, ob der aktuelle Zustand identisch mit dem letzten gespeicherten Zustand ist\n        if (lastAction && lastAction.currentVPD === this.vpd.current) {\n            node.log(\"VPD hat sich nicht geändert. Keine Aktion notwendig.\");\n            return true;\n        }\n\n        return false;\n    }\n}\n\nclass Device {\n    constructor(deviceName, deviceType = \"generic\") {\n        this.name = deviceName;\n        this.deviceType = deviceType;\n        this.isRunning = false;\n        this.isLocked = false\n        this.lockedFor = \"\"\n        this.needChange = false\n        this.inRoomName = \"\"\n        this.isfromAmbient = false\n        this.action = \"\"\n        this.switches = [];\n        this.sensors = [];\n        this.data = {};\n\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n    }\n\n    setFromtent(roomName) {\n        if (roomName != this.inRoomName) {\n            this.inRoomName = roomName\n        }\n    }\n\n    identifyIfFromAmbient() {\n        if (typeof this.inRoomName === \"string\" &&\n            (this.inRoomName.toLowerCase().includes(\"ambient\"))) {\n            this.isfromAmbient = true;\n        } else {\n            this.isfromAmbient = false;\n        }\n    }\n\n    identifySwitchesAndSensors() {\n        if (!this.data || typeof this.data !== \"object\") return;\n\n        const keys = Object.keys(this.data);\n        this.switches = keys.filter((key) =>\n            key.startsWith(\"switch.\") || key.startsWith(\"light.\") || key.startsWith(\"fan.\") || key.startsWith(\"climate.\")\n        );\n        this.sensors = keys.filter((key) =>\n            key.startsWith(\"sensor.\") || key.startsWith(\"select.\") || key.startsWith(\"number.\") || key.startsWith(\"text.\") || key.startsWith(\"time.\")\n        );\n    }\n\n    updateIsRunningState() {\n        // Standardmäßig ist das Gerät nicht laufend\n        this.isRunning = false;\n\n        if (!this.data || typeof this.data !== \"object\") {\n            return;\n        }\n\n        // 1. Prüfen, ob ein Fan eingeschaltet ist\n        const fanKeys = Object.keys(this.data).filter((key) => key.startsWith(\"fan.\"));\n        if (fanKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }else{\n            this.isRunning = false;\n        }\n\n        // 2. Prüfen, ob ein Light eingeschaltet ist\n        const lightKeys = Object.keys(this.data).filter((key) => key.startsWith(\"light.\"));\n        if (lightKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }else{\n            this.isRunning = false;\n        }\n\n        // 3. Prüfen, ob eine Klimaanlage eingeschaltet ist\n        const climateKeys = Object.keys(this.data).filter((key) => key.startsWith(\"climate.\"));\n        if (climateKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }else{\n            this.isRunning = false;\n        }\n\n        // 4. Prüfung Switches\n        const switchKeys = Object.keys(this.data).filter((key) => key.startsWith(\"switch.\"));\n        if (switchKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }else{\n            this.isRunning = false;\n        }\n        \n        // 5. Prüfung Humdifier\n        const humhKeys = Object.keys(this.data).filter((key) => key.startsWith(\"humidifier.\"));\n        if (humhKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }else{\n            this.isRunning = false;\n        }\n\n        // 5. Prüfen, ob ein gültiger Duty-Cycle-Wert vorhanden ist\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"duty_cycle\") ||\n            key.toLowerCase().includes(\"dutycycle\") ||\n            key.toLowerCase().includes(\"duty\") ||\n            key.toLowerCase().includes(\"number.\") ||\n            key.toLowerCase().includes(\"voltage\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue) && dutyCycleValue > 0) {\n                //this.isRunning = true;\n                return;\n            }\n        }\n\n        // 6. Prüfen, ob Sensor-Werte anzeigen, dass das Gerät läuft\n        if (Array.isArray(this.sensors) && this.sensors.length > 0) {\n            const sensorKey = this.sensors.find((key) =>\n                key.toLowerCase().includes(\"duty_cycle\") || key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty\")\n            );\n            if (sensorKey && parseInt(this.data[sensorKey], 10) > 0) {\n                //this.isRunning = true;\n                return;\n            }\n        }\n    }\n\n    prepareAction(finalActions) {\n        if (finalActions.hasOwnProperty(this.deviceType)) {\n            const actionValue = finalActions[this.deviceType];\n\n            // Spezielles Verhalten für \"light\"-Geräte\n            if (this.deviceType === \"light\") {\n                if (actionValue !== \"unchanged\"){\n                    this.needChange = true;\n                    this.action = actionValue;\n                }else{\n                    this.needChange = false;\n                    this.action = actionValue;\n                }\n\n\n                // Sonderfall für \"climate\" Geräte\n            } else if (this.deviceType === \"climate\") {\n                //node.warn(`IN Climate Aciton Value: ${JSON.stringify(finalActions, actionValue)}`);\n                if (finalActions.climate && typeof finalActions.climate === \"object\") {\n                    for (const [mode, action] of Object.entries(finalActions.climate)) {\n                        if (action !== \"unchanged\") {\n                            this.needChange = true;\n                            this.action = { mode, action }; // Speichere den gefundenen Modus und die Aktion\n                            break; // Beende die Schleife, sobald der erste gültige Wert gefunden wurde\n                        }\n                    }\n                } else {\n                    this.action = \"unchanged\"; // Standardwert, falls keine gültigen Climate-Aktionen vorhanden sind\n                }\n            } else {\n                // Standard-Verhalten für andere Gerätetypen\n                if (actionValue === \"unchanged\") {\n                    this.needChange = false;\n                    this.action = actionValue;\n                } else if (\n                    [\"maximum\", \"reduced\", \"increased\", \"minimum\", \"on\", \"off\"].includes(actionValue)\n                ) {\n                    this.needChange = true;\n                    this.action = actionValue;\n                }\n            }\n        } else {\n            // Falls keine Aktion definiert ist, logge Warnung\n            node.warn(`No actions defined for device type: ${this.deviceType}`);\n            this.needChange = false;\n            this.action = \"unchanged\";\n        }\n\n        // Debugging-Ausgabe zur Überprüfung der finalen Aktionen\n        //node.warn(`Prepared action for ${this.name}: ${JSON.stringify(this.action, null, 2)}, needChange: ${this.needChange}`);\n\n        return this;\n    }\n\n    evalAction() {\n        // Generische Prüfungen für alle Geräte\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        // Falls keine Änderung notwendig ist, abbrechen\n        if (this.needChange === false) return;\n        if (!this.evalAction()) {\n            return { Device: `${this.switches[0]}`, Action: \"noChangesNeeded\", State: \"unchanged\" };\n        }\n\n        //node.warn(`Running Action for ${this.name} in ${this.inRoomName} `);\n        //node.warn(`Action State:${this.action}`);\n\n\n        // Aktion: increased\n        if (this.action === \"increased\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(50);\n                        node.warn(`${this.name} Duty-Cycle wurde auf 50% gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle + 5}% erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle + 5); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n\n            // Aktion: reduced\n        } else if (this.action === \"reduced\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät aus, falls es läuft\n                if (this.isRunning) {\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return this.turnOFF();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready OFF\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (this.dutyCycle === 5) {\n                    node.warn(`${this.name} ist auf Minimum gestellt in ${this.inRoomName} .`);\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return { entity_id: this.switches[0], action: \"Minium Reached\" }\n                } else {\n                    node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle - 5}% reduziert in ${this.inRoomName} .`);\n                    return this.changeDuty(this.dutyCycle - 5); // Beispiel: Reduziere Duty-Cycle um 10%\n                }\n            }\n\n            // Aktion: unchanged\n        } else if (this.action === \"maximum\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(100);\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX %gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX % erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(100); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n        } else if (this.action === \"minimum\") {\n\n        } else if (this.action === \"unchanged\") {\n            //node.warn(`${this.name} bleibt unverändert.`);\n            return { entity_id: this.switches[0], action: \"UNCHANGED\" }\n            // Fehlerfall\n        } else {\n            node.warn(`Etwas Ungewöhnliches ist passiert: ${this.name} hat eine unbekannte Aktion. Bitte Support kontaktieren.`);\n\n        }\n    }\n\n    turnOFF() {\n        let enitiy = this.switches[0]\n        if (this.isRunning === true) {\n            this.isRunning = false\n            return { \"entity_id\": enitiy, \"action\": \"off\" }\n        }\n\n    }\n\n    turnON() {\n        let enitiy = this.switches[0]\n        if (this.isRunning == false) {\n            this.isRunning = true\n            return { \"entity_id\": enitiy, \"action\": \"on\" }\n        }\n\n    }\n}\n\nclass Exhaust extends Device {\n    constructor(name, dutyCycle = 0) {\n        super(name, \"exhaust\");\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        this.minDuty = 10;\n        this.maxDuty = 95;\n        this.hasDuty = false;\n        this.isRuckEC = false;\n\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyIfRuckEC(); // RuckEC zuerst prüfen\n        this.findDutyCycle();    // Danach Duty Cycle suchen\n    }\n\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    identifyIfRuckEC() {\n        this.isRuckEC = this.name.toLowerCase().includes(\"ruck\");\n        if (this.isRuckEC) {\n            this.hasDuty = true\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten vorhanden.`);\n            this.dutyCycle = this.minDuty;\n            this.hasDuty = false;\n            return;\n        }\n\n        // Suche nach einem Schlüssel, der dutycycle oder duty_cycle enthält\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n\n            // Parse den Wert des gefundenen dutycycle-Keys\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                this.hasDuty = true;\n            } else {\n                this.dutyCycle = this.minDuty;\n                this.hasDuty = false;\n            }\n        } else {\n            this.dutyCycle = this.minDuty;\n            this.hasDuty = false;\n        }\n    }\n\n\n\n    setDutyCycle(dutyCycle) {\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        node.warn(`${this.name}: Duty Cycle auf ${this.dutyCycle}% gesetzt.`);\n        return this.dutyCycle;\n    }\n\n    changeDuty(duty) {\n        const newDuty = this.clampDutyCycle(duty);\n        if (this.switches?.[0]) {\n            const switchId = this.switches[0];\n            if(newDuty !== this.dutyCycle){\n                const clampedDuty = this.clampDutyCycle(duty);\n                this.dutyCycle = clampedDuty;\n            }else{\n                return { entity_id: switchId, action: \"SameDuty\", dutycycle: newDuty };\n            }\n\n            node.warn(`${this.name}: Duty Cycle ${this.dutyCycle} an Abluft ${switchId} gesendet.`);\n            return { entity_id: switchId, action: \"dutycycle\", dutycycle: newDuty };\n        } else {\n            return { error: \"No switch available\" };\n        }\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { Exhaust: `${this.name}`, Action: \"NoChangeNeeded\" };\n        }\n\n        const switchId = this.switches?.[0];\n        if (!switchId) {\n            return { error: \"No switch available\" };\n        }\n\n        switch (this.action) {\n            case \"maximum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.maxDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"minimum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.minDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"increased\":\n                if (this.hasDuty) {\n                    const increasedDuty = Math.min(this.dutyCycle + 5, this.maxDuty);\n                    return this.changeDuty(increasedDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"reduced\":\n                if (this.hasDuty) {\n                    const reducedDuty = Math.max(this.dutyCycle - 5, this.minDuty);\n                    return this.changeDuty(reducedDuty);\n                } else {\n                    return this.turnOFF(switchId);\n                }\n\n\n            case \"on\":\n                return this.turnON(switchId);\n\n            case \"off\":\n                return this.turnOFF(switchId);\n\n            case \"unchanged\":\n                return { entity_id: switchId, action: \"UNCHANGED\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Exhaust: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Lüfter eingeschaltet.`);\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Lüfter ausgeschaltet.`);\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n}\n\nclass Ventilation extends Device {\n    constructor(name) {\n        super(name, \"ventilation\");\n        this.dutyCycle = 50; // Startwert 50%\n        this.dutyMin = 90;   // Minimalwert\n        this.dutyMax = 100;  // Maximalwert\n        this.hasDuty = true; // Immer Duty Cycle verfügbar\n        this.isTasmota = false;\n        this.isInitialized = false; // Verhindert doppelte Initialisierung\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n\n        this.identifyIfTasmota(); // Prüfe, ob es ein Tasmota-Gerät ist\n\n        if (this.isTasmota) {\n            // Für Tasmota-Geräte initialisiere Duty Cycle und überspringe findDutyCycle\n            if (!this.isInitialized) {\n                this.initializeDutyCycle();\n                this.isInitialized = true;\n            }\n            return;\n        }\n\n        // Für Nicht-Tasmota-Geräte den Duty Cycle aus den Daten suchen\n        if (!this.isInitialized) {\n            this.initializeDutyCycle();\n            this.isInitialized = true;\n        } else {\n            this.findDutyCycle();\n        }\n    }\n\n    initializeDutyCycle() {\n        if (this.isTasmota) return\n        node.warn(`${this.name}: Initialisiere Duty Cycle auf ${this.dutyCycle}%.`);\n        this.dutyCycle = this.dutyMin; // Initialisiere auf 50%\n    }\n\n    identifyIfTasmota() {\n        if (Array.isArray(this.switches)) {\n            this.isTasmota = this.switches.some(\n                (switchDevice) => typeof switchDevice === \"string\" && switchDevice.startsWith(\"light.\")\n            );\n\n            if (this.isTasmota && !this.isInitialized) {\n                node.warn(`${this.name}: Tasmota-Ventilation erkannt. Duty Cycle wird auf 50% gesetzt.`);\n                this.dutyCycle = this.dutyMin; // Tasmota-Geräte starten mit 50%\n                this.isInitialized = true;\n            }\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty_cycle\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                node.warn(`${this.name}: Duty Cycle aus Daten gesetzt auf ${this.dutyCycle}%.`);\n            }\n        } else {\n            node.warn(`${this.name}: Kein Duty Cycle-Schlüssel gefunden.`);\n        }\n    }\n\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.dutyMin, Math.min(this.dutyMax, dutyCycle));\n    }\n\n    setDutyCycle(dutyCycle) {\n        const clampedDuty = this.clampDutyCycle(dutyCycle);\n        this.dutyCycle = clampedDuty;\n        return clampedDuty;\n    }\n\n    changeDuty(switchId, duty) {\n        this.setDutyCycle(duty);\n        return { entity_id: switchId, action: \"dutycycle\", dutycycle: this.dutyCycle };\n    }\n\n    runAction(action) {\n        if (!this.needChange) return { Ventilation: `${this.switches[0]}`, Action: \"NoChangeNeeded\" };\n\n        const results = [];\n        const applyActionToSwitches = (actionCallback) => {\n            return this.switches.map((switchId) => {\n                const result = actionCallback(switchId);\n                results.push(result);\n                return result;\n            });\n        };\n\n        switch (this.action) {\n            case \"maximum\":\n                node.warn(`${this.name}: Duty Cycle auf Maximum (${this.dutyMax}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMax));\n\n            case \"minimum\":\n                node.warn(`${this.name}: Duty Cycle auf Minimum (${this.dutyMin}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMin));\n\n            case \"reduced\":\n                const reducedDuty = Math.max(this.dutyCycle - 5, this.dutyMin);\n                node.warn(`${this.name}: Duty Cycle reduziert auf ${reducedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, reducedDuty));\n\n            case \"increased\":\n                const increasedDuty = Math.min(this.dutyCycle + 5, this.dutyMax);\n                node.warn(`${this.name}: Duty Cycle erhöht auf ${increasedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, increasedDuty));\n\n            case \"on\":\n                return applyActionToSwitches((switchId) => this.turnON(switchId));\n\n            case \"off\":\n                return applyActionToSwitches((switchId) => this.turnOFF(switchId));\n\n            case \"unchanged\":\n                node.warn(`${this.name}: Keine Änderung erforderlich.`);\n                return applyActionToSwitches((switchId) => ({ entity_id: switchId, action: \"UNCHANGED\" }));\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Ventilation: `${this.switches[0]}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n}\n\nclass Climate extends Device {\n    constructor(name) {\n        super(name, \"climate\");\n        this.currentHAVOC = \"off\"; // Standardzustand\n        this.havocs = {\n            dry: \"dry\",\n            cool: \"cool\",\n            hot: \"hot\",\n            heat: \"heat\",\n            wind: \"wind\",\n            off: \"off\",\n        };\n        this.isRunning = false; // Status der Klimaanlage\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyCurrentHavoc();\n    }\n\n    identifyCurrentHavoc() {\n        const havocDevice = this.switches[0];\n        if (!havocDevice) {\n            console.warn(`${this.name}: Keine Switches definiert, um HAVOC zu identifizieren.`);\n            return;\n        }\n\n        const havocValue = this.data[havocDevice];\n\n        if (havocValue && Object.values(this.havocs).includes(havocValue)) {\n            this.currentHAVOC = havocValue;\n            console.warn(`${this.name}: HAVOC-Modus gesetzt auf \"${this.currentHAVOC}\".`);\n        } else {\n            console.warn(`${this.name}: Ungültiger HAVOC-Wert \"${havocValue}\", Standardwert \"off\" wird verwendet.`);\n        }\n    }\n\n    runAction() {\n        if (!this.needChange || !this.action || typeof this.action !== \"object\") {\n            console.warn(`${this.name}: Keine Änderungen erforderlich.`);\n            return null;\n        }\n\n        const { mode, action } = this.action;\n        const lowerMode = mode.toLowerCase(); // Konvertiere in Kleinbuchstaben\n        const validMode = this.havocs[lowerMode]; // Vergleiche mit `havocs` Mapping\n\n        console.warn(`Aktion empfangen: Mode = \"${mode}\", Action = \"${action}\", ValidMode = \"${validMode}\", CurrentHAVOC = \"${this.currentHAVOC}\"`);\n\n        // Prüfen, ob der Modus ungültig ist\n        if (!validMode) {\n            console.warn(`${this.name}: Ungültiger Modus \"${mode}\" erhalten. Standardwert \"off\" wird verwendet.`);\n            return { entity_id: this.switches[0], action: \"invalid_mode\", received_mode: mode };\n        }\n\n        // Prüfen, ob der Modus bereits läuft\n        if (this.isRunning && this.currentHAVOC.toLowerCase() === validMode) {\n            console.warn(`${this.name}: Keine Änderungen notwendig. Der Modus \"${validMode}\" ist bereits aktiv.`);\n            return { entity_id: this.switches[0], action: \"AllReady_ON\", climate_mode: this.currentHAVOC };\n        }\n\n        if (action === \"off\") {\n            return this.turnOFF();\n        }\n\n        if (!this.isRunning) {\n            return this.turnON(validMode);\n        }\n\n        return this.changeMode(validMode);\n    }\n\n    turnON(mode) {\n        this.isRunning = true;\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_Running\", climate_mode: mode };\n        }\n\n    }\n\n    turnOFF() {\n        if (this.isRunning) {\n            const previousMode = this.currentHAVOC;\n\n            if (this.isRunning === true) {\n                this.isRunning = false;\n                this.currentHAVOC = \"off\";\n                return { entity_id: this.switches[0], action: \"off\", previous_mode: previousMode };\n            } else {\n                return { entity_id: this.switches[0], action: \"AllreadyOFF\", previous_mode: previousMode };\n            }\n        }\n        return { entity_id: this.switches[0], action: \"already_off\" };\n    }\n\n    changeMode(mode) {\n\n        if (this.currentHAVOC !== mode) {\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        } else {\n            return { entity_id: this.switches[0], action: \"AllReady_OFF\", climate_mode: mode };\n        }\n\n    }\n}\n\nclass Light extends Device {\n    constructor(name) {\n        super(name, \"light\");\n        this.hasDuty = false;\n        this.dutyCycle = null;\n        this.minDuty = 20;\n        this.maxDuty = 100;\n        this.lastSentDutyCycle = null;\n        this.voltage = 0.0;\n        this.sunriseMin = 20;\n        this.sunsetMin = 20;\n        this.stepSize = 1; // Schrittweite für Änderungen\n        this.sunRiseTime = \"\";\n        this.sunSetTime = \"\";\n        this.lightOnTime = \"\"; // Startzeit des Lichts\n        this.lightOffTime = \"\"; // Endzeit des Lichts\n        this.isScheduled = false; // Ob das Licht Zeitpläne berücksichtigt\n        this.controlOverVoltage = false;\n        this.controledOverOGB = true\n        this.worksWithCO2 = false;\n        this.currentPlantPhase = {\n            min: 0,\n            max: 0,\n        };\n        this.PlantStageMinMax = {\n            Germ: {\n                min: 20,\n                max: 30,\n            },\n            Veg: {\n                min: 20,\n                max: 50,\n            },\n            Flower: {\n                min: 70,\n                max: 100,\n            },\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.setCurrenPlantPhaseName(context);\n        this.findDutyCycle(); // Initialisiere den Duty-Cycle, falls vorhanden\n        this.setLightTimes(context);\n        this.setSunTimes(context.isPlantDay.sunRiseTimes, context.isPlantDay.sunSetTimes);\n    }\n\n    voltageFactorToDutyCycle(voltage) {\n        return Math.floor(voltage * 10);\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            console.log(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n    \n        const voltageKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n        );\n    \n        if (voltageKey) {\n            const voltageValue = parseFloat(this.data[voltageKey]);\n            if (!isNaN(voltageValue)) {\n                this.controlOverVoltage = true;\n                const calculatedDuty = this.voltageFactorToDutyCycle(voltageValue); // Voltage zu Duty umrechnen\n                this.dutyCycle = Math.max(this.minDuty, Math.min(this.maxDuty, calculatedDuty));\n                this.hasDuty = true;\n                console.log(`${this.name}: Duty-Cycle basierend auf Spannung (${voltageValue}V) berechnet: ${this.dutyCycle}`);\n            } else {\n                this.hasDuty = false;\n                console.log(`${this.name}: Keine gültige Spannung gefunden.`);\n            }\n        } else {\n            console.log(`${this.name}: Kein Voltage-Key gefunden.`);\n            this.hasDuty = false;\n        }\n    }\n    \n    setCurrenPlantPhaseName(context) {\n        if (!context) return;\n        if (context.plantStage !== this.currentPlantPhase) {\n            this.currentPlantPhase = context.plantStage;\n            this.setForPlantLightPhase();\n        }\n    }\n\n    setForPlantLightPhase() {\n        const phase = this.currentPlantPhase;\n        if (phase.includes(\"Germination\") || phase.includes(\"Clones\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Germ };\n        } else if (phase.includes(\"Veg\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Veg };\n        } else if (phase.includes(\"Flower\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Flower };\n        }\n        this.minDuty = this.currentPlantPhase.min;\n        this.maxDuty = this.currentPlantPhase.max;\n    }\n\n    setLightTimes(context) {\n        if (!context) return;\n        const { lightOnTime, lightOffTime } = context.isPlantDay || {};\n        this.lightOnTime = lightOnTime;\n        this.lightOffTime = lightOffTime;\n\n        if (this.lightOnTime && this.lightOffTime !== \"\") {\n            this.isScheduled = true;\n        }\n    }\n\n    setSunTimes(sunRiseTime, sunSetTime) {\n        if (this.hasDuty) {\n            if (sunRiseTime || sunSetTime !== \"\") {\n                this.sunRiseTime = sunRiseTime;\n                this.sunSetTime = sunSetTime;\n            }\n        } else {\n            return { ERROR: \"NoDuty\" }\n        }\n\n    }\n\n    parseTime(timeString) {\n        if (!timeString || typeof timeString !== \"string\") {\n            console.log(\"DEBUG: Invalid time string provided:\", timeString);\n            return 0; // Fallback auf Mitternacht\n        }\n\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return (hours * 3600) + (minutes * 60) + seconds;\n    }\n\n    checkforStartStop() {\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n        const startTime = this.parseTime(this.lightOnTime);\n        const endTime = this.parseTime(this.lightOffTime);\n    \n        let isLightOn;\n    \n        if (endTime < startTime) {\n            // Handling when light off time is past midnight\n            isLightOn = currentSeconds >= startTime || currentSeconds <= endTime;\n        } else {\n            isLightOn = currentSeconds >= startTime && currentSeconds <= endTime;\n        }\n    \n        console.log(\"LIGHTONSTATE:\", isLightOn);\n    \n        if (isLightOn !== this.isRunning) {\n            this.action = isLightOn ? \"on\" : \"off\";\n            console.log(\"ON/OFF ACTION\", this.action);\n            return isLightOn ? this.turnON() : this.turnOFF();\n        }\n    }\n    \n    checkforPhase() {\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        const lightOnSeconds = this.parseTime(this.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.lightOffTime);\n        const sunRiseSeconds = this.parseTime(this.sunRiseTime); // Dauer des Sonnenaufgangs\n        const sunSetSeconds = this.parseTime(this.sunSetTime);   // Dauer des Sonnenuntergangs\n        const sunriseEndSeconds = lightOnSeconds + sunRiseSeconds; // Endzeit Sunrise\n        const sunsetStartSeconds = lightOffSeconds - sunSetSeconds; // Startzeit Sunset\n\n        // **Sonnenaufgang (Sunrise Phase)**\n        const isSunriseActive = currentSeconds >= lightOnSeconds && currentSeconds < sunriseEndSeconds;\n        if (isSunriseActive) {\n            const sunriseDuration = sunRiseSeconds; // Gesamtdauer der Sunrise-Phase\n            const elapsedSunrise = currentSeconds - lightOnSeconds; // Verstrichene Zeit\n            const dutyIncrement = (elapsedSunrise / sunriseDuration) * (this.currentPlantPhase.max - this.sunriseMin);\n            const newDuty = Math.min(this.currentPlantPhase.max, this.sunriseMin + dutyIncrement);\n\n            console.log(\"DEBUG: Sunrise Phase Active\");\n            console.log(`Elapsed Sunrise Time: ${elapsedSunrise}`);\n            console.log(`Sunrise Duration: ${sunriseDuration}`);\n            console.log(`Duty Increment: ${dutyIncrement}`);\n            console.log(`${this.name}: Sunrise - Increasing Duty to ${Math.floor(newDuty)}`);\n\n            if (this.dutyCycle !== Math.floor(newDuty)) {\n                // **Hier wird der neue DutyCycle berechnet und gesendet**\n                this.dutyCycle = Math.floor(newDuty);\n                return {\n                    entity_id: this.switches[0],\n                    action: \"setDutyCycle\",\n                    dutycycle: this.dutyCycle, // Neuer DutyCycle\n                };\n            }\n            return true; // Sunrise-Phase aktiv\n        }\n\n        // **Sonnenuntergang (Sunset Phase)**\n        const isSunsetActive = currentSeconds >= sunsetStartSeconds && currentSeconds < lightOffSeconds;\n        if (isSunsetActive) {\n            const sunsetDuration = sunSetSeconds; // Gesamtdauer der Sunset-Phase\n            const elapsedSunset = currentSeconds - sunsetStartSeconds; // Verstrichene Zeit\n            const dutyDecrement = (elapsedSunset / sunsetDuration) * (this.dutyCycle - this.sunsetMin);\n            const newDuty = Math.max(this.sunsetMin, this.dutyCycle - dutyDecrement);\n\n            console.log(\"DEBUG: Sunset Phase Active\");\n            console.log(`Elapsed Sunset Time: ${elapsedSunset}`);\n            console.log(`Sunset Duration: ${sunsetDuration}`);\n            console.log(`Duty Decrement: ${dutyDecrement}`);\n            console.log(`${this.name}: Sunset - Reducing Duty to ${Math.floor(newDuty)}`);\n\n            if (this.dutyCycle !== Math.floor(newDuty)) {\n                // **Hier wird der neue DutyCycle berechnet und gesendet**\n                this.dutyCycle = Math.floor(newDuty);\n                return {\n                    entity_id: this.switches[0],\n                    action: \"setDutyCycle\",\n                    dutycycle: this.dutyCycle, // Neuer DutyCycle\n                };\n            }\n            return true; // Sunset-Phase aktiv\n        }\n\n        console.log(\"DEBUG: No active Sunrise or Sunset phase.\");\n        return false; // Keine Phase aktiv\n    }\n\n\n    runAction(context) {\n        const actions = []; // Liste, die alle Aktionen sammelt\n\n        // 1. Prüfen auf Start/Stop\n        const startStopAction = this.checkforStartStop();\n        if (startStopAction) {\n            console.log(\"DEBUG: Start/Stop Action:\", startStopAction);\n            actions.push(startStopAction); // Die Start/Stop-Aktion zur Liste hinzufügen\n        }\n\n        // 2. Prüfen auf aktive Sunrise/Sunset-Phasen\n        const isInPhase = this.checkforPhase();\n        if (isInPhase) {\n            console.log(\"DEBUG: Sunrise or Sunset phase active.\");\n            actions.push({\n                entity_id: this.switches[0],\n                action: \"SunriseOrSunset\",\n                status: true,\n            });\n\n            // Sicherstellen, dass DutyCycle während der Phase gesetzt wird\n            const dutyAction = this.changeDuty(this.dutyCycle);\n            if (dutyAction && dutyAction.action !== \"NoChangeNeeded\") {\n                actions.push(dutyAction);\n            }\n        }\n\n        // 3. Verarbeiten der Aktionen, wenn keine Phase aktiv ist\n        if (!isInPhase) {\n            switch (this.action) {\n                case \"on\":\n                    const onAction = this.turnON();\n                    actions.push(onAction);\n                    break;\n\n                case \"off\":\n                    const offAction = this.turnOFF();\n                    actions.push(offAction);\n                    break;\n\n                case \"unchanged\":\n                    return { Light: `${this.switches[0]}`, Action: \"NoChange\", Status: this.isRunning };\n\n                case \"increased\":\n                    if (this.hasDuty) {\n                        const newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                        if (this.dutyCycle !== newDuty) {\n                            console.log(`${this.name}: Increasing DutyCycle to ${newDuty}.`);\n                            actions.push(this.changeDuty(newDuty));\n                        } else {\n                            console.log(`${this.name}: DutyCycle unchanged (${this.dutyCycle}).`);\n                        }\n                    }\n                    break;\n\n                case \"reduced\":\n                    if (this.hasDuty) {\n                        const newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                        if (this.dutyCycle !== newDuty) {\n                            console.log(`${this.name}: Reducing DutyCycle to ${newDuty}.`);\n                            actions.push(this.changeDuty(newDuty));\n                        } else {\n                            console.log(`${this.name}: DutyCycle unchanged (${this.dutyCycle}).`);\n                        }\n                    }\n                    break;\n\n                case \"maximum\":\n                    if (this.hasDuty) {\n                        if (this.dutyCycle !== this.maxDuty) {\n                            console.log(`${this.name}: Setting DutyCycle to maximum (${this.maxDuty}).`);\n                            actions.push(this.changeDuty(this.maxDuty));\n                        } else {\n                            console.log(`${this.name}: DutyCycle already at maximum (${this.maxDuty}).`);\n                        }\n                    }\n                    break;\n\n                case \"minimum\":\n                    if (this.hasDuty) {\n                        if (this.dutyCycle !== this.minDuty) {\n                            console.log(`${this.name}: Setting DutyCycle to minimum (${this.minDuty}).`);\n                            actions.push(this.changeDuty(this.minDuty));\n                        } else {\n                            console.log(`${this.name}: DutyCycle already at minimum (${this.minDuty}).`);\n                        }\n                    }\n                    break;\n\n                default:\n                    console.log(`${this.name}: Unknown action.`);\n                    actions.push({\n                        entity_id: this.switches[0] || \"unknown\",\n                        action: \"UnknownAction\",\n                        status: this.isRunning,\n                    });\n            }\n        }\n\n        // 4. Sicherstellen, dass keine wiederholten DutyCycle- oder Voltage-Werte gesendet werden\n        const filteredActions = actions.filter((action) => {\n            if (action.action === \"setVoltage\") {\n                const isSameDutyCycle = action.dutycycle === this.dutyCycle;\n                const isSameVoltage = action.voltage === this.voltage;\n                if (isSameDutyCycle && isSameVoltage) {\n                    console.log(`${this.name}: Skipping redundant setVoltage action.`);\n                    return false; // Überspringen, wenn Werte gleich sind\n                }\n            }\n            return true; // Alle anderen Aktionen bleiben erhalten\n        });\n\n        // 5. Sicherstellen, dass mindestens eine Aktion zurückgegeben wird\n        if (filteredActions.length === 0) {\n            filteredActions.push({\n                entity_id: this.switches[0] || \"unknown\",\n                action: \"NoActionNeeded\",\n                status: this.isRunning,\n            });\n        }\n\n        return filteredActions;\n    }\n\n    \n    changeDuty(newDuty) {\n        if (!this.hasDuty) {\n            return { entity_id: this.switches[0], action: \"NoDutyCycle\" };\n        }\n\n        const clampedDuty = Math.max(this.minDuty, Math.min(this.maxDuty, newDuty));\n        const newVoltage = parseFloat((clampedDuty / 10).toFixed(1)); // Voltage ist Faktor 10 kleiner als DutyCycle\n\n        console.log(`DEBUG: Current DutyCycle: ${this.dutyCycle}, New DutyCycle: ${clampedDuty}`);\n        console.log(`DEBUG: Current Voltage: ${this.voltage}, New Voltage: ${newVoltage}`);\n\n        // Prüfen, ob der neue Duty-Cycle gesendet werden muss\n        if (this.lastSentDutyCycle === clampedDuty && this.voltage === newVoltage) {\n            console.log(`${this.name}: Duty-Cycle und Voltage unverändert, keine Aktion notwendig.`);\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n\n        // Aktualisiere den aktuellen und den zuletzt gesendeten Duty-Cycle\n        this.dutyCycle = clampedDuty;\n        this.voltage = newVoltage;\n        this.lastSentDutyCycle = clampedDuty;\n\n        if (this.controlOverVoltage) {\n            const voltageKey = this.sensors.find((key) =>\n                key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n            );\n\n            if (!voltageKey) {\n                console.log(`${this.name}: Kein Voltage-Key in sensors gefunden.`);\n                return { entity_id: null, action: \"NoVoltageKey\" };\n            }\n\n            console.log(`${this.name}: Voltage-Wert gesendet: ${newVoltage} an ${voltageKey}`);\n            return { entity_id: voltageKey, action: \"number\", value: newVoltage };\n        }\n\n        console.log(`${this.name}: Duty-Cycle geändert auf ${clampedDuty}%, Voltage: ${this.voltage}V.`);\n        return { entity_id: this.switches[0], action: \"dutycycle\", dutycycle: clampedDuty };\n    }\n    \n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            console.log(`${this.name}: Gerät wurde ausgeschaltet.`);\n            return { entity_id: entity, action: \"off\" };\n        } else {\n            console.log(`${this.name}: Gerät ist bereits ausgeschaltet.`);\n            return { entity_id: entity, action: \"AlreadyOFF\" };\n        }\n    }\n    \n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            console.log(`${this.name}: Gerät wurde eingeschaltet.`);\n            return { entity_id: entity, action: \"on\" };\n        } else {\n            console.log(`${this.name}: Gerät ist bereits eingeschaltet.`);\n            return { entity_id: entity, action: \"AlreadyON\" };\n        }\n    }\n    \n    \n    \n    \n}\n\nclass Light2 extends Device {\n    constructor(name) {\n        super(name, \"light\");\n        this.hasDuty = false;\n        this.dutyCycle = null;\n        this.minDuty = 20;\n        this.maxDuty = 100;\n        this.voltage = 0.0;\n        this.sunriseMin = 20;\n        this.sunsetMin = 20;\n        this.stepSize = 1; // Schrittweite für Änderungen\n        this.sunRiseTime = \"\";\n        this.sunSetTime = \"\";\n        this.lightOnTime = \"\"; // Startzeit des Lichts\n        this.lightOffTime = \"\"; // Endzeit des Lichts\n        this.isScheduled = false; // Ob das Licht Zeitpläne berücksichtigt\n        this.controlOverVoltage = false;\n        this.controledOverOGB = true\n        this.worksWithCO2 = false;\n        this.currentPlantPhase = {\n            min: 0,\n            max: 0,\n        };\n        this.PlantStageMinMax = {\n            Germ: {\n                min: 20,\n                max: 30,\n            },\n            Veg: {\n                min: 20,\n                max: 50,\n            },\n            Flower: {\n                min: 70,\n                max: 100,\n            },\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.setCurrenPlantPhaseName(context);\n        this.findDutyCycle(); // Initialisiere den Duty-Cycle, falls vorhanden\n        this.setLightTimes(context);\n        this.setSunTimes(context.isPlantDay.sunRiseTimes, context.isPlantDay.sunSetTimes);\n    }\n\n    voltageFactorToDutyCycle(voltage) {\n        return Math.floor(voltage * 10);\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        // Prüfe, ob die Pflanzenphase bereits definiert ist\n        if (this.currentPlantPhase.min !== 0 || this.currentPlantPhase.max !== 0) {\n            this.minDuty = this.currentPlantPhase.min;\n            this.maxDuty = this.currentPlantPhase.max;\n            //node.warn(`${this.name}: Duty-Cycle wird basierend auf der Pflanzenphase gesetzt. Min: ${this.minDuty}, Max: ${this.maxDuty}`);\n        }\n\n        const voltageKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n        );\n\n        if (voltageKey) {\n            const voltageValue = parseFloat(this.data[voltageKey]);\n            if (!isNaN(voltageValue)) {\n                this.controlOverVoltage = true;\n                const calculatedDuty = this.voltageFactorToDutyCycle(voltageValue);\n                this.dutyCycle = Math.max(this.minDuty, Math.min(this.maxDuty, calculatedDuty));\n                this.hasDuty = true;\n                node.warn(`${this.name}: Duty-Cycle basierend auf Spannung berechnet: ${this.dutyCycle}`);\n            } else {\n                this.hasDuty = false;\n            }\n        } else {\n            const dutyCycleKey = Object.keys(this.data).find((key) =>\n                [\"dutycycle\", \"number.\"].some((term) => key.toLowerCase().includes(term))\n            );\n\n            if (dutyCycleKey) {\n                const dutyCycleValue = parseFloat(this.data[dutyCycleKey]);\n                if (!isNaN(dutyCycleValue)) {\n                    const clampedValue = Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycleValue));\n                    this.dutyCycle = clampedValue;\n                    this.hasDuty = true;\n                    node.warn(`${this.name}: Duty-Cycle aus Daten berechnet: ${this.dutyCycle}`);\n                } else {\n                    this.hasDuty = false;\n                }\n            } else {\n                this.hasDuty = false;\n            }\n        }\n    }\n\n    setCurrenPlantPhaseName(context) {\n        if (!context) return;\n        if (context.plantStage !== this.currentPlantPhase) {\n            this.currentPlantPhase = context.plantStage;\n            this.setForPlantLightPhase();\n        }\n    }\n\n    setForPlantLightPhase() {\n        const phase = this.currentPlantPhase;\n        if (phase.includes(\"Germination\") || phase.includes(\"Clones\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Germ };\n        } else if (phase.includes(\"Veg\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Veg };\n        } else if (phase.includes(\"Flower\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Flower };\n        }\n        this.minDuty = this.currentPlantPhase.min;\n        this.maxDuty = this.currentPlantPhase.max;\n    }\n\n    setLightTimes(context) {\n        if (!context) return;\n        const { lightOnTime, lightOffTime } = context.isPlantDay || {};\n        this.lightOnTime = lightOnTime;\n        this.lightOffTime = lightOffTime;\n\n        if (this.lightOnTime && this.lightOffTime !== \"\") {\n            this.isScheduled = true;\n        }\n    }\n\n    setSunTimes(sunRiseTime, sunSetTime) {\n        if (this.hasDuty) {\n            if (sunRiseTime || sunSetTime !== \"\") {\n                this.sunRiseTime = sunRiseTime;\n                this.sunSetTime = sunSetTime;\n            }\n        } else {\n            return { ERROR: \"NoDuty\" }\n        }\n\n    }\n\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    checkforStartStop(){\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n        const startTime = this.parseTime(this.lightOnTime);\n        const endTime = this.parseTime(this.lightOffTime);\n\n        let isLightOn;\n        if (endTime < startTime) {\n            isLightOn = currentSeconds >= startTime || currentSeconds <= endTime;\n        } else {\n            isLightOn = currentSeconds >= startTime && currentSeconds <= endTime;\n        }\n\n        if (isLightOn !== this.isRunning) {\n            this.action = isLightOn ? \"on\" : \"off\";\n        }\n\n    }\n\n    checkforPhase() {\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        const sunRiseSeconds = this.parseTime(this.sunRiseTime);\n        const sunSetSeconds = this.parseTime(this.sunSetTime);\n\n        // Prüfe, ob die aktuelle Zeit innerhalb des Sonnenzeitfensters liegt\n        if (currentSeconds >= sunRiseSeconds && currentSeconds < sunSetSeconds) {\n            const sunriseDuration = sunSetSeconds - sunRiseSeconds;\n            const elapsed = currentSeconds - sunRiseSeconds;\n\n            // Berechne den Duty-Inkrement basierend auf der verstrichenen Zeit\n            const dutyIncrement = (elapsed / sunriseDuration) * (this.maxDuty - this.sunriseMin);\n            const newDuty = Math.min(this.maxDuty, this.sunriseMin + dutyIncrement);\n            node.warn(`${this.inRoomName} Sonnenuntergang New Duty ${newDuty}`)\n            // Aktualisiere den Duty-Cycle entsprechend\n            this.changeDuty(newDuty);\n        } else if (currentSeconds >= sunSetSeconds || currentSeconds < sunRiseSeconds) {\n            const sunsetDuration = (24 * 3600 - sunSetSeconds) + sunRiseSeconds;\n            const elapsed = currentSeconds >= sunSetSeconds\n                ? currentSeconds - sunSetSeconds\n                : 24 * 3600 - sunSetSeconds + currentSeconds;\n\n            // Berechne den Duty-Decrement basierend auf der verstrichenen Zeit\n            const dutyDecrement = (elapsed / sunsetDuration) * (this.maxDuty - this.sunsetMin);\n            const newDuty = Math.max(this.sunsetMin, this.maxDuty - dutyDecrement);\n\n            // Aktualisiere den Duty-Cycle entsprechend\n            node.warn(`${this.inRoomName} Sonnenaufgang New Duty ${newDuty}`)\n            this.changeDuty(newDuty);\n        } else {\n            // Außerhalb des Zeitplans: Zurücksetzen auf normale Min-/Max-Werte der Phase\n            this.changeDuty(this.maxDuty);\n        }\n    }\n\n    runAction() {\n        if (!this.lightOnTime || !this.lightOffTime) {\n            node.warn(`${this.name}: Lichtzeiten fehlen. Keine Aktion durchgeführt.`);\n            return { Light: `${this.switches[0]}`, Action: \"NoLightTimesSet\", Status: this.isRunning };\n        }\n\n\n        this.checkforStartStop()\n        this.checkforPhase()\n\n        switch (this.action) {\n            case \"on\":\n                return this.turnON();\n\n            case \"off\":\n                return this.turnOFF();\n\n            case \"unchanged\":\n                return { Light: `${this.switches[0]}`, Action: \"NoChange\", Status: this.isRunning };\n\n            case \"increased\":\n                if (this.hasDuty && this.isRunning) {\n                    const newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                    if(this.dutyCycle != newDuty){\n                        return this.changeDuty(newDuty);\n                    }\n                }\n                break;\n\n            case \"reduced\":\n                if (this.hasDuty && this.isRunning) {\n                    const newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                    if (this.dutyCycle !== newDuty){\n                        return this.changeDuty(newDuty);\n                    }\n                }\n                break;\n\n            case \"minimum\":\n                if (this.hasDuty && this.isRunning) {\n                    if(this.dutyCycle !== this.minDuty){\n                        return this.changeDuty(this.minDuty);\n                    }\n                }\n                break;\n\n            case \"maximum\":\n                if (this.hasDuty && this.isRunning) {\n                    if(this.dutyCycle !== this.maxDuty){\n                        return this.changeDuty(this.maxDuty);\n                    }\n                }\n                break;\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Light: `${this.switches[0]}`, Action: \"UnknownAction\", Status: this.isRunning };\n        }\n    }\n\n    changeDuty(newDuty) {\n        if (!this.hasDuty) {\n            return { entity_id: this.switches[0], action: \"NoDutyCycle\" };\n        }\n\n        const clampedDuty = Math.max(this.minDuty, Math.min(this.maxDuty, newDuty));\n\n        // Überprüfen, ob sich dutyCycle oder voltage tatsächlich geändert haben\n        const newVoltage = Math.floor(clampedDuty / 10);\n        if (this.dutyCycle === clampedDuty && this.voltage === newVoltage) {\n            //node.warn(`${this.name}: Duty-Cycle und Voltage unverändert.`);\n            return { entity_id: this.switches[0], action: \"NoChangeNeeded\" };\n        }\n\n        // Aktualisiere dutyCycle und voltage\n        this.dutyCycle = clampedDuty;\n        this.voltage = newVoltage;\n\n        if (this.controlOverVoltage) {\n            const voltageKey = this.sensors.find((key) =>\n                key.toLowerCase().includes(\"voltage\") && !key.toLowerCase().startsWith(\"sensor.\")\n            );\n\n            if (!voltageKey) {\n                node.warn(`${this.name}: Kein Voltage-Key in sensors gefunden.`);\n                return { entity_id: null, action: \"NoVoltageKey\" };\n            }\n\n            const correctedVoltage = parseFloat((this.dutyCycle / 10).toFixed(1)); // Runde auf eine Dezimalstelle\n\n            node.warn(`${this.name}: Voltage-Wert gesendet: ${correctedVoltage} an ${voltageKey}`);\n            return { entity_id: voltageKey, action: \"number\", value: correctedVoltage };\n        }\n\n        const entity = this.switches[0];\n        //node.warn(`${this.name}: Duty-Cycle geändert auf ${clampedDuty}%, Voltage: ${this.voltage}V.`);\n        return { entity_id: entity, action: \"dutycycle\", dutycycle: clampedDuty };\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (this.isRunning === false) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Licht wurde eingeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"on\" };\n        } else {\n            return { entity_id: entity, action: \"AllReadyON\" };\n        }\n\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning === true) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Licht wurde ausgeschaltet in ${this.inRoomName}.`);\n            return { entity_id: entity, action: \"off\" };\n        } else {\n            return { entity_id: entity, action: \"AllReadyOff\" };\n        }\n\n    }\n}\n\nclass Humidifier extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.targetHumidity = 0; // Ziel-Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n        this.realHumidifier = false; // Erkennung eines echten Luftbefeuchters\n        this.hasModes = false; // Erkennung von Modis\n        this.isSimpleSwitch = true; // Gerät ist nur ein einfacher Schalter\n        this.modes = {\n            interval: true,\n            small: false,\n            large: false,\n        };\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data }; // Aktualisiere die Gerätedaten\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyHumidifierType();\n        this.identifyIfHasModes();\n    }\n\n    identifyIfHasModes() {\n        if (this.data && this.data[\"select.humidifier_mode\"]) {\n            this.realHumidifier = true;\n            this.hasModes = true;\n            this.isSimpleSwitch = false;\n        } else {\n            this.hasModes = false;\n        }\n    }\n\n    identifyHumidifierType() {\n        if (this.data) {\n            if (Object.keys(this.data).some(key => key.startsWith(\"humidifier.\"))) {\n                this.realHumidifier = true;\n                this.isSimpleSwitch = false;\n            } else if (Object.keys(this.data).some(key => key.startsWith(\"switch.\"))) {\n                this.isSimpleSwitch = true;\n                this.realHumidifier = false;\n            } else {\n                this.realHumidifier = false;\n                this.isSimpleSwitch = true;\n            }\n        } else {\n            node.warn(`${this.name}: Keine Daten vorhanden, Standard: Einfacher Schalter.`);\n            this.realHumidifier = false;\n            this.isSimpleSwitch = true;\n        }\n    }\n\n    setHumidityLevel(humlevel) {\n        if (!this.realHumidifier) {\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n        const entity = this.switches[0];\n        this.targetHumidity = humlevel;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${humlevel}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: humlevel };\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        if (this.isSimpleSwitch) {\n            return this.action === \"increased\" || this.action === \"on\"\n                ? this.turnON()\n                : this.turnOFF();\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.hasModes\n                    ? this.changeMode(\"increased\")\n                    : this.turnON();\n            case \"reduced\":\n                return this.hasModes\n                    ? this.changeMode(\"reduced\")\n                    : this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    changeMode(direction) {\n        if (!this.hasModes) {\n            node.warn(`${this.name}: Moduswechsel nicht unterstützt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const actions = [];\n\n        if (direction === \"increase\") {\n            if (!this.isRunning) {\n                this.isRunning = true;\n                actions.push({ entity_id: this.switches[0], action: \"on\" });\n            }\n\n            if (this.modes.interval) {\n                this.modes.interval = false;\n                this.modes.small = false;\n                this.modes.large = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"large\" });\n            }\n        } else if (direction === \"decrease\") {\n            if (this.modes.large) {\n                this.modes.large = false;\n                this.modes.small = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"small\" });\n            } else if (this.modes.small) {\n                this.modes.small = false;\n                this.modes.interval = true;\n                actions.push({ entity_id: \"select.humidifier_mode\", action: \"select\", option: \"interval\" });\n            } else if (this.modes.interval) {\n                this.isRunning = false;\n                actions.push({ entity_id: this.switches[0], action: \"off\" });\n            }\n        }\n\n        return actions.length > 0 ? actions : { entity_id: this.switches[0], action: \"No Change\" };\n    }\n\n    changeHumidity(delta) {\n        if (!this.realHumidifier) {\n            node.warn(`${this.name}: Luftfeuchtigkeit kann nicht geändert werden, da es sich um einen einfachen Schalter handelt.`);\n            return { entity_id: this.switches[0], action: \"Unsupported\" };\n        }\n\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            node.warn(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        node.warn(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"number\", value: newHumidity };\n    }\n}\n\n//NEED TO TEST THIS \nclass Dehumidifier extends Device {\n    constructor(name) {\n        super(name, \"dehumidifier\");\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n}\n\nclass Heater extends Device {\n    constructor(name) {\n        super(name, \"heater\");\n    }\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\nclass Cooler extends Device {\n    constructor(name) {\n        super(name, \"cooler\");\n    }\n\n    runAction() {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF();\n            case \"on\":\n                return this.turnON();\n            case \"increased\":\n                return this.turnON();\n            case \"reduced\":\n                return this.turnOFF();\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n}\n\nclass Pump extends Device {\n    constructor(name) {\n        super(name, \"pump\");\n        this.pumpInterval = 3600; // Mindestintervall zwischen Pumpzyklen (in Sekunden)\n        this.pumpDuration = 10; // Pumpdauer in Sekunden\n        this.isAutoRun = false; // Automatikmodus\n        this.OGBAutoMODE = false; // OpenGrowBox Steuerung\n        this.lastPumpTime = null; // Zeitpunkt des letzten Pumpvorgangs\n        this.soilMoisture = 0; // Bodenfeuchtigkeit\n        this.soilEC = 0; // Elektrische Leitfähigkeit\n        this.minSoilMoisture = 25; // Mindestbodenfeuchte\n        this.maxSoilEC = 2.5; // Maximaler EC-Wert\n    }\n\n    // Gerätedaten setzen und Bodenwerte aktualisieren\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.evaluateStateFromData();\n        this.identifyIfOGBControlled(context);\n\n        // Aktualisiere Sensorwerte\n        if (data.soilmoisture) this.soilMoisture = parseFloat(data.soilmoisture);\n        if (data.soilec) this.soilEC = parseFloat(data.soilec);\n    }\n\n    // Prüfe OpenGrowBox Steuerung\n    identifyIfOGBControlled(context) {\n        this.OGBAutoMODE = !!context.controls.co2Control;\n    }\n\n    // Status aus Gerätedaten evaluieren\n    evaluateStateFromData() {\n        if (this.data) {\n            const pumpOnKey = Object.keys(this.data).find(key => key.includes(\"pump_on\"));\n            if (pumpOnKey) this.isRunning = this.data[pumpOnKey] === \"on\";\n\n            const autoRunKey = Object.keys(this.data).find(key => key.includes(\"pump_autorun\"));\n            if (autoRunKey) this.isAutoRun = this.data[autoRunKey] === \"on\";\n        }\n    }\n\n    // Mindestintervall prüfen\n    canPumpNow() {\n        const now = new Date();\n        const elapsedTime = this.lastPumpTime\n            ? (now.getTime() - this.lastPumpTime.getTime()) / 1000\n            : this.pumpInterval;\n\n        return elapsedTime >= this.pumpInterval;\n    }\n\n    // Prüfe, ob Bewässerung notwendig ist\n    needsWatering() {\n        return this.soilMoisture < this.minSoilMoisture && this.soilEC < this.maxSoilEC;\n    }\n\n    // Geräteaktionen ausführen\n    runAction(context) {\n        // Prüfe ob AutoModus aktiv ist\n        if (this.isAutoRun) {\n            return this.runAutoMode();\n        }\n\n        switch (this.action) {\n            case \"on\":\n                return this.runPump(\"on\");\n            case \"off\":\n                return this.runPump(\"off\");\n            case \"autorun-on\":\n                return this.setAutoMode(true);\n            case \"autorun-off\":\n                return this.setAutoMode(false);\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { entity_id: this.switches[0], action: \"UnknownAction\" };\n        }\n    }\n\n    // Automatische Steuerung der Pumpe\n    runAutoMode() {\n        if (!this.canPumpNow()) {\n            node.warn(`${this.name}: Intervall nicht erreicht.`);\n            return { entity_id: this.switches[0], action: \"wait_interval\" };\n        }\n\n        if (!this.needsWatering()) {\n            node.warn(`${this.name}: Keine Bewässerung notwendig (Moisture: ${this.soilMoisture}, EC: ${this.soilEC}).`);\n            return { entity_id: this.switches[0], action: \"no_water_needed\" };\n        }\n\n        this.lastPumpTime = new Date();\n        this.isRunning = true;\n\n        node.warn(`${this.name}: Starte automatische Bewässerung.`);\n        return { entity_id: this.switches[0], action: \"on\", duration: this.pumpDuration };\n    }\n\n    // Manuelle Pumpaktion ausführen\n    runPump(state) {\n        if (state === \"on\" && !this.isRunning) {\n            this.isRunning = true;\n            this.lastPumpTime = new Date();\n            node.warn(`${this.name}: Pumpe manuell eingeschaltet.`);\n            return { entity_id: this.switches[0], action: \"on\" };\n        } else if (state === \"off\" && this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Pumpe manuell ausgeschaltet.`);\n            return { entity_id: this.switches[0], action: \"off\" };\n        } else {\n            return { entity_id: this.switches[0], action: `Already ${state.toUpperCase()}` };\n        }\n    }\n\n    // AutoModus setzen\n    setAutoMode(state) {\n        this.isAutoRun = state;\n        const action = state ? \"on\" : \"off\";\n        node.warn(`${this.name}: Automatikmodus ${state ? \"aktiviert\" : \"deaktiviert\"}.`);\n        return { entity_id: this.switches[1], action: action };\n    }\n}\n\nclass CO2 extends Device {\n    constructor(name) {\n        super(name, \"co2\"); // Setze den Gerätetyp auf \"co2\"\n        this.targetCO2 = 0; // Zielwert für CO2 (ppm)\n        this.currentCO2 = 0; // Aktueller CO2-Wert (ppm)\n        this.autoRegulate = false; // Automatische Steuerung\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    setTargetCO2(target) {\n        if (target !== this.targetCO2) {\n            this.targetCO2 = target;\n        }\n    }\n\n    enableAutoRegulation() {\n        if (!this.enableAutoRegulation) {\n            this.autoRegulate = true;\n        }\n    }\n\n    disableAutoRegulation() {\n        if (this.enableAutoRegulation) {\n            this.autoRegulate = false;\n        }\n    }\n\n    updateCurrentCO2(value) {\n        if (value !== this.currentCO2) {\n            this.currentCO2 = value;\n        }\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") return false;\n\n        if (this.autoRegulate && this.currentCO2 < this.targetCO2) {\n            this.action = \"increased\";\n            return true;\n        } else if (this.autoRegulate && this.currentCO2 > this.targetCO2) {\n            this.action = \"reduced\";\n            return true;\n        }\n\n        return this.action !== \"unchanged\";\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { CO2: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"increased\":\n                node.warn(`${this.name}: CO2-Zufuhr wird erhöht.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"reduced\":\n                node.warn(`${this.name}: CO2-Zufuhr wird gestoppt.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"on\":\n                node.warn(`${this.name}: CO2-Zufuhr wird aktiviert.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: CO2-Zufuhr wird deaktiviert.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { CO2: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass GenericSwitch extends Device {\n    constructor(name) {\n        super(name, \"switch\"); // Setze den Gerätetyp auf \"switch\"\n        this.isRunning = false; // Status des Schalters\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Switch: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                if (!this.isRunning) {\n                    this.isRunning = true;\n                    node.warn(`${this.name}: Switch wird eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"on\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already ON\" };\n                }\n\n            case \"off\":\n                if (this.isRunning) {\n                    this.isRunning = false;\n                    node.warn(`${this.name}: Switch wird ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"off\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already OFF\" };\n                }\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Switch: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\n//// UNTIL HERE\nclass Sensor extends Device {\n    constructor(name) {\n        super(name, \"sensor\");\n        this.readings = []; // Speichert Sensordaten\n    }\n\n    init() { }\n    evalAction(context) {\n        // Generische Prüfungen für alle Geräte\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n\n        return true; // Standardmäßig erlauben\n    }\n    addReading(reading) {\n        this.readings.push(reading);\n        return this.readings;\n    }\n\n    getLastReading() {\n        return this.readings.length > 0 ? this.readings[this.readings.length - 1] : null;\n    }\n\n    clearReadings() {\n        this.readings = [];\n    }\n}\n\n// Instanziiere die VPDControl-Klasse und speichere sie in der globalen Node-RED-Variablen\nglobal.set(\"OpenGrowBox\", OpenGrowBox);\nnode.status({fill:\"green\",shape:\"ring\",text:\"OpenGrowBox Started\"});\nmsg.topic = \"Init\"\nreturn msg\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":860,"y":80,"wires":[[]]},{"id":"5772bf4c.b461d","type":"server","name":"OpenGrowBox","version":5,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":true,"cacheJson":true,"heartbeat":false,"heartbeatInterval":"30","areaSelector":"friendlyName","deviceSelector":"friendlyName","entitySelector":"friendlyName","statusSeparator":"at: ","statusYear":"hidden","statusMonth":"short","statusDay":"numeric","statusHourCycle":"h23","statusTimeFormat":"h:m","enableGlobalContextStore":true},{"id":"home-assistant-server","type":"server","name":"Home Assistant","addon":true}]