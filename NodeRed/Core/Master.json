[{"id":"7dbb001f4a12c33e","type":"tab","label":"Master","disabled":false,"info":"","env":[]},{"id":"f909d81ee941efae","type":"group","z":"7dbb001f4a12c33e","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["379bbb62f7fb4b7c","d6134f16ee8844fc","efb43912e7a2eb98","9137b5d43acc28ea","5d05c002dcc181b1","05fdf37a0dfc53e5","36eb4263578cb7f8","595ee059ea3fd974","621530929f948569","176f31d32887aa17","e87f8899a673c36a","c82af6bc5bdd07e6","7eea3c825b6deed0","766ff979fe22bf9f","2ca40f0181e36b3b"],"x":14,"y":519,"w":972,"h":262},{"id":"6bed9eda4fa3acae","type":"group","z":"7dbb001f4a12c33e","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ea9a5f7f9a30622e","1204a9454a246bef","e080200084a2a53c","6fdad6fd6de44623","fc401daeeb0fd351","d5b094f02df76602","cac49eb78ba68312","bbabf73a6a9a50e0","46c4877d2b9df30b","bc7f22d406c8c903","9e68bb4660b0dc85","8e269f5aa2c73b95","c3c2984391e4f4ff","c61764896b398806","a18896581ae39de2","15efd1a28752af0a","aa69781023c2c8e4","b968e79941432fde","67515b3048bcee47","857c11e447bf274e","8f62c9fa4f10ed22"],"x":14,"y":199,"w":1402,"h":302},{"id":"366be7e1c1f87ce8","type":"group","z":"7dbb001f4a12c33e","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["7cd26991c29b23ad","b1f1cfc20406abdb","eb313d27f2dc425c","9ee4acd6be52febc","eff0ee90b7e5aa16","9c978f503585f201","de414321bf65b230"],"x":14,"y":39,"w":692,"h":142},{"id":"8f62c9fa4f10ed22","type":"junction","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","x":440,"y":340,"wires":[["9e68bb4660b0dc85","1204a9454a246bef"]]},{"id":"766ff979fe22bf9f","type":"junction","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","x":620,"y":700,"wires":[["36eb4263578cb7f8","9137b5d43acc28ea"]]},{"id":"1204a9454a246bef","type":"ha-api","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"areas","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/area_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"areas","propertyType":"msg","value":"","valueType":"results"},{"property":"topic","propertyType":"msg","value":"areas","valueType":"str"}],"x":510,"y":380,"wires":[["a18896581ae39de2","15efd1a28752af0a"]]},{"id":"e080200084a2a53c","type":"inject","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"Manual Update","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"60","crontab":"","once":true,"onceDelay":"15","topic":"","payload":"","payloadType":"date","x":140,"y":240,"wires":[["8f62c9fa4f10ed22"]]},{"id":"6fdad6fd6de44623","type":"ha-api","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"entities","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/entity_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"entities","propertyType":"msg","value":"","valueType":"results"}],"x":1060,"y":380,"wires":[["c61764896b398806"]]},{"id":"fc401daeeb0fd351","type":"server-events","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"On Connect","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"home_assistant_client","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":110,"y":460,"wires":[["d5b094f02df76602"]]},{"id":"d5b094f02df76602","type":"switch","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"con","property":"payload","propertyType":"msg","rules":[{"t":"eq","v":"connected","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":330,"y":420,"wires":[["8f62c9fa4f10ed22"]]},{"id":"cac49eb78ba68312","type":"server-events","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"entity_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"entity_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":140,"y":280,"wires":[["bc7f22d406c8c903"]]},{"id":"bbabf73a6a9a50e0","type":"server-events","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"device_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"device_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":150,"y":340,"wires":[["bc7f22d406c8c903"]]},{"id":"46c4877d2b9df30b","type":"server-events","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"area_registry_updated","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"area_registry_updated","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":140,"y":400,"wires":[["bc7f22d406c8c903"]]},{"id":"bc7f22d406c8c903","type":"trigger","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"Update","op1":"","op2":"","op1type":"nul","op2type":"payl","duration":"30","extend":false,"overrideDelay":false,"units":"s","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":340,"y":340,"wires":[["8f62c9fa4f10ed22"]]},{"id":"9e68bb4660b0dc85","type":"ha-get-entities","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"Get All Entities","server":"home-assistant-server","version":1,"rules":[],"outputType":"array","outputEmptyResults":false,"outputLocationType":"msg","outputLocation":"payload","x":540,"y":300,"wires":[["8e269f5aa2c73b95"]]},{"id":"8e269f5aa2c73b95","type":"function","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"AllData","func":"msg.topic=\"AllData\"\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":300,"wires":[["ea9a5f7f9a30622e"]]},{"id":"c3c2984391e4f4ff","type":"function","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"GroupFilledRoom","func":"let data = msg.payload;\nlet allData = data.AllData;\ndelete data.AllData;\n\n// Erstelle ein Mapping von entity_id zu state aus dem AllData-Array\nlet entityIdToStateMap = {};\nallData.forEach(item => {\n    entityIdToStateMap[item.entity_id] = item.state;\n});\n\n// Erstelle ein neues Objekt zur Gruppierung der Daten, das die gleiche Struktur wie das Ursprungsobjekt beibehält\nlet groupedData = {};\n\n// Iteriere über die Hauptgruppen in data (z.B., flowertent, vegittent, dryingtent, ambient)\nfor (let group in data) {\n    if (data.hasOwnProperty(group)) {\n        groupedData[group] = {}; // Behalte den Gruppennamen wie flowertent\n\n        // Iteriere über die Untergruppen in der Hauptgruppe (z.B., light, plant, co2, ...)\n        for (let subGroup in data[group]) {\n            if (data[group].hasOwnProperty(subGroup)) {\n                groupedData[group][subGroup] = {};\n\n                // Iteriere über die Sensoren in der Untergruppe\n                for (let sensor in data[group][subGroup]) {\n                    if (data[group][subGroup].hasOwnProperty(sensor)) {\n                        // Hole den Wert aus entityIdToStateMap, falls vorhanden, andernfalls behalte den bestehenden Wert\n                        let value = entityIdToStateMap[sensor] !== undefined ? entityIdToStateMap[sensor] : data[group][subGroup][sensor];\n\n                        // Speichere den Sensor-Schlüssel mit dem gefüllten Wert in groupedData\n                        groupedData[group][subGroup][sensor] = value;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Setze das gefüllte Objekt als msg.payload\nmsg.payload = groupedData;\nmsg.tentData = true\n// Entferne nicht benötigte Eigenschaften aus msg\ndelete msg.devices;\ndelete msg.entities;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1250,"y":300,"wires":[["aa69781023c2c8e4"]]},{"id":"c61764896b398806","type":"function","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"DynamicCollectData","func":"// Erster Teil: Erstellen des `entities`-Objekts mit `area_id` und `name`\nconst entities = {};\n\nmsg.entities.forEach(e => {\n    // Überprüfe, ob entweder `device_id` gefüllt ist oder `area_id` gefüllt ist, aber `device_id` null ist\n    if (!e.device_id && e.area_id) {\n        const area = msg.areas.find(a => a.area_id === e.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    } else if (e.device_id) {\n        const device = msg.devices.find(d => d.id === e.device_id);\n        const area = msg.areas.find(a => a.area_id === device.area_id);\n        if (area) {\n            entities[e.entity_id] = {\n                area_id: area.area_id,\n                name: area.name\n            };\n        }\n    }\n});\n\n// Erzeuge die nicht gruppierte Nachricht für den zweiten Output\nlet ungroupedOutput = { payload: entities, update: true };\n\n// Zweiter Teil: Gruppierung von `entities` nach `area_id` und `name`\nlet output = {};\n\nfor (let key in entities) {\n    let area_id = entities[key].area_id;\n    let entityName = entities[key].name;\n\n    // Falls der `area_id`-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id]) {\n        output[area_id] = {};\n    }\n\n    // Teile den Sensor-String in `name` und `type` auf\n    let [prefix, suffix] = key.split('.'); // Trenne bei Punkt, z.B. \"sensor.light_ip\"\n    let [name, type] = suffix.split('_'); // Trenne bei Unterstrich, z.B. \"light_ip\"\n\n    // Falls der Name-Bereich noch nicht existiert, erstelle ihn\n    if (!output[area_id][name]) {\n        output[area_id][name] = {};\n    }\n\n    // Speichere den vollständigen Sensor-Schlüssel mit `null` als Wert\n    output[area_id][name][key] = null;\n}\n\n// Erzeugung von Nachrichten für jeden `area_id`-Bereich (erster Output)\nlet messages = [];\n\nfor (let area_id in output) {\n    if (output.hasOwnProperty(area_id)) {\n        // Erzeuge eine Nachricht für jede Gruppe mit `area_id` als `topic`\n        messages.push({\n            topic: area_id,\n            payload: output[area_id]\n        });\n    }\n}\n\n// Rückgabe der beiden Outputs: erster Output für die gruppierten Daten, zweiter für die ungruppierten\nreturn [messages, ungroupedOutput];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1240,"y":380,"wires":[["67515b3048bcee47"],["b968e79941432fde"]]},{"id":"379bbb62f7fb4b7c","type":"server-events","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"newEvent","server":"5772bf4c.b461d","version":3,"exposeAsEntityConfig":"","eventType":"state_changed","eventData":"","waitForRunning":true,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"},{"property":"event_type","propertyType":"msg","value":"$outputData(\"eventData\").event_type","valueType":"jsonata"}],"x":100,"y":600,"wires":[["d6134f16ee8844fc"]]},{"id":"ea9a5f7f9a30622e","type":"function","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"DynamicCombinedRoomData","func":"// Überprüfe, ob die Nachricht `AllData` ist und speichere sie im Kontext\nif (msg.topic === \"AllData\") {\n    context.set(\"AllData\", msg.payload);\n    node.status({ fill: \"green\", shape: \"dot\", text: \"AllData Loaded\", })\n    return null; // `AllData` wird nur gespeichert und nicht sofort ausgegeben\n}\n\n// Hole `AllData` aus dem Kontext\nlet allData = context.get(\"AllData\");\n\n// Wenn `AllData` noch nicht geladen ist, warte auf weitere Nachrichten\nif (!allData) {\n    node.warn(\"AllData noch nicht im Kontext vorhanden. Warte auf AllData.\");\n    node.status({fill:\"red\", shape: \"ring\", text: \"No Data Available\", })\n    return null;\n}\n\n// Kombiniere `AllData` mit der aktuellen Nachricht\nlet combinedData = {\n    AllData: allData,\n    [msg.topic]: msg.payload\n};\n\n// Setze das kombinierte Objekt als `msg.payload`\nmsg.payload = combinedData;\n\n// Gib die kombinierte Nachricht zurück\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1010,"y":300,"wires":[["c3c2984391e4f4ff"]]},{"id":"d6134f16ee8844fc","type":"function","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"SetArea","func":"if(msg.update) {\n    node.status({fill:\"green\", shape: \"dot\", text: \"Area Data Loaded\", })\n    context.set(\"data\", msg.payload);\n    return;\n}\nconst data = context.get(\"data\");\n\nif(!data) {\n    node.status({fill:\"red\", shape: \"ring\", text: \"No Area Data\", })\n    return;\n}\n\nconst area = data[msg.payload.entity_id];\nif(!area) return;\n\nmsg.area = area.name.toLowerCase();\n\n\n// Extrahiere `entity_id`, z.B. \"sensor.h5179_485d_temperature\"\nconst entity_id = msg.payload.entity_id;\n\n// Zerlege den `entity_id`-String, um den Gerätetyp zu extrahieren\nconst parts = entity_id.split('.')[1]; // Entfernt den Präfix (z.B., \"sensor.\")\nconst device = parts.split('_')[0]; // Entfernt den Suffix nach dem ersten Unterstrich\n\n// Extrahiere alten und neuen Zustand\nconst oldState = msg.payload.event.old_state.state;\nconst newState = msg.payload.event.new_state.state;\n\n// Erstelle ein Objekt `updateData` für das Update\nconst updateData = {\n    room: msg.area,\n    device: device,\n    entity_id: entity_id,\n    oldState: oldState,\n    newState: newState\n};\nnode.status({ text: `Update for: ${msg.area}`});\nmsg.payload = updateData\nmsg.update = true\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":300,"y":600,"wires":[["5d05c002dcc181b1","e87f8899a673c36a"]]},{"id":"efb43912e7a2eb98","type":"function","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"GetRoomInstance","func":"// Hole den Raumnamen aus `msg.area`\nconst room = msg.topic;\n\n// Lade die Instanz der OpenGrowBox für den Raum\nconst roomInstance = global.get(room);\nif (!roomInstance) {\n    node.warn(`Keine Instanz für Raum ${room} gefunden.`);\n    return null;\n}\nmsg.payload = [roomInstance]\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":490,"y":700,"wires":[["766ff979fe22bf9f"]]},{"id":"9137b5d43acc28ea","type":"debug","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"RoomObject","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":730,"y":680,"wires":[]},{"id":"a18896581ae39de2","type":"ha-api","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"devices","server":"5772bf4c.b461d","version":1,"debugenabled":false,"protocol":"websocket","method":"get","path":"","data":"{\"type\": \"config/device_registry/list\"}","dataType":"json","responseType":"json","outputProperties":[{"property":"devices","propertyType":"msg","value":"","valueType":"results"}],"x":840,"y":380,"wires":[["6fdad6fd6de44623"]]},{"id":"7cd26991c29b23ad","type":"inject","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":470,"y":80,"wires":[["b1f1cfc20406abdb"]]},{"id":"b1f1cfc20406abdb","type":"function","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"ClearGlobals","func":"// Alle globalen Schlüssel abrufen\nconst keys = global.keys();\n\nif (keys.length === 0) {\n    node.warn(\"Keine globalen Variablen vorhanden, nichts zu löschen.\");\n    return null; // Keine Variablen zum Löschen\n}\n\n// Alle globalen Schlüssel löschen\nkeys.forEach(key => {\n    global.set(key, undefined); // Setzt den Schlüssel auf undefined, was ihn effektiv löscht\n    node.warn(`Globale Variable gelöscht: ${key}`);\n});\n\nnode.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: `Alle ${keys.length} globalen Variablen gelöscht`\n});\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":610,"y":80,"wires":[[]]},{"id":"5d05c002dcc181b1","type":"function","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"CombinedUpdated_RoomData","func":"// Hole die gespeicherten Basisdaten aus dem globalen Speicher\nlet tentsData = global.get(\"tentsData\") || {};\n\n// Prüfen, ob die Nachricht ein Update enthält (msg.update = true)\nif (msg.update === true) {\n    // Extrahiere die Update-Informationen\n    const update = msg.payload;\n    const room = update.room; // Welcher Raum soll aktualisiert werden\n    const device = update.device; // Welches Gerät im Raum\n    const entityId = update.entity_id; // Entität, die aktualisiert wird\n    const newValue = update.newState; // Neuer Wert\n\n    // Sicherstellen, dass der Raum in den Daten existiert\n    if (tentsData[room]) {\n        // Sicherstellen, dass das Gerät im Raum existiert\n        if (tentsData[room][device]) {\n            // Prüfen, ob die Entität existiert\n            if (tentsData[room][device][entityId] !== undefined) {\n                const oldValue = tentsData[room][device][entityId];\n\n                // Aktualisieren, wenn der Wert unterschiedlich ist\n                if (oldValue !== newValue) {\n                    tentsData[room][device][entityId] = newValue;\n                    node.status({ fill: \"green\", shape: \"dot\", text: `Updated: ${room} -> ${device} -> ${entityId}` });\n                } else {\n                    node.status({ fill: \"blue\", shape: \"ring\", text: `No change: ${room} -> ${device} -> ${entityId}` });\n                }\n            } else {\n                node.status({ fill: \"yellow\", shape: \"ring\", text: `Entity not found: ${room} -> ${device} -> ${entityId}` });\n            }\n        } else {\n            node.status({ fill: \"red\", shape: \"ring\", text: `Device not found: ${room} -> ${device}` });\n        }\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: `Room not found: ${room}` });\n    }\n\n    // Setze den msg.topic auf den Raum-Namen\n    msg.topic = room;\n\n    // Gib nur den aktualisierten Raum zurück\n    msg.payload = { [room]: tentsData[room] };\n} else {\n    // Basisdaten speichern\n    const newTentsData = msg.payload;\n\n    // Räume in die globale Datenstruktur hinzufügen oder aktualisieren\n    for (const room in newTentsData) {\n        if (newTentsData.hasOwnProperty(room)) {\n            tentsData[room] = { ...tentsData[room], ...newTentsData[room] };\n        }\n    }\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Base data updated\" });\n\n    // Setze den msg.topic auf den Raum-Namen, falls ein einzelner Raum geladen wurde\n    msg.topic = \"all_rooms\";\n\n    // Gib die gesamte Struktur zurück, wenn es keine Updates sind\n    //msg.payload = tentsData;\n}\n\n// Speichere die aktualisierten Daten im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\n// Debugging: Zeige die vollständige Struktur\n//node.warn(`Updated tents data: ${JSON.stringify(tentsData, null, 2)}`);\n\n// Rückgabe des aktualisierten Raums oder der gesamten Struktur\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":570,"y":600,"wires":[["c82af6bc5bdd07e6","2ca40f0181e36b3b"]]},{"id":"eb313d27f2dc425c","type":"inject","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"Init","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"OpenGrowBox Start","payloadType":"str","x":110,"y":80,"wires":[["de414321bf65b230"]]},{"id":"05fdf37a0dfc53e5","type":"link out","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"MasterLink","mode":"link","links":["02701e85ddace028","e9fc73b86d447581"],"x":945,"y":600,"wires":[]},{"id":"9ee4acd6be52febc","type":"inject","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"Load Data on Start","props":[],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","x":150,"y":140,"wires":[[]]},{"id":"eff0ee90b7e5aa16","type":"file in","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"Read from File","filename":"/data/openGrowBox.json","filenameType":"str","format":"utf8","chunk":false,"sendError":false,"encoding":"none","x":380,"y":140,"wires":[["9c978f503585f201"]]},{"id":"9c978f503585f201","type":"function","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"Initialize Instances","func":"// Prüfen, ob die Klasse OpenGrowBox im globalen Kontext verfügbar ist\nconst OpenGrowBox = global.get(\"OpenGrowBox\");\nif (!OpenGrowBox) {\n    node.error(\"OpenGrowBox class not found in global context\");\n    return null;\n} \nif (msg.payload) {\n    const storedData = JSON.parse(msg.payload);\n    storedData.forEach(roomData => {\n        const roomName = roomData.roomName;\n        const roomInstance = new OpenGrowBox(roomName);\n        roomInstance.tentData = roomData.tentData;\n        global.set(roomName, roomInstance);\n    });\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Instances Loaded\" });\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"No Data Found\" });\n}\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":570,"y":140,"wires":[[]]},{"id":"36eb4263578cb7f8","type":"function","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"Prepare Data","func":"const allInstances = global.keys().map(roomName => {\n    const roomInstance = global.get(roomName);\n    return {\n        roomName: roomName,\n        tentData: roomInstance ? roomInstance.tentData : null\n    };\n});\n\nmsg.payload = JSON.stringify(allInstances, null, 2);\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":630,"y":740,"wires":[["595ee059ea3fd974"]]},{"id":"595ee059ea3fd974","type":"file","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"Write to File","filename":"/data/openGrowBox.json","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"utf8","x":790,"y":740,"wires":[[]]},{"id":"15efd1a28752af0a","type":"function","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"RoomManager","func":"// Hole aktuelle Räume aus Home Assistant\nconst currentAreas = msg.areas; // Räume von Home Assistant\nconst currentAreaIds = currentAreas.map(area => area.area_id.toLowerCase()); // IDs der aktuellen Räume\n\n// Hole gespeicherte Räume aus tentsData\nlet tentsData = global.get(\"tentsData\") || {};\nlet removedRooms = [];\n\n// Iteriere über gespeicherte Räume und entferne verwaiste\nfor (let roomName in tentsData) {\n    if (!currentAreaIds.includes(roomName)) {\n        // Raum aus tentsData entfernen\n        delete tentsData[roomName];\n        removedRooms.push(roomName);\n\n        // Globale Rauminstanz entfernen\n        global.set(roomName, null);\n    }\n}\n\n// Aktualisiere tentsData im globalen Speicher\nglobal.set(\"tentsData\", tentsData);\n\n// Logge die entfernten Räume\nif (removedRooms.length > 0) {\n    node.warn(`Removed orphaned rooms: ${removedRooms.join(', ')}`);\n} else {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"No orphaned rooms found\" });\n}\n\n// Rückgabe der aktualisierten Daten\nmsg.payload = { removedRooms, remainingRooms: Object.keys(tentsData) };\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":680,"y":360,"wires":[[]]},{"id":"aa69781023c2c8e4","type":"link out","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"GroupFilledRoom","mode":"link","links":["621530929f948569"],"x":1375,"y":300,"wires":[]},{"id":"621530929f948569","type":"link in","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"link in 87","links":["aa69781023c2c8e4"],"x":395,"y":580,"wires":[["5d05c002dcc181b1"]]},{"id":"b968e79941432fde","type":"link out","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"CollectedRooms","mode":"link","links":["176f31d32887aa17"],"x":1375,"y":400,"wires":[]},{"id":"176f31d32887aa17","type":"link in","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"link in 88","links":["b968e79941432fde"],"x":215,"y":580,"wires":[["d6134f16ee8844fc"]]},{"id":"67515b3048bcee47","type":"link out","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"DataNeededRoom","mode":"link","links":["857c11e447bf274e"],"x":1375,"y":360,"wires":[]},{"id":"857c11e447bf274e","type":"link in","z":"7dbb001f4a12c33e","g":"6bed9eda4fa3acae","name":"DataNeededRoom","links":["67515b3048bcee47"],"x":835,"y":280,"wires":[["ea9a5f7f9a30622e"]]},{"id":"de414321bf65b230","type":"function","z":"7dbb001f4a12c33e","g":"366be7e1c1f87ce8","name":"OpenGrowBox","func":"class OpenGrowBox {\n    constructor(tentName = \"\", plantStage = \"\", tentMode = \"\", perfectionTolerance = 0.025) {\n\n        // Tent Environment        \n        this.tentName = tentName;\n        this.tentMode = tentMode;\n        this.plantStage = plantStage;\n        this.controlSet = \"\";\n\n        this.devices = [];\n        this.ownSetttetDevices = []\n\n        this.needchange = false\n        this.previousActions = [];\n\n        this.controls = {\n            ownWeights:false,\n            weights:{\n                temp:null,\n                hum:null,\n            },\n            co2Control:false,\n            co2ppm:{\n                minPPM:400,\n                maxPPM:1200,\n            },\n            ownDeviceSetup:false,\n            experimental:false,\n            modes:{\n                vpdPerfection:\"VPD Perfection\",\n                inRangeVPD:\"IN-VPD-Range\",\n                targetedVDP:\"Targeted VPD\",\n                drying:\"Drying\",\n                experimentel:\"Experimentel\",\n                disabled:\"Disabled\"\n            }\n        }\n\n        this.expMods = {\n            current:\"\",\n            plantType:\"\",\n        }\n\n        this.isPlantDay = {\n            nightVPDHold: false,\n            lightOn: false,\n            lightOnTime: \"\",\n            lightOffTime: \"\",\n            lightbyOGBControl:false,\n            sunRiseTimes:\"\",\n            sunSetTimes:\"\",\n        }\n\n        this.enviorment = {\n            ambientTemp: 0.0,\n            ambientHumidity: 0.0,\n            ambientDewpoint: 0.0,\n            outsiteTemp: 0.0,\n            outsiteHumidity: 0.0,\n            outsiteDewpoint: 0.0,\n        };\n\n        this.tentData = {\n            temperature: null,\n            humidity: null,\n            leafTempOffset: 0,\n            dewpoint: 0.0,\n            maxTemp: 0,\n            minTemp: 0,\n            maxHumidity: 0,\n            minHumidity: 0,\n            co2Level:400,\n        };\n\n        this.plantStages = {\n            Germination: { vpdRange: [0.412, 0.7], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            Clones: { vpdRange: [0.42, 0.75], minTemp: 20, maxTemp: 26, minHumidity: 65, maxHumidity: 80 },\n            EarlyVeg: { vpdRange: [0.7, 0.85], minTemp: 20, maxTemp: 28, minHumidity: 55, maxHumidity: 70 },\n            MidVeg: { vpdRange: [0.85, 1.1], minTemp: 22, maxTemp: 30, minHumidity: 50, maxHumidity: 65 },\n            LateVeg: { vpdRange: [0.933, 1.2], minTemp: 22, maxTemp: 30, minHumidity: 50, maxHumidity: 60 },\n            EarlyFlower: { vpdRange: [1.0, 1.25], minTemp: 22, maxTemp: 28, minHumidity: 45, maxHumidity: 60 },\n            MidFlower: { vpdRange: [1.1, 1.4], minTemp: 22, maxTemp: 26, minHumidity: 40, maxHumidity: 55 },\n            LateFlower: { vpdRange: [1.2, 1.7], minTemp: 20, maxTemp: 24, minHumidity: 40, maxHumidity: 50 }\n        };\n\n        this.vpd = {\n            current: null,\n            // RANGE VPD\n            range: [],\n            rangeTolerance: 0.0,\n            diffRange: null,\n            // VPD PERFECTION\n            perfection: 0.0,\n            perfectMin: 0.0,\n            perfectMax: 0.0,\n            perfectTolerance: perfectionTolerance,\n            diffPerfection: null,\n            // TARGETED VPD\n            targeted: 0.0,\n            targetedTolerance: 0.0,\n            diffTargeted: null,\n            ecotarget: [0.55, 0.88]\n        };\n\n        this.watering = {\n            autoWatering: false,\n            isRunning: false,\n            pumpInvervall: \"\",\n            pumpTime: \"\",\n            nextPumpAction: \"\",\n            waterTemp: 0,\n            nutrients: {\n                PH: 0,\n                PPM: 0,\n                EC: 0,\n                Temp: 0,\n                N: 0,\n                P: 0,\n                K: 0,\n            }\n        }\n\n        this.dryStartTime = null;\n        this.drying = {\n            currentDryMode: \"\",\n            isEnabled:false,\n            isRunning:false,\n            waterActivity: 0.0,\n            dewpointVPD: 0.0,\n            vaporPressureActual: 0.0,\n            vaporPressureSaturation: 0.0,\n            modes:{\n                elClassico: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetHumidity: 62, durationHours: 72\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetHumidity: 60, durationHours: 72\n                        },\n                        endTime: {\n                            targetTemp: 20, targetHumidity: 58, durationHours: 72\n                        }\n                    }\n                },\n                sharkMouse: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 22.2, targetHumidity: 55, targetVPD: 1.2, durationHours: 48\n                        },\n                        halfTime: {\n                            maxTemp: 23.3, targetHumidity: 52, targetVPD: 1.39, durationHours: 24\n                        },\n                        endTime: {\n                            maxTemp: 23.9, targetHumidity: 50, targetVPD: 1.5, durationHours: 48\n                        }\n                    }\n                },\n                dewBased: {\n                    isActive: false,\n                    phase: {\n                        start: {\n                            targetTemp: 20, targetDewPoint: 12.25, durationHours: 96\n                        },\n                        halfTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 96\n                        },\n                        endTime: {\n                            targetTemp: 20, targetDewPoint: 11.1, durationHours: 48\n                        }\n                    }\n                }\n            }\n\n        }\n\n        this.addons ={\n            GasLanternRoutine:{\n                Veg:{\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,   \n                },\n                Flower:{\n                    Sativa:{\n                    LightOnPhase: 8,\n                    LightOffPhase: 16,\n                    },\n                    Indica:{\n                    LightOnPhase: 6,\n                    LightOffPhase: 18,\n                    }\n                }\n            },\n            GLR_NaturalSunshine:{\n                Veg: {\n                    LightOnPhase: 12,\n                    LightOffPhase: 5,\n                    LightAddon: 1,\n                },\n                Flower: {\n                    Sativa: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 8,\n                        LightOffPhase: 0,\n                        LightSteps:0,\n                        LightStepTime:0,\n\n                    },\n                    Indica: {\n                        LightOnStartPhase: 12,\n                        LightOnEndPhase: 6,\n                        LightOffPhase: 0,\n                        LightSteps: 0,\n                        LightStepTime: 0,\n\n                    }\n                }\n            }\n        }\n\n        //Actions\n        this.actions = {\n            Increased: {\n                exhaust: \"increased\",\n                humidifier: \"reduced\",\n                dehumidifier: \"increased\",\n                heater: \"increased\",\n                cooler: \"reduced\",\n                ventilation: \"increased\",\n                light: \"increased\",\n                co2: \"increased\",\n                climate: {\n                    cool: \"reduced\",\n                    dry: \"increased\",\n                    heat: \"increased\",\n                }\n            },\n            Reduced: {\n                exhaust: \"reduced\",\n                humidifier: \"increased\",\n                dehumidifier: \"reduced\",\n                heater: \"reduced\",\n                cooler: \"increased\",\n                ventilation: \"reduced\",\n                light: \"reduced\",\n                co2:\"reduced\",\n                climate: {\n                    cool: \"increased\",\n                    dry: \"reduced\",\n                    heat: \"reduced\",\n                }\n            },\n            Unchanged: {\n                exhaust: \"unchanged\",\n                humidifier: \"unchanged\",\n                dehumidifier: \"unchanged\",\n                heater: \"unchanged\",\n                cooler: \"unchanged\",\n                ventilation: \"unchanged\",\n                light: \"unchanged\",\n                climate: {\n                    cool: \"unchanged\",\n                    dry: \"unchanged\",\n                    heat: \"unchanged\"\n                }\n            },\n        }\n\n        this.init();\n    }\n\n    init() {\n\n    }\n\n   // DATA SETTER/GETTER ******************************\n    setTentName(tentName = \"\") {\n        this.tentName = tentName;\n    }\n    \n    // Setze ob Ausleih funktion für Ambient aktiv ist. \n    setControlSet(controlSet) {\n        if (this.controlSet !== controlSet) {\n            this.controlSet = controlSet\n        }\n    }\n\n    // erhalte ob Ambient Steuerung aktiv ist.\n    getControlSet() {\n        return this.controlSet\n    }\n\n    // Setze Aktiven ZeltMode\n    setTentMode(tentMode = \"\") {\n        if (this.tentMode !== tentMode) { // Vergleiche auf Gleichheit\n            node.warn(`TentMode geändert von ${this.tentMode} auf ${tentMode} in ${this.tentName}`);\n            \n            // Prüfe, ob der neue Modus nicht \"Drying\" ist\n            if (tentMode !== \"Drying\") {\n                this.drying.isRunning = false;\n                this.drying.isEnabled = false;\n                this.drying.currentDryMode = \"\"; // Drying-Mode zurücksetzen\n                this.dryStartTime = null;        // Timer zurücksetzen\n                node.warn(\"Drying-Modus deaktiviert und Timer zurückgesetzt.\");\n            }\n\n            this.tentMode = tentMode; // Neuen Modus setzen\n        } else {\n            return; // Keine Änderung notwendig\n        }\n    }\n\n    // Setze Targeted VPD wenn Mode aktiv!\n    setTargetedVPD(targetVPD) {\n        if (targetVPD !== this.vpd.targeted) {\n            if(this.tentMode === \"Targeted VPD\"){\n                this.vpd.targeted = targetVPD\n            }\n        }\n    }\n\n    // Ehalte Targeted VPD wenn Mode aktiv!\n    getTargetedVPD() {\n        if (this.tentMode === \"Targeted VPD\") { // Korrekt: Vergleich statt Zuweisung\n            return this.vpd.targeted;\n        }\n        return null; // Falls der Mode nicht aktiv ist, gib einen sinnvollen Wert zurück\n    }\n\n\n\n    // Setze Plant Stage\n    setPlantStageValue(plantStage = \"\") {\n        if (this.plantStages.hasOwnProperty(plantStage)) {\n            const stage = this.plantStages[plantStage];\n            this.vpd.range = stage.vpdRange;\n            this.tentData.maxTemp = stage.maxTemp;\n            this.tentData.minTemp = stage.minTemp;\n            this.tentData.maxHumidity = stage.maxHumidity;\n            this.tentData.minHumidity = stage.minHumidity;\n            this.calculatePerfectVPD();\n            this.plantStage = plantStage; // Stelle sicher, dass plantStage gesetzt wird\n            //node.warn(`PlantStage innerhalb der Instanz aktualisiert: ${this.plantStage}`);\n        } else {\n            node.warn(`Ungültige PlantStage: ${plantStage}`);\n        }\n    }\n\n    // Setze aktuelle Temp\n    setCurrentTemp(temp) {\n        let newTemp = null;\n\n        // Überprüfen, ob temp ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(temp)) {\n            newTemp = parseFloat(this.calculateAvgValue(temp));\n        } else if (typeof temp === 'number') {\n            newTemp = temp;\n        } else if (typeof temp === 'string') {\n            newTemp = parseFloat(temp);\n        } else {\n            throw new Error(\"Invalid temperature data. Must be an array, number, or string.\");\n        }\n\n        if (newTemp === this.tentData.temperature) return;\n\n        this.tentData.temperature = newTemp;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Blatt Temp Offset\n    setLeafOffset(offset) {\n        this.tentData.leafTempOffset = parseFloat(offset)\n    }\n\n    // Setze aktuelle Feuchtigkeit\n    setCurrentHumidity(humidity) {\n        let newHumidity = null;\n\n        // Überprüfen, ob humidity ein Array ist und den Durchschnitt berechnen\n        if (Array.isArray(humidity)) {\n            newHumidity = parseFloat(this.calculateAvgValue(humidity));\n        } else if (typeof humidity === 'number') {\n            newHumidity = humidity;\n        } else if (typeof humidity === 'string') {\n            newHumidity = parseFloat(humidity);\n        } else {\n            throw new Error(\"Invalid humidity data. Must be an array, number, or string.\");\n        }\n\n        if (newHumidity === this.tentData.humidity) return;\n\n        this.tentData.humidity = newHumidity;\n\n        if (this.tentData.humidity != null && this.tentData.temperature != null) {\n            this.calculatePerfectVPD();\n        }\n    }\n\n    // Setze Ambient Raum Daten (WO DAS ZELT STEHT!!!!)\n    setAmbientData(ambTemp, ambHum, ambDew = null) {\n        // Exit if any value is null\n        if (ambTemp === null || ambHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = ambDew !== null ? ambDew : this.calculateDewPoint(ambTemp, ambHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.ambientTemp !== ambTemp ||\n            this.enviorment.ambientHumidity !== ambHum ||\n            this.enviorment.ambientDewpoint !== dewpoint\n        ) {\n            this.enviorment.ambientTemp = ambTemp;\n            this.enviorment.ambientHumidity = ambHum;\n            this.enviorment.ambientDewpoint = dewpoint;\n        }\n    }\n\n    // Setze Temp von Außen \n    setOutsiteData(outTemp, outHum, outDew = null) {\n        // Exit if any value is null\n        if (outTemp === null || outHum === null) return;\n\n        // Calculate dew point if it is missing\n        const dewpoint = outDew !== null ? outDew : this.calculateDewPoint(outTemp, outHum);\n\n        // Update only if values have changed\n        if (\n            this.enviorment.outsiteTemp !== outTemp ||\n            this.enviorment.outsiteHumidity !== outHum ||\n            this.enviorment.outsiteDewpoint !== dewpoint\n        ) {\n            this.enviorment.outsiteTemp = outTemp;\n            this.enviorment.outsiteHumidity = outHum;\n            this.enviorment.outsiteDewpoint = dewpoint;\n        }\n    }\n\n    // Setze aktuellen Dewpoint\n    setCurrentDewPoint(dewpoint) {\n        this.tentData.dewpoint = this.calculateDewPoint(dewpoint)\n    }\n\n    // Aktiviere Nacht VPD Ignoranz\n    setVPDNightHold(nightHold) {\n        if(nightHold != this.helperYesTrue(this.isPlantDay.nightVPDHold)){\n            this.isPlantDay.nightVPDHold = this.helperYesTrue(nightHold)\n        }\n    }\n\n    // Aktiviere Gewicht für Feinjustierung\n    activateOwnWeights(activ) {\n        if(activ !== this.controls.ownWeights){\n            this.controls.ownWeights = this.helperYesTrue(activ)\n            if(!this.controls.ownWeights){\n                this.controls.weights.temp = null\n                this.controls.weights.hum = null\n            }\n        }\n    }\n\n    // Erhatel Gewicht Aktivi Status\n    getifOwnWeightsActive(){\n        return this.helperYesTrue(this.controls.ownWeights)\n    }\n\n    // Setze Gewicht für Feinjustierung\n    setOwnWeights(name, weight) {\n        if (!this.controls.ownWeights) {\n            // Wenn `ownWeights` deaktiviert oder nicht definiert ist\n            if (!this.controls.ownWeights) {\n                return { ownWeights: \"Disabled\" }; // Gebe zurück, dass `ownWeights` deaktiviert ist\n            }\n            // Falls `ownWeights` undefined oder nicht initialisiert ist\n            this.controls.ownWeights = null;\n            return { ownWeights: \"Disabled\" };\n        } else {\n            // Wenn `ownWeights` aktiviert ist\n            if (name.includes(\"hum\")) {\n                // Feuchtigkeitsgewicht setzen\n                this.controls.weights.hum = parseFloat(weight);\n            } else if (name.includes(\"temp\")) {\n                // Temperaturgewicht setzen\n                this.controls.weights.temp = parseFloat(weight);\n            } else {\n                // Ungültiger Name\n                console.warn(`Unrecognized weight type: ${name}`);\n                return { error: `Invalid weight type: ${name}` };\n            }\n\n            return { ownWeights: \"Enabled\" }; // Gebe zurück, dass `ownWeights` aktiviert ist\n        }\n    }\n\n    // Erhalte Gewicht für Feinjustierung\n    getOwnWeights() {\n        if (this.controls.ownWeights) {\n            return { tempWeight: this.controls.weights.temp, humWweight: this.controls.weights.hum }\n        } else {\n            return { Data: \"NotNeeded\" }\n        }\n    }\n\n    // EXPRIMENTEL\n    setGLSControl(glscControl){\n        if(glscControl !== this.controls.experimental){\n            this.controls.experimental = this.helperYesTrue(glscControl)\n        }\n    }\n\n    // EXPRIMENTEL\n    getGLSControl(){\n        return this.helperYesTrue(this.controls.experimental)\n    }\n\n    // EXPRIMENTEL\n    setGLSPlantType(plantType) {\n        if(this.controls.experimental){\n            if (plantType !== this.controls.experimental) {\n                this.expMods.plantType = plantType\n            }\n        }else{\n            if(this.expMods.plantType != \"\"){\n                this.expMods.plantType =\"\"\n                \n            }\n\n        }\n\n    }\n\n    // EXPRIMENTEL\n    getGLSPlantType() {\n        return this.expMods.plantType\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    setOwnDeviceSetup(deviceControl){\n        if (deviceControl !== this.controls.ownDeviceSetup){\n            this.controls.ownDeviceSetup = this.helperYesTrue(deviceControl)\n        }\n        return\n    }\n\n    // EXPRIMENTEL\n    // Aktiviere Eigene Geräte Steuerung(Experimentel\"NOT-DONE\")\n    getOwnDeviceSetup(){\n        return this.helperYesTrue(this.controls.ownDeviceSetup)\n    }\n\n    // Aktiviere CO2 Steuerung\n    setCO2Control(co2Control){\n        if(co2Control !== this.controls.co2Control){\n            this.controls.co2Control = this.helperYesTrue(co2Control)\n        }\n    }\n\n    // COS Status\n    getCO2Control(){\n        return  this.helperYesTrue(this.controls.co2Control)\n    }\n\n    // Aktiviere Kontorlle für Licht\n    setLightControlByOGB(wantsControl){\n        if(wantsControl !== this.isPlantDay.lightbyOGBControl){\n            this.isPlantDay.lightbyOGBControl = this.helperYesTrue(wantsControl)\n        }\n    }\n\n    // Licht Controll Status\n    getLightControlByOGB(){\n        return this.helperYesTrue(this.isPlantDay.lightbyOGBControl)\n    }\n\n    // Setze lichtzeiten wenn Kontrolle AKTIV \n    setLightTimes(startTime = \"\", endTime = \"\") {\n        if(!this.isPlantDay.lightbyOGBControl)return\n        if (startTime !== this.isPlantDay.lightOnTime || endTime !== this.isPlantDay.lightOffTime) {\n            this.isPlantDay.lightOnTime = startTime;\n            this.isPlantDay.lightOffTime = endTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${startTime}, Ende: ${endTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setLightTimes(startTime, endTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n\n            this.updateLightState(); // Aktualisiere den Lichtstatus\n        }\n    }\n    // Setze Sonnen Auf/Untergang \n    setSunTimes(sunRiseTime = \"\", sunSetTime = \"\") {\n        if (!this.isPlantDay.lightbyOGBControl) return\n        if (sunRiseTime !== this.isPlantDay.sunRiseTimes || sunSetTime !== this.isPlantDay.sunSetTimes) {\n            this.isPlantDay.sunRiseTimes = sunRiseTime;\n            this.isPlantDay.sunSetTimes = sunSetTime;\n\n            node.warn(`Aktualisierter Lichtzyklus: Start: ${sunRiseTime}, Ende: ${sunSetTime}`);\n            this.devices.forEach(device => {\n                if (device.deviceType === \"light\") {\n                    device.setSunTimes(sunRiseTime, sunSetTime); // Lichtzeiten an die Geräte übergeben\n                }\n            });\n        }\n    }\n\n\n    // HELPERS ******************************\n    helperYesTrue(input) {\n        if (typeof input === \"string\") {\n            // Convert string to boolean\n            const upperInput = input.toUpperCase(); // Normalize case\n            if (upperInput === \"YES\") return true;\n            if (upperInput === \"NO\") return false;\n        } else if (typeof input === \"boolean\") {\n            // Convert boolean to string\n            return input ? \"YES\" : \"NO\";\n        }\n        // Handle invalid input\n        throw new Error(\"Invalid input: expected a string ('YES'/'NO') or boolean (true/false).\");\n    }\n\n    // Aktualisierung des Lichtstatus basierend auf der aktuellen Zeit\n    updateLightState(currentTime = new Date()) {\n        // Hole die aktuelle Zeit in Sekunden\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        // Konvertiere Lichtzeiten in Sekunden\n        const lightOnSeconds = this.parseTime(this.isPlantDay.lightOnTime);\n        const lightOffSeconds = this.parseTime(this.isPlantDay.lightOffTime);\n\n        let lightOn;\n\n        if (lightOffSeconds < lightOnSeconds) {\n            // Lichtzyklus über Mitternacht: Licht an, wenn aktuelle Zeit nach Startzeit oder vor Endzeit\n            lightOn = currentSeconds >= lightOnSeconds || currentSeconds < lightOffSeconds;\n        } else {\n            // Lichtzyklus innerhalb eines Tages: Licht an, wenn aktuelle Zeit zwischen Start- und Endzeit\n            lightOn = currentSeconds >= lightOnSeconds && currentSeconds < lightOffSeconds;\n        }\n\n        // Setze den Lichtstatus in isPlantDay.lightOn\n        if (this.isPlantDay.lightOn !== lightOn) {\n            this.isPlantDay.lightOn = lightOn;\n\n            // Logge Änderungen für Debugging\n            node.warn(\n                `${this.tentName}: Lichtstatus aktualisiert - ${lightOn ? \"Licht AN\" : \"Licht AUS\"\n                } (Aktuelle Zeit: ${currentTime.toTimeString()}, On: ${this.isPlantDay.lightOnTime\n                }, Off: ${this.isPlantDay.lightOffTime})`\n            );\n\n            // Überprüfe, ob ein Lichtgerät vorhanden ist, und aktualisiere es\n        }\n    }\n\n    // Hilfsfunktion zur Zeitumrechnung (HH:MM:SS → Sekunden)\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n\n    /// DEVCIES ******************************\n    // Methode zum Abrufen der passenden Geräteklasse\n    getDeviceClass(deviceType) {\n        const deviceClasses = {\n            humidifier: Humidifier,\n            dehumidifier: Dehumidifier,\n            exhaustfan: ExhaustFan,\n            ventilation: Ventilation,\n            heater: Heater,\n            cooler: Cooler,\n            light: Light,\n            pump: Pump,\n            climate: Climate,\n            sensor: Sensor,\n        };\n\n        return deviceClasses[deviceType] || Device;\n    }\n\n    // Gerät direkt zur Instanz hinzufügen und in entities speichern\n    addDevice(deviceName,deviceData,context) {\n        const identifiedDevice = this.identifyDevice(deviceName, deviceData);\n        if (!identifiedDevice) {\n            node.error(`Failed to identify device: ${deviceName}`);\n            return;\n        }\n\n        // Daten initialisieren, falls nicht vorhanden\n        identifiedDevice.data = { ...deviceData };\n        identifiedDevice.setData(deviceData,context); // Gerätedaten setzen\n        this.devices.push(identifiedDevice); // Gerät zur Liste hinzufügen\n        this.registerDevices(identifiedDevice)\n        node.warn(`Added new device: ${deviceName}`);\n    }\n\n    // Geräte Identifizierung\n    identifyDevice(deviceName, deviceData) {\n        const deviceTypeMapping = {\n            \"sensor\": [\"mode\", \"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"h5179\"],\n            \"humidifier\": [\"humidifier\", \"mist\"],\n            \"dehumidifier\": [\"dehumidifier\", \"dry\", \"removehumidity\"],\n            \"exhaustfan\": [\"exhaust\", \"abluft\", \"ruck\"],\n            \"ventilation\": [\"vent\", \"vents\", \"venti\", \"ventilation\", \"inlet\", \"outlet\"],\n            \"heater\": [\"heater\", \"heizung\", \"warm\"],\n            \"cooler\": [\"cooler\", \"fan\", \"kühl\"],\n            \"light\": [\"light\", \"lamp\", \"led\", \"switch.light\"],\n            \"climate\": [\"klima\", \"climate\"],\n            \"co2\": [\"co2\", \"carbon\"],\n            \"pump\": [\"pump\", \"waterpump\", \"pumpe\"],\n            //\"sensor\": [\"sensor\", \"mode\",\"plant\", \"temperature\", \"temp\", \"humidity\", \"co2\", \"moisture\", \"dewpoint\", \"illuminance\", \"ppfd\", \"dli\", \"flower\", \"veggi\", \"vegi\", \"dutycycle\", \"duty\", \"h5179\"],\n        };\n\n        // Prüfen, ob der Gerätename einen bekannten Typ enthält\n        // Überprüfen des Gerätetyps\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (keywords.some(keyword => deviceName.toLowerCase().includes(keyword))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                node.warn(`Device ${deviceName} identified as ${deviceType}`);\n                return new DeviceClass(deviceName, deviceType, deviceData);\n            }\n        }\n\n        // Prüfen, ob deviceData Schlüssel enthält, die auf einen Typ hindeuten\n        const entityKeys = Object.keys(deviceData || {});\n        for (const [deviceType, keywords] of Object.entries(deviceTypeMapping)) {\n            if (entityKeys.some(key => keywords.some(keyword => key.toLowerCase().includes(keyword)))) {\n                const DeviceClass = this.getDeviceClass(deviceType);\n                return new DeviceClass(deviceName, deviceType); // Gerät erstellen\n            }\n        }\n\n        node.warn(`Device ${deviceName} not recognized, returning unknown device.`);\n        return new Device(deviceName, \"unknown\");\n    }\n    \n    // Registierung Caps ( noch nicht in nutzung)\n    registerDevices(device) {\n        // Sensoren ignorieren\n        if (device.deviceType.includes(\"sensor\")) return;\n        let capabilities\n        // Bestimme die Fähigkeiten des Geräts\n        capabilities = {\n            canHeat: device.deviceType === \"heater\" || device.deviceType === \"climate\" || device.deviceType === \"light\",\n            canCool: device.deviceType === \"cooler\" || device.deviceType === \"climate\",\n            canHumidify: device.deviceType === \"humidifier\",\n            canDehumidify: device.deviceType === \"dehumidifier\" || device.deviceType === \"climate\",\n            canVentilate: device.deviceType === \"ventilation\" ,\n            canExhaust: device.deviceType === \"exhaust\",\n            canLight: device.deviceType === \"light\",\n        };\n\n        // Entferne alle Fähigkeiten, die das Gerät nicht besitzt\n        capabilities = Object.fromEntries(\n            Object.entries(capabilities).filter(([key, value]) => value)\n        );\n\n        // Füge die bereinigten Fähigkeiten zum Gerät hinzu\n\n\n        // Füge das Gerät zum `registeredDevices`-Array hinzu\n        if (!this.devices) this.devices = [];\n        device.capabilities = { ...capabilities }\n\n        node.warn(`Device registered: ${device.name} with capabilities: ${Object.keys(capabilities).join(\", \")}`);\n    }\n\n    // Erhalte alle geräte \n    listDevices() {\n        return this.devices;\n    }\n    \n    // Gerät sperren\n    lockDevice(device, roomName) {\n        if (!device.isLocked) {\n            device.isLocked = true;\n            device.lockedFor = roomName;\n            this.updateDevice(device);\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät entsperren\n    unlockDevice(device) {\n        if (device.isLocked) {\n            device.isLocked = false;\n            device.lockedFor = \"\";\n            console.warn(`Gerät entsperrt: ${device.name}`);\n            return true;\n        }\n        console.warn(`Gerät war nicht gesperrt: ${device.name}`);\n        return false;\n    }\n\n    // Gerät ausleihen\n    borrowDevice(device, fromTent) {\n        if (this.lockDevice(device, fromTent)) {\n            const borrowedIndex = this.devices.findIndex(d => d.name === device.name);\n            if (borrowedIndex === -1) {\n                this.devices.push(device);\n            }\n            device.inRoomName = this.tentName; // Setze den Raumnamen des geliehenen Geräts\n            device.isfromAmbient = false; // Markiere, dass es nicht mehr von Ambient kommt\n            return true;\n        }\n        return false;\n    }\n\n    // Gerät aktualisieren\n    updateDevice(updatedDevice) {\n        const index = this.devices.findIndex(d => d.name === updatedDevice.name);\n        if (index !== -1) {\n            this.devices[index] = updatedDevice;\n        } else {\n            this.devices.push(updatedDevice);\n        }\n    }\n\n    // Gerät zurückgeben\n    returnDevice(device) {\n        if (this.unlockDevice(device)) {\n            // Entferne alle Instanzen des Geräts aus dem Array\n            device.action = \"off\";\n            device.mode = \"off\";\n            let offAction = device.turnOFF();\n            this.devices = this.devices.filter(d => d.name !== device.name);\n            console.warn(`Alle Instanzen von ${device.name} entfernt.`);\n\n            device.inRoomName = \"ambient\"; // Setze den Raumnamen zurück auf Ambient\n            device.isfromAmbient = true; // Markiere, dass es wieder zu Ambient gehört\n            device.action = \"off\";\n           node.warn(`OFF_Action_ROOM: ${JSON.stringify(offAction, null, 2)}`);\n            return offAction\n        }\n        console.warn(`Gerät konnte nicht entsperrt werden: ${device.name}`);\n        return false;\n    }\n\n\n    // Calc Funks ******************************\n    // Calc Dewpoint\n    calculateDewPoint(temperature = this.tentData.temperature, humidity = this.tentData.humidity) {\n        const temp = parseFloat(temperature);\n        const hum = parseFloat(humidity);\n        if (isNaN(temp) || isNaN(hum)) {\n            return \"unavailable\";\n        }\n\n        const a = 17.27;\n        const b = 237.7;\n\n        // Berechnung der Hilfsvariable γ(T, RH)\n        const gamma = (a * temp) / (b + temp) + Math.log(hum / 100);\n\n        // Berechnung des Taupunkts\n        const dewPoint = (b * gamma) / (a - gamma);\n        this.tentData.dewpoint = parseFloat(dewPoint.toFixed(2))\n        return parseFloat(dewPoint.toFixed(2));\n    }\n\n    // Calc Aktellen VPD ( Based TEMP-HUM-EAFTEMP)\n    calculateCurrentVPD(Temp = this.tentData.temperature, Humidity = this.tentData.humidity, LeafOffset = this.tentData.leafTempOffset) {\n        const temp = parseFloat(Temp);\n        const humidity = parseFloat(Humidity);\n        const leafTemp = parseFloat(Temp) - parseFloat(LeafOffset);\n\n        if (isNaN(temp) || isNaN(humidity) || isNaN(leafTemp)) {\n            return NaN;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * temp) / (temp + 237.3));\n        let sdpBlatt = 0.6108 * Math.exp((17.27 * leafTemp) / (leafTemp + 237.3));\n        let adp = (humidity / 100) * sdpLuft;\n        let vpd = sdpBlatt - adp;\n\n        this.vpd.current = parseFloat(vpd.toFixed(2));\n        return this.vpd.current;\n    }\n\n    // Calc Aktellen VPD Mittelwert aus aktuellen Plantstage min/max werten \n    calculatePerfectVPD(vpdRange = this.vpd.range) {\n        const averageVPD = (vpdRange[0] + vpdRange[1]) / 2;\n        this.vpd.perfection = parseFloat(averageVPD.toFixed(2));\n\n        this.vpd.perfectMin = parseFloat((this.vpd.perfection - this.vpd.perfectTolerance).toFixed(3));\n        this.vpd.perfectMax = parseFloat((this.vpd.perfection + this.vpd.perfectTolerance).toFixed(3));\n    }\n\n    // Berechne aus array/string/number/object den avg wert.\n    calculateAvgValue(temps = []) {\n        let sum = 0;\n        let count = 0;\n\n        // Prüfen, ob es ein Array von Zahlen ist oder ein Array von Objekten mit `value`\n        temps.forEach((entry) => {\n            let temp = parseFloat(entry.value);\n\n            if (!isNaN(temp)) {\n                sum += temp;\n                count++;\n            }\n        });\n\n        if (count === 0) {\n            return \"unavailable\";\n        }\n\n        const avg = sum / count;\n        return avg.toFixed(2);\n    }\n\n    // DRYING ******************************\n    // Setze aktuellen DryMode\n    setDryingMode(dryMode) {\n        if(this.tentMode !== \"Drying\")return\n        const normalizedMode = Object.keys(this.drying.modes).find(\n            mode => mode.toLowerCase() === dryMode.toLowerCase()\n        );\n\n        if (!normalizedMode) {\n            node.warn(`Ungültiger Trocknungsmodus: ${dryMode}. Standardmodus 'elClassico' wird verwendet.`);\n            this.drying.currentDryMode = \"elClassico\"; // Standardmodus setzen\n        } else {\n            this.drying.currentDryMode = normalizedMode;\n        }\n\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date)) {\n            this.setDryingStartTime();\n        }\n\n        this.drying.isEnabled = true;\n        this.drying.isRunning = true;\n        node.warn(`Trocknungsmodus aktiviert: ${this.drying.currentDryMode}`);\n    }\n\n    \n    // Erhalte aktulle DryPhase nach Zeitpunkt\n    getDryingPhase() {\n        // Sicherstellen, dass dryStartTime gültig ist\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            node.error(\"Startzeit ist ungültig. Setze Startzeit neu.\");\n            this.setDryingStartTime();\n        }\n\n        // Sicherstellen, dass ein gültiger Drying-Mode gesetzt ist\n        if (!this.drying.currentDryMode || !this.drying.modes.hasOwnProperty(this.drying.currentDryMode)) {\n            node.error(\"Kein gültiger Drying-Mode gesetzt! Setze Standardmodus 'elClassico'.\");\n            this.setDryingMode(\"elClassico\");\n        }\n\n        const startTimeInSeconds = Math.floor(this.dryStartTime.getTime() / 1000);\n        const nowInSeconds = Math.floor(Date.now() / 1000);\n        const elapsedSeconds = nowInSeconds - startTimeInSeconds;\n\n        node.warn(`Verstrichene Zeit: ${elapsedSeconds} Sekunden`);\n\n        // Phasen abrufen und in Sekunden umrechnen\n        const currentMode = this.drying.modes[this.drying.currentDryMode];\n        const { start, halfTime, endTime } = currentMode.phase;\n\n        const startDuration = start.durationHours * 3600;\n        const halfTimeDuration = halfTime.durationHours * 3600;\n        const endTimeDuration = endTime.durationHours * 3600;\n\n        if (elapsedSeconds < startDuration) return \"start\";\n        if (elapsedSeconds < startDuration + halfTimeDuration) return \"halfTime\";\n        if (elapsedSeconds < startDuration + halfTimeDuration + endTimeDuration) return \"endTime\";\n\n        node.warn(\"Trocknung abgeschlossen.\");\n        return \"completed\";\n    }\n\n\n\n\n    // Erhalte aktuellen DryMode\n    getDryingMode() {\n        return this.drying.currentDryMode\n    }\n    \n    // Setze Initale Zeit für DryZeitpunkt\n    setDryingStartTime() {\n        if (!this.dryStartTime || !(this.dryStartTime instanceof Date) || isNaN(this.dryStartTime.getTime())) {\n            this.dryStartTime = new Date(); // Erstelle gültiges Date-Objekt\n            node.warn(`Startzeit wurde gesetzt: ${this.dryStartTime.toISOString()}`);\n        }\n    }\n\n\n\n    // Berechne Wasseraktivität\n    calcWatteractiviy(humidity = this.tentData.humidity) {\n        let hum = parseFloat(humidity);\n\n        if (isNaN(hum)) {\n            console.error(\"Invalid humidity value. Water activity cannot be calculated.\");\n            this.drying.waterActivity = null; // Setze den Wert explizit auf null bei Fehler\n            return null;\n        }\n\n        let wa = hum / 100; // Wasseraktivität berechnet als Verhältnis von Luftfeuchtigkeit\n        this.drying.waterActivity = parseFloat(wa.toFixed(2)); // Auf zwei Dezimalstellen runden\n        return this.drying.waterActivity;\n    }\n\n    // Berechne DewPointVPD (Based on Dewpoint/TEMP)\n    calcDewVPD(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for VPD calculation.\");\n            this.drying.dryingVPD = null;\n            return null;\n        }\n\n        let sdpLuft = 0.6108 * Math.exp((17.27 * airTemp) / (airTemp + 237.3));\n        let adp = 0.6108 * Math.exp((17.27 * dewPoint) / (dewPoint + 237.3));\n\n        let dewVPD = sdpLuft - adp;\n        this.drying.dewpointVPD = parseFloat(dewVPD.toFixed(2)); // Rundet den VPD-Wert auf zwei Dezimalstellen\n        return this.drying.dewpointVPD;\n    }\n\n\n    // Setze Aktuelle Vapor Pressure Werte\n    calcDryingVPs(airTemp = this.tentData.temperature, dewPoint = this.tentData.dewpoint) {\n        airTemp = parseFloat(airTemp);\n        dewPoint = parseFloat(dewPoint);\n\n        if (isNaN(airTemp) || isNaN(dewPoint)) {\n            console.error(\"Invalid air temperature or dew point for vapor pressure calculation.\");\n            this.drying.vaporPressureActual = null;\n            this.drying.vaporPressureSaturation = null;\n            return null;\n        }\n\n        // Berechnung des tatsächlichen Dampfdrucks (ADP) am Taupunkt\n        let vaporPressureActual = 6.11 * Math.pow(10, (7.5 * dewPoint) / (237.3 + dewPoint));\n        this.drying.vaporPressureActual = parseFloat(vaporPressureActual.toFixed(2)); // Runden\n\n        // Berechnung des Sättigungsdampfdrucks (SDP) für Lufttemperatur\n        let vaporPressureSaturation = 6.11 * Math.pow(10, (7.5 * airTemp) / (237.3 + airTemp));\n        this.drying.vaporPressureSaturation = parseFloat(vaporPressureSaturation.toFixed(2)); // Runden\n\n        return {\n            vaporPressureActual: this.drying.vaporPressureActual,\n            vaporPressureSaturation: this.drying.vaporPressureSaturation,\n        };\n    }\n\n\n        //MODES ******************************\n        // MASTER MODE\n        ultraAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n            let action;\n            let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n\n            if (currentVPD < perfectVPD - tolerance) {\n                action = this.actions.Increased;\n            } else if (currentVPD > perfectVPD + tolerance) {\n                action = this.actions.Reduced;\n            }\n\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"Ultra Perfection\",\n                currentVPD: currentVPD,\n                targetVPD: perfectVPD,\n                vpdDiffPercent: vpdDiffPercent,\n                perfectMin: this.vpd.perfectMin,\n                perfectMax: this.vpd.perfectMax,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n        \n        // MITTEL wert ziel aus range vpd werten\n        perfectionAdjustments(currentVPD = this.vpd.current, perfectVPD = this.vpd.perfection, tolerance = this.vpd.perfectTolerance) {\n            let action;\n            let vpdDiffPercent = parseFloat((((currentVPD - perfectVPD) / perfectVPD) * 100).toFixed(2));\n\n            if (currentVPD < perfectVPD - tolerance) {\n                action = this.actions.Increased;\n            } else if (currentVPD > perfectVPD + tolerance) {\n                action = this.actions.Reduced;\n            }\n\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"VPD Perfection\",\n                currentVPD: currentVPD,\n                targetVPD: perfectVPD,\n                vpdDiffPercent: vpdDiffPercent,\n                perfectMin: this.vpd.perfectMin,\n                perfectMax: this.vpd.perfectMax,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n        \n        // Jumper zwishen min und max werten.\n        rangeAdjustments(currentVPD = this.vpd.current, targetVPDRange = this.vpd.range, tolerance = this.vpd.rangeTolerance) {\n            let action;\n            let vpdDiffPercent;\n\n            if (currentVPD < targetVPDRange[0] - tolerance) {\n                vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[0]) / targetVPDRange[0]) * 100).toFixed(2));\n                action = this.actions.Increased;\n            } else if (currentVPD > targetVPDRange[1] + tolerance) {\n                vpdDiffPercent = parseFloat((((currentVPD - targetVPDRange[1]) / targetVPDRange[1]) * 100).toFixed(2));\n                action = this.actions.Reduced;\n            }\n\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: \"VPD Range\",\n                currentVPD: currentVPD,\n                targetVPDMin: targetVPDRange[0],\n                targetVPDMax: targetVPDRange[1],\n                vpdDiffPercent: vpdDiffPercent,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n\n        // Targeted VPD Ziel mit Targed VPD\n        targetAdjustment(currentVPD = this.vpd.current, targetVPD = this.vpd.targeted, tolerance = this.vpd.targetedTolerance) {\n            let action;\n            let vpdDiffPercent = parseFloat((((currentVPD - targetVPD) / targetVPD) * 100)); // Korrektur der Berechnung\n\n            if (currentVPD < targetVPD + tolerance) {\n                action = this.actions.Increased;\n            } else if (currentVPD > targetVPD + tolerance) {\n                action = this.actions.Reduced;\n            }\n\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                currentVPD: currentVPD,\n                targetedVPD: targetVPD,\n                vpdDiffPercent: vpdDiffPercent,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n\n    // DryingModeChecks \n    dryAdjustments() {\n        if (!this.drying.isEnabled || !this.drying.isRunning) {\n            this.drying.isEnabled = true;\n            this.drying.isRunning = true;\n            this.setDryingStartTime();\n            node.warn(\"Trocknung gestartet und Status aktualisiert.\");\n        }\n\n        const currentPhase = this.getDryingPhase();\n        if (!currentPhase) {\n            node.error(\"Keine Phase berechnet, Startzeit fehlt.\");\n            return { error: \"Phase konnte nicht berechnet werden.\" };\n        }\n\n        if (currentPhase === \"completed\") {\n            node.warn(\"Trocknung abgeschlossen.\");\n            this.drying.isRunning = false;\n            return { status: \"completed\" };\n        }\n\n        // Wasseraktivität und VPD berechnen\n        const waterActivity = this.calcWatteractiviy(this.tentData.humidity);\n        const dewVPD = this.calcDewVPD(this.tentData.temperature, this.tentData.dewpoint);\n        const vapors = this.calcDryingVPs(this.tentData.temperature,this.tentData.dewpoint)\n        \n        node.warn(`CURRENTPHASE: ${currentPhase}`);\n\n        // Phase-spezifische Aktionen ausführen\n        switch (this.drying.currentDryMode) {\n            case \"elClassico\":\n                return this.dryElClassico(currentPhase);\n            case \"sharkMouse\":\n                return this.drySharkMouse(currentPhase);\n            case \"dewBased\":\n                return this.dryDewBased(currentPhase);\n            default:\n                node.error(\"Unbekannter Drying-Mode!\");\n                return { error: \"Unbekannter Drying-Mode\" };\n        }\n    }\n\n\n        \n        // DRYMODE Classic\n        dryElClassico(currentPhase) {\n            const phaseConfig = this.drying.modes.elClassico.phase[currentPhase];\n            const dryAction = this.actions.Unchanged; // Modus-spezifische Aktionen\n            node.warn(`Aktuelle Phase der Trocknung:, ${currentPhase}`);\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetHum: phaseConfig.targetHumidity,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction\n            };\n        }\n\n        // DRYMODE VPD Based\n        drySharkMouse(currentPhase) {\n            const phaseConfig = this.drying.modes.sharkMouse.phase[currentPhase];\n            const dryAction = this.actions.Unchanged; // Modus-spezifische Aktionen\n            node.warn(`Aktuelle Phase der Trocknung:, ${currentPhase}`);\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetHum: phaseConfig.targetHumidity,\n                    targetVPD: phaseConfig.targetVPD,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction\n            };\n        }\n\n        // DRYMODE DewPoint Based\n        dryDewBased(currentPhase) {\n            const phaseConfig = this.drying.modes.dewBased.phase[currentPhase];\n            const dryAction = this.actions.Unchanged; // Modus-spezifische Aktionen\n            node.warn(`Aktuelle Phase der Trocknung:, ${currentPhase}`);\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inDryMode: this.drying.currentDryMode,\n                startTime: this.dryStartTime?.toISOString() || \"Not Set\", // Startzeit hinzufügen\n                currentPhase,\n                targetValues: {\n                    targetTemp: phaseConfig.targetTemp,\n                    targetDewPoint: phaseConfig.targetDewPoint,\n                    targetDuration: phaseConfig.durationHours,\n                },\n                actions: dryAction\n            };\n        }\n\n        // EXPERIMENTEL\n        ecoAdjustments(currentVPD = this.vpd.current, ecoTarget = this.vpd.ecotarget) {\n            let action;\n            let vpdECOPercent;\n\n            if (currentVPD < ecoTarget[0]) {\n                vpdECOPercent = parseFloat((((currentVPD - ecoTarget[0]) / ecoTarget[0]) * 100).toFixed(2));\n                action = this.actions.Increased;\n            } else if (currentVPD > ecoTarget[1]) {\n                vpdECOPercent = parseFloat((((currentVPD - ecoTarget[1]) / ecoTarget[1]) * 100).toFixed(2));\n                action = this.actions.Reduced;\n            }\n\n            return {\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                currentVPD: currentVPD,\n                targetVPDMin: ecoTarget[0],\n                targetVPDMax: ecoTarget[1],\n                vpdDiffPercent: vpdECOPercent,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n        // NIGHTHOLD VPD OUTPUT\n        inDontCareMode() {\n            let action = {\n                exhaust: \"maximal\",\n                humidifier: \"Unchanged\",\n                dehumidifier: \"Unchanged\",\n                heater: \"Unchanged\",\n                cooler: \"Unchanged\",\n                ventilation: \"maximal\",\n                light: \"Unchanged\",\n                co2: \"Unchanged\",\n                climate: {\n                    cool: \"Unchanged\",\n                    dry: \"Unchanged\",\n                    heat: \"Unchanged\",\n                }\n\n            }\n            // NEED TO TEST ON LIGHT OFF PHASE\n            node.warn(`Ignore VPD on NightTime run minimal Actions`);\n            return {\n                tentName: this.tentName,\n                tentMode: \"I DONT CARE MODE\",\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity\n                },\n                actions: action\n            };\n        }\n        /// DISABELD \n        disabledMode() {\n            node.log(\"Disabled mode active\");\n            let action = {\n                exhaust: \"Unchanged\",\n                humidifier: \"Unchanged\",\n                dehumidifier: \"Unchanged\",\n                heater: \"Unchanged\",\n                cooler: \"Unchanged\",\n                ventilation: \"Unchanged\",\n                light: \"Unchanged\",\n                co2: \"Unchanged\",\n                climate: {\n                    cool: \"Unchanged\",\n                    dry: \"Unchanged\",\n                    heat: \"Unchanged\",\n                }\n\n            }\n            return {\n                TentName: this.tentName,\n                tentMode: this.tentMode,\n                actions: action,\n            };\n        }\n\n\n        /// ACTIONS ******************************\n        selectAction(context) {\n            let preparedDevices = []; // Speicher für Geräteaktionen\n            let actionData;\n            let limitAdjustments\n\n            // Prüfen, ob der Zustand seit der letzten Aktion unverändert ist\n            if (this.checkLastState()) {\n                    this.needchange = false;\n                    actionData = {\n                        tentName: this.tentName,\n                        tentMode: \"Unchanged\",\n                        currentVPD: this.vpd.current,\n                        Temps: {\n                            Temperature: this.tentData.temperature,\n                            MinTemperature: this.tentData.minTemp,\n                            MaxTemperature: this.tentData.maxTemp,\n                        },\n                        Humidities: {\n                            Humidity: this.tentData.humidity,\n                            MinHumidity: this.tentData.minHumidity,\n                            MaxHumidity: this.tentData.maxHumidity,\n                        },\n                        actions: this.actions.Unchanged,\n                        deviceActions: preparedDevices,\n                    };\n            } else {\n                this.needchange = true;           \n            }\n\n\n            // Modusabhängige Logik\n            if (this.needchange) {\n                switch (this.tentMode) {\n                    case \"VPD Perfection\":\n                        actionData = this.perfectionAdjustments(\n                            this.vpd.current,\n                            this.vpd.perfection,\n                            this.vpd.perfectTolerance\n                        );\n                        break;\n                    case \"IN-VPD-Range\":\n                        actionData = this.rangeAdjustments(\n                            this.vpd.current,\n                            this.vpd.range,\n                            this.vpd.rangeTolerance\n                        );\n                        break;\n                    case \"Targeted VPD\":\n                        actionData = this.targetAdjustment(\n                            this.vpd.current,\n                            this.vpd.targeted,\n                            this.vpd.targetedTolerance\n                        );\n                        break;\n                    case \"ECO-VPD\":\n                        actionData = this.ecoAdjustments(\n                            this.vpd.current,\n                            this.vpd.ecotarget,\n                        );\n                        break;\n                    case \"Drying\":\n                        actionData = this.dryAdjustments();\n                        break;\n                    case \"Disabled\":\n                        actionData = this.disabledMode();\n                        break;\n\n                    default:\n                        throw new Error(\"Unknown mode: \" + this.tentMode);\n                }\n\n                if (this.isPlantDay.lightOn === false && this.isPlantDay.nightVPDHold === false) {\n                    actionData = this.inDontCareMode()\n                }\n                \n            }\n\n            if(this.needchange){\n                limitAdjustments = this.checkLimits();\n            }\n            // Vorzeitige Anpassungen\n\n                // Kombiniere alle Aktionen\n            const finalActions = {\n            ...actionData.actions || null,\n            ...limitAdjustments || null,\n            };\n            //let absolutActions = this.evaluateDeviceEnvironment(finalActions)\n\n            this.devices.forEach((device) => {\n\n                // Prüfen, ob das Gerät korrekt initialisiert wurde\n                if (device.switches.length === 0) return\n                if (device && typeof device.prepareAction === \"function\") {\n                    if (device.deviceType === \"sensor\" || device.deviceType === \"pump\" || device.deviceType === \"co2\") return;\n                        \n                    device = device.prepareAction(finalActions);\n\n                    let actions = device.runAction(context)\n\n                    //node.warn(`FinalAction: ${JSON.stringify(actions, null, 2)}`);\n\n                    preparedDevices.push(actions)\n                    //preparedDevices.push(device)\n                } else {\n                    // Falls Gerät nicht korrekt initialisiert ist, Warnung ausgeben\n                    node.warn(`Device ${device?.name || \"undefined\"} konnte nicht verarbeitet werden.`);\n                }\n            });\n\n\n            // Aktion speichern\n            this.dataSetter({\n                ...actionData || null,\n                actions: finalActions || null,\n                devices: this.devices || null,\n                deviceActions: preparedDevices || null,\n            });\n\n            // Rückgabe der Aktion mit den angepassten Geräten\n            return {\n                ...actionData || null,\n                actions: finalActions || null,\n                devices: this.devices || null,\n                deviceActions: preparedDevices || null, \n            };\n        }\n        // Check min/max settins and do adjustments\n        checkLimits() {\n            let adjustments = {};\n            \n            if(this.tentMode === \"Drying\")return\n\n            if (!this.needchange) return adjustments\n\n            // Dynamische Gewichtung basierend auf Plant Stage\n            let humidityWeight, temperatureWeight;\n            \n            if(this.controls.ownWeights){\n                if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n                    humidityWeight = this.controls.weights.hum; \n                    temperatureWeight = this.controls.weights.temp;\n                } else {\n                    humidityWeight = this.controls.weights.hum; \n                    temperatureWeight = this.controls.weights.temp;\n                }   \n            }else{\n                if (this.plantStage === \"MidFlower\" || this.plantStage === \"LateFlower\") {\n        \n                    humidityWeight = 1.25 // In der Blütephase hat die Feuchtigkeit eine höhere Priorität\n                    temperatureWeight = 1.0; // Temperatur hat in diesen Phasen weniger Priorität\n                } else {\n                    humidityWeight = 1.0; // In anderen Phasen wie der Vegetationsphase ist die Temperatur leicht höher als Feuchtigkeit\n                    temperatureWeight = 1.0;\n                }\n            }\n\n            // Temperatur- und Feuchtigkeitsabweichungen berechnen\n            const tempDeviation = (this.tentData.temperature - this.tentData.maxTemp) * temperatureWeight;\n            const humDeviation = (this.tentData.humidity - this.tentData.maxHumidity) * humidityWeight;\n\n            // **Initialisiere climate innerhalb von adjustments**\n            adjustments.climate = {\n                cool: \"unchanged\",\n                heat: \"unchanged\",\n                dry: \"unchanged\",\n            };\n\n\n            // **1. Hohe Temperatur + Hohe Feuchtigkeit**\n            if (tempDeviation > 0 && humDeviation > 0) {\n                adjustments.dehumidifier = \"increased\"; // Feuchtigkeit reduzieren\n                adjustments.cooler = \"increased\"; // Temperatur senken\n                adjustments.exhaust = \"increased\"; // Abluft maximieren\n                adjustments.climate.cool = \"increased\";\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n            // node.warn(`${this.tentName} Fall: Hohe Temperatur + Hohe Feuchtigkeit`);\n\n                // **2. Hohe Temperatur + Niedrige Feuchtigkeit**\n            } else if (tempDeviation > 0 && humDeviation < 0) {\n                adjustments.humidifier = \"increased\"; // Feuchtigkeit erhöhen\n                adjustments.cooler = \"increased\"; // Temperatur senken\n                adjustments.exhaust = \"increased\"; // Abluft beibehalten oder erhöhen\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                adjustments.climate.cool = \"increased\";\n            // node.warn(`${this.tentName} Fall: Hohe Temperatur + Niedrige Feuchtigkeit`);\n\n                // **3. Niedrige Temperatur + Hohe Feuchtigkeit**\n            } else if (tempDeviation < 0 && humDeviation > 0) {\n                adjustments.dehumidifier = \"increased\"; // Feuchtigkeit reduzieren\n                adjustments.heater = \"increased\"; // Temperatur erhöhen\n                adjustments.exhaust = \"increased\"; // Abluft erhöhen, um Feuchtigkeit abzuführen\n                adjustments.climate.dry = \"increased\";\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Fall: Niedrige Temperatur + Hohe Feuchtigkeit`);\n\n                // **4. Niedrige Temperatur + Niedrige Feuchtigkeit**\n            } else if (tempDeviation < 0 && humDeviation < 0) {\n                adjustments.humidifier = \"increased\"; // Feuchtigkeit erhöhen\n                adjustments.heater = \"increased\"; // Temperatur erhöhen\n                adjustments.exhaust = \"reduced\"; // Abluft reduzieren, um Wärme und Feuchtigkeit zu halten\n                adjustments.climate.heat = \"increased\";\n                adjustments.ventilation = \"reduced\"; // Vents verringern\n                //node.warn(`${this.tentName} Fall: Niedrige Temperatur + Niedrige Feuchtigkeit`);\n            }\n\n            // **Zusätzliche Fälle**\n\n            // **5. Notfallmaßnahmen bei extremer Übertemperatur**\n            if (this.tentData.temperature > this.tentData.maxTemp + 5) {\n                adjustments.exhaust = \"maximum\"; // Maximale Abluft\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen            \n                adjustments.cooler = \"increased\";\n                adjustments.climate.cool = \"increased\";\n                adjustments.light = \"reduced\"; // Licht komplett ausschalten, um Wärme zu reduzieren\n            // node.warn(`${this.tentName} Kritische Übertemperatur! Notfallmaßnahmen aktiviert.`);\n            }\n\n            // **6. Notfallmaßnahmen bei extremer Untertemperatur**\n            if (this.tentData.temperature < this.tentData.minTemp - 5) {\n                adjustments.heater = \"maximum\"; // Maximale Heizung\n                adjustments.exhaust = \"reduced\"; // Abluft reduzieren, um Wärme zu halten\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen        \n                adjustments.climate.heat = \"increased\";\n            // node.warn(` ${this.tentName} Kritische Untertemperatur! Notfallmaßnahmen aktiviert.`);\n            }\n\n            // **7. Lichtsteuerung basierend auf Temperatur**\n            if (this.tentData.temperature > this.tentData.maxTemp && this.isPlantDay.lightOn) {\n                adjustments.light = \"reduced\"; // Lichtleistung reduzieren, um Wärme zu verringern\n            //node.warn(`${this.tentName} Lichtleistung reduziert aufgrund hoher Temperatur`);\n            }\n\n            // **8. CO₂-Management**\n            if (this.tentData.co2Level < 400) {\n                adjustments.co2 = \"increased\"; // CO₂ hinzufügen\n                adjustments.exhaust = \"minimum\"; // CO₂ halten\n                //node.warn(\"CO₂-Level zu niedrig, CO₂-Zufuhr erhöht\");\n            } else if (this.tentData.co2Level > 1200) {\n                adjustments.co2 = \"reduced\"; // CO₂-Zufuhr stoppen\n                adjustments.exhaust = \"increased\"; // CO₂ abführen\n                //node.warn(`${this.tentName} CO₂-Level zu hoch, Abluft erhöht`);\n            }\n\n            // **9. Taupunkt- und Kondensationsschutz**\n            if (this.tentData.dewpoint >= this.tentData.temperature - 1) {\n                adjustments.dehumidifier = \"increased\"; // Feuchtigkeit reduzieren\n                adjustments.exhaust = \"increased\"; // Abluft erhöhen\n                adjustments.climate.dry = \"increased\";\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Taupunkt erreicht, Feuchtigkeit reduziert`);\n            }\n\n            // **10. Nachtmodus (Licht aus, maximale Abluft)**\n            if (!this.isPlantDay.lightOn) {\n                adjustments.light = \"off\"; // Licht ausschalten\n                adjustments.exhaust = \"maximum\"; // Abluft auf max setzen\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Nachtmodus aktiv: Licht aus, Abluft erhöht`);\n            }\n\n            // **11. Sicherheitsfall: Abluft niemals reduzieren bei hoher Temperatur**\n            if (tempDeviation > 0) {\n                adjustments.exhaust = \"increased\"; // Abluft beibehalten oder erhöhen\n                adjustments.ventilation = \"maximum\" // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Sicherheit: Abluft erhöht, da Temperatur zu hoch`);\n            }\n\n            // **12. Feuchtigkeitsgrenzwerte beachten**\n            if (this.tentData.humidity < this.tentData.minHumidity) {\n                adjustments.humidifier = \"increased\"; // Feuchtigkeit erhöhen\n                adjustments.ventilation = \"increased\"\n            //node.warn(`${this.tentName} Feuchtigkeit unter Minimum: Luftbefeuchter aktiviert`);\n            } else if (this.tentData.humidity > this.tentData.maxHumidity) {\n                adjustments.dehumidifier = \"increased\"; // Feuchtigkeit reduzieren\n                adjustments.climate.dry = \"increased\";\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Feuchtigkeit über Maximum: Entfeuchter aktiviert`);\n            }\n\n            // **13. Temperaturgrenzwerte beachten**\n            if (this.tentData.temperature < this.tentData.minTemp) {\n                adjustments.heater = \"increased\"; // Temperatur erhöhen\n                adjustments.climate.heat = \"increased\";\n                adjustments.ventilation = \"reduced\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Temperatur unter Minimum: Heizung aktiviert`);\n            } else if (this.tentData.temperature > this.tentData.maxTemp) {\n                adjustments.cooler = \"increased\"; // Temperatur senken\n                adjustments.climate.cool = \"increased\";\n                adjustments.ventilation = \"increased\"; // Vents beibehalten oder erhöhen\n                //node.warn(`${this.tentName} Temperatur über Maximum: Kühler aktiviert`);\n            }\n\n            return adjustments;\n        }\n\n        // Experimentel ( use outsite and ambient data)\n        analyzeTrends(){\n            let trend = {\n                temperature: this.enviorment.outsiteTemp - this.enviorment.ambientTemp,\n                humidity: this.enviorment.outsiteHumidity - this.enviorment.ambientHumidity,\n            };\n\n            if (trend.temperature > 0) {\n                // Außentemperatur steigt -> Vorzeitig lüften\n                this.actionsIncreased.exhaust = \"preemptively increased\";\n            } else if (trend.temperature < 0) {\n                // Außentemperatur sinkt -> Lüftung reduzieren\n                this.actionsReduced.exhaust = \"preemptively reduced\";\n            }\n\n            if (trend.humidity > 0) {\n                // Außenfeuchtigkeit steigt -> Entfeuchter verstärken\n                this.actionsIncreased.dehumidifier = \"preemptively increased\";\n            } else if (trend.humidity < 0) {\n                // Außenfeuchtigkeit sinkt -> Befeuchter anpassen\n                this.actionsReduced.humidifier = \"preemptively reduced\";\n            }\n        }\n\n        // DATA SETTER FAKE DB ******************************\n        dataSetter(data) {\n            const time = new Date().toISOString();\n            const lastAction = this.previousActions[this.previousActions.length - 1];\n            // Definiere eine Schwelle für Änderungen\n            const vpdThreshold = 0.001;\n\n            if (this.tentMode === \"Unchanged\" || \"Disabled\" || \"I DONT CARE MODE\" ){\n                return\n            }\n\n\n            // Filter für aktive oder relevante Geräte\n            // Filter für aktive oder relevante Geräte\n            const relevantDevices = this.devices.filter(\n                (device) => (device.switches.length > 0) || device.isRunning\n            );\n\n\n            // Erstelle das Datenobjekt\n            const enrichedData = {\n                time,\n                tentName: this.tentName,\n                tentMode: this.tentMode,\n                inMode: data.inMode,\n                currentVPD: this.vpd.current,\n                targetVPDMin: this.vpd.range[0],\n                targetVPDMax: this.vpd.range[1],\n                vpdDiffPercent: data.vpdDiffPercent || 0,\n                Temps: {\n                    Temperature: this.tentData.temperature,\n                    MinTemperature: this.tentData.minTemp,\n                    MaxTemperature: this.tentData.maxTemp,\n                },\n                Humditys: {\n                    Humidity: this.tentData.humidity,\n                    MinHumidity: this.tentData.minHumidity,\n                    MaxHumidity: this.tentData.maxHumidity,\n                },\n                Dewpoint: this.tentData.dewpoint,\n                actions: data.actions,\n                Environment: {\n                    ambientTemp: this.enviorment.ambientTemp,\n                    ambientHumidity: this.enviorment.ambientHumidity,\n                    ambientDewpoint: this.enviorment.ambientDewpoint,\n                },\n                Outside: {\n                    outsiteTemp: this.enviorment.outsiteTemp,\n                    outsiteHumidity: this.enviorment.outsiteHumidity,\n                    outsiteDewpoint: this.enviorment.outsiteDewpoint,\n                },\n                devices: relevantDevices.map((device) => ({\n                    name: device.name,\n                    deviceType: device.deviceType,\n                    isRunning: device.isRunning,\n                    needChange: device.needChange,\n                    action: device.action,\n                    hasDuty: device.hasDuty,\n                    dutyCycle: device.dutyCycle,\n                    switches: device.switches,\n                    sensors: device.sensors,\n                    data: device.data,\n                })),\n                deviceActions: data.deviceActions\n            };\n\n            // Bedingung für signifikante Änderungen\n            const significantChange =\n                !lastAction ||\n                Math.abs(lastAction.currentVPD - this.vpd.current) > vpdThreshold ||\n                lastAction.targetVPDMin !== enrichedData.targetVPDMin ||\n                lastAction.targetVPDMax !== enrichedData.targetVPDMax ||\n                lastAction.Temps.Temperature !== enrichedData.Temps.Temperature ||\n                lastAction.Humditys.Humidity !== enrichedData.Humditys.Humidity ||\n                lastAction.Dewpoint !== enrichedData.Dewpoint;\n\n            if (significantChange) {\n                this.previousActions.push(enrichedData);\n                node.log(`Neue Aktion gespeichert:\", ${enrichedData}`);\n            } else {\n                node.log(\"Änderung nicht signifikant - Keine Aktion gespeichert.\");\n            }\n\n            // Begrenze die Anzahl der gespeicherten Aktionen\n            if (this.previousActions.length > 250) {\n                this.previousActions = this.previousActions.slice(-250);\n            }\n        }\n            // Check if action is needed to chagnes in vpd \n        checkLastState() {\n            if (this.previousActions.length === 0) return false;\n\n            const lastAction = this.previousActions[this.previousActions.length - 1];\n\n            // Prüfen, ob der aktuelle Zustand identisch mit dem letzten gespeicherten Zustand ist\n            if (lastAction && lastAction.currentVPD === this.vpd.current) {\n                node.log(\"VPD hat sich nicht geändert. Keine Aktion notwendig.\");\n                return true;\n            }\n\n            return false;\n        }\n}\n\nclass Device {\n    constructor(deviceName, deviceType = \"generic\") {\n        this.name = deviceName;\n        this.deviceType = deviceType;\n        this.isRunning = false;\n        this.isLocked = false\n        this.lockedFor = \"\"\n        this.needChange = false\n        this.inRoomName  = \"\"\n        this.isfromAmbient = false\n        this.action = \"\"\n        this.switches = [];\n        this.sensors = [];\n        this.data = {};\n\n    }\n\n    setData(data,context) {\n        this.setFromtent(context.tentName)\n        this.identifyIfFromAmbient()\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n    }\n\n    setFromtent(roomName){\n        if(roomName != this.inRoomName){\n            this.inRoomName = roomName\n        }\n    }\n\n    identifyIfFromAmbient() {\n        if (typeof this.inRoomName === \"string\" && \n            (this.inRoomName.toLowerCase().includes(\"ambient\"))) {\n            this.isfromAmbient = true;\n        } else {\n            this.isfromAmbient = false;\n        }\n    }\n\n    identifySwitchesAndSensors() {\n        if (!this.data || typeof this.data !== \"object\") return;\n\n        const keys = Object.keys(this.data);\n        this.switches = keys.filter((key) =>\n            key.startsWith(\"switch.\") || key.startsWith(\"light.\") || key.startsWith(\"fan.\") || key.startsWith(\"climate.\")\n        );\n        this.sensors = keys.filter((key) =>\n            key.startsWith(\"sensor.\") || key.startsWith(\"number.\") || key.startsWith(\"text.\") || key.startsWith(\"time.\")\n        );\n    }\n\n    updateIsRunningState() {\n        // Standardmäßig ist das Gerät nicht laufend\n        this.isRunning = false;\n\n        if (!this.data || typeof this.data !== \"object\") {\n            return;\n        }\n\n        // 1. Prüfen, ob ein Fan eingeschaltet ist\n        const fanKeys = Object.keys(this.data).filter((key) => key.startsWith(\"fan.\"));\n        if (fanKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }\n\n        // 2. Prüfen, ob ein Light eingeschaltet ist\n        const lightKeys = Object.keys(this.data).filter((key) => key.startsWith(\"light.\"));\n        if (lightKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }\n\n        // 3. Prüfen, ob eine Klimaanlage eingeschaltet ist\n        const climateKeys = Object.keys(this.data).filter((key) => key.startsWith(\"climate.\"));\n        if (climateKeys.some((key) => this.data[key] === \"on\")) {\n            this.isRunning = true;\n            return;\n        }\n\n        // 4. Prüfen, ob Switches eingeschaltet sind\n        if (Array.isArray(this.switches) && this.switches.length > 0) {\n            if (this.switches.some((switchKey) => this.data[switchKey] === \"on\")) {\n                this.isRunning = true;\n                return;\n            }\n        }\n\n        // 5. Prüfen, ob ein gültiger Duty-Cycle-Wert vorhanden ist\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"duty_cycle\") ||\n            key.toLowerCase().includes(\"dutycycle\") ||\n            key.toLowerCase().includes(\"duty\") ||\n            key.toLowerCase().includes(\"number.\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue) && dutyCycleValue > 0) {\n                this.isRunning = true;\n                return;\n            }\n        }\n\n        // 6. Prüfen, ob Sensor-Werte anzeigen, dass das Gerät läuft\n        if (Array.isArray(this.sensors) && this.sensors.length > 0) {\n            const sensorKey = this.sensors.find((key) =>\n                key.toLowerCase().includes(\"duty_cycle\") || key.toLowerCase().includes(\"dutycycle\") || key.toLowerCase().includes(\"duty\")\n            );\n            if (sensorKey && parseInt(this.data[sensorKey], 10) > 0) {\n                this.isRunning = true;\n                return;\n            }\n        }\n    }\n\n    prepareAction(finalActions) {\n        if (finalActions.hasOwnProperty(this.deviceType)) {\n            const actionValue = finalActions[this.deviceType];\n            //node.warn(`Climate Aciton Value: ${JSON.stringify(finalActions,actionValue)}`);\n            // Sonderfall für \"climate\" Geräte\n            if (this.deviceType === \"light\") {\n                // Spezielles Verhalten für \"light\"-Geräte\n                this.needChange = true;\n                this.action = actionValue;\n            } else if (this.deviceType === \"climate\"){\n                //node.warn(`IN Climate Aciton Value: ${JSON.stringify(finalActions, actionValue)}`);\n                if (finalActions.climate && typeof finalActions.climate === \"object\") {\n                    for (const [mode, action] of Object.entries(finalActions.climate)) {\n                        if (action !== \"unchanged\") {\n                            this.needChange = true;\n                            this.action = { mode, action }; // Speichere den gefundenen Modus und die Aktion\n                            break; // Beende die Schleife, sobald der erste gültige Wert gefunden wurde\n                        }\n                    }\n                } else {\n                    this.action = \"unchanged\"; // Standardwert, falls keine gültigen Climate-Aktionen vorhanden sind\n                }\n            } else{\n                // Standard-Verhalten für andere Gerätetypen\n                if (actionValue === \"unchanged\") {\n                    this.needChange = false;\n                    this.action = actionValue;\n                } else if (\n                    [\"maximum\", \"reduced\", \"increased\", \"minimum\", \"medium\", \"on\", \"off\"].includes(actionValue)\n                ) {\n                    this.needChange = true;\n                    this.action = actionValue;\n                }\n            }\n        } else {\n            // Falls keine Aktion definiert ist, logge Warnung\n            node.warn(`No actions defined for device type: ${this.deviceType}`);\n            this.needChange = false;\n            this.action = \"unchanged\";\n        }\n\n        // Debugging-Ausgabe zur Überprüfung der finalen Aktionen\n        //node.warn(`Prepared action for ${this.name}: ${JSON.stringify(this.action, null, 2)}, needChange: ${this.needChange}`);\n\n        return this;\n    }\n\n    evalAction() {\n        // Generische Prüfungen für alle Geräte\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        // Falls keine Änderung notwendig ist, abbrechen\n        if (this.needChange === false) return;\n        if (!this.evalAction()) {\n            return { Device: `${this.switches[0]}`, Action: \"noChangesNeeded\",State:\"unchanged\" };\n        }\n\n        //node.warn(`Running Action for ${this.name} in ${this.inRoomName} `);\n        //node.warn(`Action State:${this.action}`);\n\n\n        // Aktion: increased\n        if (this.action === \"increased\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(50);\n                        node.warn(`${this.name} Duty-Cycle wurde auf 50% gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle + 5}% erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle + 5); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n\n            // Aktion: reduced\n        } else if (this.action === \"reduced\") {\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät aus, falls es läuft\n                if (this.isRunning) {\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return this.turnOFF();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready OFF\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (this.dutyCycle === 5) {\n                    node.warn(`${this.name} ist auf Minimum gestellt in ${this.inRoomName} .`);\n                    node.warn(`${this.name} wurde ausgeschaltet in ${this.inRoomName} .`);\n                    return { entity_id: this.switches[0], action: \"Minium Reached\" }\n                } else {\n                    node.warn(`${this.name} Duty-Cycle wurde auf ${this.dutyCycle - 5}% reduziert in ${this.inRoomName} .`);\n                    return this.changeDuty(this.dutyCycle - 5); // Beispiel: Reduziere Duty-Cycle um 10%\n                }\n            }\n\n            // Aktion: unchanged\n        } else if (this.action === \"maximum\"){\n            if (!this.hasDuty) {\n                // Kein Duty-Modus: Schalte das Gerät ein, falls es nicht läuft\n                if (!this.isRunning) {\n                    node.warn(`${this.name} wurde eingeschaltet in ${this.inRoomName} .`);\n                    return this.turnON();\n                } else {\n                    return { entity_id: this.switches[0], action: \"Allready ON\" }\n                }\n            } else {\n                // Duty-Modus: Verwalte Duty-Cycle\n                if (!this.isRunning) {\n                    if (this.dutyCycle === 0) {\n                        this.setDutyCycle(100);\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX %gesetzt und eingeschaltet in ${this.inRoomName} .`);\n                        return this.changeDuty(this.dutyCycle);\n                    }\n                } else {\n                    if (this.dutyCycle === 95) {\n                        node.warn(`${this.name} läuft bereits auf maximalem Duty-Cycle in ${this.inRoomName} .`);\n                        return { entity_id: this.switches[0], action: \"Max Reached\" }\n                    } else {\n                        node.warn(`${this.name} Duty-Cycle wurde auf MAX % erhöht in ${this.inRoomName} .`);\n                        return this.changeDuty(100); // Beispiel: Erhöhe Duty-Cycle um 10%\n                    }\n                }\n\n            }\n        } else if (this.action === \"minimum\") {\n\n        } else if (this.action === \"unchanged\") {\n            //node.warn(`${this.name} bleibt unverändert.`);\n            return { entity_id: this.switches[0], action: \"UNCHANGED\" }\n            // Fehlerfall\n        } else {\n            node.warn(`Etwas Ungewöhnliches ist passiert: ${this.name} hat eine unbekannte Aktion. Bitte Support kontaktieren.`);\n\n        }\n    }\n\n    turnOFF() {\n        let enitiy = this.switches[0]\n        if (this.isRunning === true) {\n            this.isRunning = false\n            return { \"entity_id\": enitiy, \"action\": \"off\" }\n        }\n\n    }\n\n    turnON() {\n        let enitiy = this.switches[0]\n        if (this.isRunning == false) {\n            this.isRunning = true\n            return { \"entity_id\": enitiy, \"action\": \"on\" }\n        }\n\n    }\n}\n\nclass ExhaustFan extends Device {\n    constructor(name, dutyCycle = 0) {\n        super(name, \"exhaust\");\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        this.minDuty = 10;\n        this.maxDuty = 95;\n        this.hasDuty = false;\n        this.isRuckEC = false;\n        this.init();\n    }\n\n    init() {\n        this.findDutyCycle();\n        this.identifyIfRuckEC();\n    }\n\n    clampDutyCycle(dutyCycle) {\n        return Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycle));\n    }\n\n    identifyIfRuckEC() {\n        this.isRuckEC = this.name.toLowerCase().includes(\"ruck\");\n        if (this.isRuckEC) {\n            node.warn(`${this.name}: Gerät als RuckEC erkannt.`);\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            this.dutyCycle = this.minDuty;\n            this.hasDuty = false;\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\") ||\n            key.toLowerCase().includes(\"duty_cycle\") ||\n            key.toLowerCase().includes(\"duty\") ||\n            key.toLowerCase().includes(\"number.\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = this.clampDutyCycle(dutyCycleValue);\n                this.hasDuty = true;\n                node.warn(`${this.name}: Duty Cycle gesetzt auf ${this.dutyCycle}%.`);\n            } else {\n                node.warn(`${this.name}: Ungültiger Duty Cycle-Wert. Setze auf ${this.minDuty}%.`);\n                this.dutyCycle = this.minDuty;\n            }\n        } else {\n            node.warn(`${this.name}: Kein Duty Cycle-Schlüssel gefunden.`);\n            this.dutyCycle = this.minDuty;\n        }\n    }\n\n    setDutyCycle(dutyCycle) {\n        this.dutyCycle = this.clampDutyCycle(dutyCycle);\n        node.warn(`${this.name}: Duty Cycle auf ${this.dutyCycle}% gesetzt.`);\n        return this.dutyCycle;\n    }\n\n    changeDuty(duty) {\n        const clampedDuty = this.clampDutyCycle(duty);\n        this.dutyCycle = clampedDuty;\n\n        if (this.switches?.[0]) {\n            const switchId = this.switches[0];\n            node.warn(`${this.name}: Duty Cycle an Switch ${switchId} gesendet.`);\n            return { entity_id: switchId, action: \"dutycycle\", dutycycle: clampedDuty };\n        } else {\n            node.warn(`${this.name}: Kein Switch verfügbar.`);\n            return { error: \"No switch available\" };\n        }\n    }\n\n    runAction(context) {\n        if (!this.needChange) {\n            return { ExhaustFan: `${this.name}`, Action: \"NoChangeNeeded\" };\n        }\n\n        const switchId = this.switches?.[0];\n        if (!switchId) {\n            node.warn(`${this.name}: Kein Switch verfügbar.`);\n            return { error: \"No switch available\" };\n        }\n\n        switch (this.action) {\n            case \"maximum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.maxDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"minimum\":\n                if (this.hasDuty) {\n                    return this.changeDuty(this.minDuty);\n                } else {\n                    return this.turnON(switchId);\n                }\n            case \"increased\":\n                if(this.hasDuty){\n                    const increasedDuty = Math.min(this.dutyCycle + 5, this.maxDuty);\n                    return this.changeDuty(increasedDuty);\n                }else{\n                    return this.turnON(switchId);\n                }\n            case \"reduced\":\n                if(this.hasDuty){\n                    const reducedDuty = Math.max(this.dutyCycle - 5, this.minDuty);\n                    return this.changeDuty(reducedDuty);\n                }else{\n                    return this.turnOFF(switchId);\n                }\n\n\n            case \"on\":\n                return this.turnON(switchId);\n\n            case \"off\":\n                return this.turnOFF(switchId);\n\n            case \"unchanged\":\n                return { entity_id: switchId, action: \"UNCHANGED\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { ExhaustFan: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Lüfter eingeschaltet.`);\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Lüfter ausgeschaltet.`);\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n}\n\nclass Ventilation extends Device {\n    constructor(name) {\n        super(name, \"ventilation\");\n        this.dutyCycle = 0; // Duty Cycle für Lüftung\n        this.dutyMin = 50; // Mindestwert für Duty Cycle\n        this.dutyMax = 100; // Maximalwert für Duty Cycle\n        this.hasDuty = false;\n        this.isTasmota = false;\n        this.init(); // Initialisierungsmethode aufrufen\n    }\n\n    init() {\n        this.findDutyCycle(); // Duty Cycle initialisieren\n\n        if (this.dutyCycle < this.dutyMin) {\n            node.warn(`${this.name}: Duty Cycle unter Mindestwert. Setze auf ${this.dutyMin}%.`);\n            this.dutyCycle = this.dutyMin;\n        }\n\n        this.identifyIfTasmota();\n    }\n\n    identifyIfTasmota() {\n        if (Array.isArray(this.switches)) {\n            this.isTasmota = this.switches.some(\n                (switchDevice) => typeof switchDevice === \"string\" && switchDevice.startsWith(\"light.\")\n            );\n\n            if (this.isTasmota) {\n                this.hasDuty = true;\n                if (this.isRunning && this.dutyCycle < this.dutyMin) {\n                    this.dutyCycle = this.dutyMin;\n                    node.warn(`Tasmota-Ventilation initialisiert mit ${this.dutyCycle}% DutyCycle.`);\n                }\n            }\n        } else {\n            node.warn(`${this.name}: Keine gültigen Switches gefunden.`);\n        }\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            this.dutyCycle = this.dutyMin; // Fallback auf Mindestwert\n            this.hasDuty = false;\n            return;\n        }\n\n        if (this.isTasmota) return; // Ignoriere Tasmota-Geräte\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            key.toLowerCase().includes(\"dutycycle\")\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseInt(this.data[dutyCycleKey], 10);\n            if (!isNaN(dutyCycleValue)) {\n                this.dutyCycle = Math.max(this.dutyMin, Math.min(this.dutyMax, dutyCycleValue));\n                this.hasDuty = true;\n                node.warn(`${this.name}: Duty Cycle gesetzt auf ${this.dutyCycle}%.`);\n            } else {\n                node.warn(`${this.name}: Ungültiger Duty Cycle-Wert. Setze auf ${this.dutyMin}%.`);\n                this.dutyCycle = this.dutyMin;\n            }\n        } else {\n            node.warn(`${this.name}: Kein Duty Cycle-Schlüssel gefunden. Setze auf ${this.dutyMin}%.`);\n            this.dutyCycle = this.dutyMin;\n        }\n    }\n\n    setDutyCycle(dutyCycle) {\n        const clampedDuty = Math.max(this.dutyMin, Math.min(this.dutyMax, dutyCycle));\n        this.dutyCycle = clampedDuty;\n        return clampedDuty;\n    }\n\n    changeDuty(switchId, duty) {\n        this.setDutyCycle(duty);\n        return { entity_id: switchId, action: \"dutycycle\", dutycycle: this.dutyCycle };\n    }\n\n    runAction(context) {\n        if (!this.needChange) return { Ventilation: `${this.switches[0]}`, Action: \"NoChangeNeeded\" };\n\n        const results = [];\n        const applyActionToSwitches = (actionCallback) => {\n            return this.switches.map((switchId) => {\n                const result = actionCallback(switchId);\n                results.push(result);\n                return result;\n            });\n        };\n\n        switch (this.action) {\n            case \"maximum\":\n                node.warn(`${this.name}: Duty Cycle auf Maximum (${this.dutyMax}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMax));\n\n            case \"minimum\":\n                node.warn(`${this.name}: Duty Cycle auf Minimum (${this.dutyMin}%) gesetzt.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, this.dutyMin));\n\n            case \"reduced\":\n                const reducedDuty = Math.max(this.dutyCycle - 5, this.dutyMin);\n                node.warn(`${this.name}: Duty Cycle reduziert auf ${reducedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, reducedDuty));\n\n            case \"increased\":\n                const increasedDuty = Math.min(this.dutyCycle + 5, this.dutyMax);\n                node.warn(`${this.name}: Duty Cycle erhöht auf ${increasedDuty}%.`);\n                return applyActionToSwitches((switchId) => this.changeDuty(switchId, increasedDuty));\n\n            case \"on\":\n                return applyActionToSwitches((switchId) => this.turnON(switchId));\n\n            case \"off\":\n                return applyActionToSwitches((switchId) => this.turnOFF(switchId));\n\n            case \"unchanged\":\n                node.warn(`${this.name}: Keine Änderung erforderlich.`);\n                return applyActionToSwitches((switchId) => ({ entity_id: switchId, action: \"UNCHANGED\" }));\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Ventilation: `${this.switches[0]}`, Action: \"UnknownAction\" };\n        }\n    }\n\n    turnOFF(switchId) {\n        if (this.isRunning) {\n            this.isRunning = false;\n            return { entity_id: switchId, action: \"off\" };\n        }\n        return { entity_id: switchId, action: \"Already OFF\" };\n    }\n\n    turnON(switchId) {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            return { entity_id: switchId, action: \"on\" };\n        }\n        return { entity_id: switchId, action: \"Already ON\" };\n    }\n}\n\nclass Climate extends Device {\n    constructor(name) {\n        super(name, \"climate\");\n        this.currentHAVOC = \"off\"; // Standardzustand\n        this.havocs = {\n            dry: \"dry\",\n            cool: \"cool\",\n            hot: \"hot\",\n            heat: \"heat\",\n            wind: \"wind\",\n            off: \"off\",\n        };\n        this.isRunning = false; // Status der Klimaanlage\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.identifyCurrentHavoc();\n    }\n\n    identifyCurrentHavoc() {\n        const havocDevice = this.switches[0];\n        if (!havocDevice) {\n            console.warn(`${this.name}: Keine Switches definiert, um HAVOC zu identifizieren.`);\n            return;\n        }\n\n        const havocValue = this.data[havocDevice];\n\n        if (havocValue && Object.values(this.havocs).includes(havocValue)) {\n            this.currentHAVOC = havocValue;\n            console.warn(`${this.name}: HAVOC-Modus gesetzt auf \"${this.currentHAVOC}\".`);\n        } else {\n            console.warn(`${this.name}: Ungültiger HAVOC-Wert \"${havocValue}\", Standardwert \"off\" wird verwendet.`);\n        }\n    }\n\n    runAction() {\n        if (!this.needChange || !this.action || typeof this.action !== \"object\") {\n            console.warn(`${this.name}: Keine Änderungen erforderlich.`);\n            return null;\n        }\n\n        const { mode, action } = this.action;\n        const lowerMode = mode.toLowerCase(); // Konvertiere in Kleinbuchstaben\n        const validMode = this.havocs[lowerMode]; // Vergleiche mit `havocs` Mapping\n\n        console.warn(`Aktion empfangen: Mode = \"${mode}\", Action = \"${action}\", ValidMode = \"${validMode}\", CurrentHAVOC = \"${this.currentHAVOC}\"`);\n\n        // Prüfen, ob der Modus ungültig ist\n        if (!validMode) {\n            console.warn(`${this.name}: Ungültiger Modus \"${mode}\" erhalten. Standardwert \"off\" wird verwendet.`);\n            return { entity_id: this.switches[0], action: \"invalid_mode\", received_mode: mode };\n        }\n\n        // Prüfen, ob der Modus bereits läuft\n        if (this.isRunning && this.currentHAVOC.toLowerCase() === validMode) {\n            console.warn(`${this.name}: Keine Änderungen notwendig. Der Modus \"${validMode}\" ist bereits aktiv.`);\n            return { entity_id: this.switches[0], action: \"AllReady_ON\", climate_mode: this.currentHAVOC };\n        }\n\n        if (action === \"off\") {\n            return this.turnOFF();\n        }\n\n        if (!this.isRunning) {\n            return this.turnON(validMode);\n        }\n\n        return this.changeMode(validMode);\n    }\n\n    turnON(mode) {\n        this.isRunning = true;\n        if(this.currentHAVOC !== mode){\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        }else{\n            return { entity_id: this.switches[0], action: \"AllReady_Running\", climate_mode: mode };\n        }\n\n    }\n\n    turnOFF() {\n        if (this.isRunning) {\n            const previousMode = this.currentHAVOC;\n            this.isRunning = false;\n            this.currentHAVOC = \"off\";\n            return { entity_id: this.switches[0], action: \"off\", previous_mode: previousMode };\n        }\n        return { entity_id: this.switches[0], action: \"already_off\" };\n    }\n\n    changeMode(mode) {\n        \n        if(this.currentHAVOC !== mode){\n            this.currentHAVOC = mode;\n            return { entity_id: this.switches[0], action: \"climate\", climate_mode: mode };\n        }else{\n            return { entity_id: this.switches[0], action: \"AllReady_OFF\", climate_mode: mode };\n        }\n\n    }\n}\n\nclass Light extends Device {\n    constructor(name) {\n        super(name, \"light\");\n        this.hasDuty = false;\n        this.dutyCycle = null;\n        this.minDuty = 20;\n        this.maxDuty = 100;\n        this.stepSize = 1; // Schrittweite für Änderungen\n        this.sunRiseTime = \"\";\n        this.sunSetTime = \"\";\n        this.lightOnTime = \"\"; // Startzeit des Lichts\n        this.lightOffTime = \"\"; // Endzeit des Lichts\n        this.isScheduled = false; // Ob das Licht Zeitpläne berücksichtigt\n        this.currentPlantPhase = {\n            min: 0,\n            max: 0,\n        };\n        this.PlantStageMinMax = {\n            Germ: {\n                min: 20,\n                max: 30,\n            },\n            Veg: {\n                min: 20,\n                max: 50,\n            },\n            Flower: {\n                min: 50,\n                max: 100,\n            },\n        };\n        this.init();\n    }\n\n    init() {\n        this.findDutyCycle(); // Initialisiere den Duty-Cycle, falls vorhanden\n    }\n\n    findDutyCycle() {\n        if (!this.data) {\n            node.warn(`${this.name}: Keine Gerätedaten gefunden.`);\n            return;\n        }\n\n        const dutyCycleKey = Object.keys(this.data).find((key) =>\n            [\"dutycycle\", \"number.\", \"duty\", \"light.\"].some((term) => key.toLowerCase().includes(term))\n        );\n\n        if (dutyCycleKey) {\n            const dutyCycleValue = parseFloat(this.data[dutyCycleKey]);\n            if (!isNaN(dutyCycleValue)) {\n                const clampedValue = Math.max(this.minDuty, Math.min(this.maxDuty, dutyCycleValue));\n                this.dutyCycle = clampedValue;\n                this.hasDuty = true;\n                node.warn(`${this.name}: Duty-Cycle gesetzt auf ${this.dutyCycle} (aus Schlüssel '${dutyCycleKey}')`);\n            } else {\n                this.hasDuty = false;\n                node.warn(`${this.name}: Ungültiger Duty-Cycle-Wert (${this.data[dutyCycleKey]})`);\n            }\n        } else {\n            this.hasDuty = false;\n            node.warn(`${this.name}: Kein Duty-Cycle-Schlüssel gefunden.`);\n        }\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.setCurrenPlantPhaseName(context);\n        this.setLightTimes(context);\n        this.setSunTimes(context.isPlantDay.sunRiseTimes, context.isPlantDay.sunSetTimes);\n    }\n\n    setCurrenPlantPhaseName(context) {\n        if (!context) return;\n        if (context.plantStage !== this.currentPlantPhase) {\n            this.currentPlantPhase = context.plantStage;\n            this.setForPlantLightPhase();\n        }\n    }\n\n    setForPlantLightPhase() {\n        const phase = this.currentPlantPhase;\n        if (phase.includes(\"Germination\") || phase.includes(\"Clones\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Germ };\n        } else if (phase.includes(\"Veg\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Veg };\n        } else if (phase.includes(\"Flower\")) {\n            this.currentPlantPhase = { ...this.PlantStageMinMax.Flower };\n        }\n        this.minDuty = this.currentPlantPhase.min;\n        this.maxDuty = this.currentPlantPhase.max;\n    }\n\n    setLightTimes(context) {\n        if (!context) return;\n        const { lightOnTime, lightOffTime } = context.isPlantDay || {};\n        this.lightOnTime = lightOnTime;\n        this.lightOffTime = lightOffTime;\n\n        if (this.lightOnTime && this.lightOffTime !== \"\") {\n            this.isScheduled = true;\n        }\n    }\n\n    setSunTimes(sunRiseTime, sunSetTime) {\n        if (sunRiseTime || sunSetTime !== \"\") {\n            this.sunRiseTime = sunRiseTime;\n            this.sunSetTime = sunSetTime;\n        }\n    }\n\n    parseTime(timeString) {\n        const [hours, minutes, seconds = 0] = timeString.split(\":\").map(Number);\n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    runAction(context) {\n        if (!this.lightOnTime || !this.lightOffTime) {\n            node.warn(`${this.name}: Lichtzeiten fehlen. Keine Aktion durchgeführt.`);\n            return { Light: `${this.switches[0]}`, Action: \"NoLightTimesSet\", Status: this.isRunning };\n        }\n\n        const currentTime = new Date();\n        const currentSeconds = this.parseTime(currentTime.toTimeString().split(\" \")[0]);\n\n        // Sonnenaufgang und Sonnenuntergang prüfen\n        const sunRiseSeconds = this.parseTime(this.sunRiseTime);\n        const sunSetSeconds = this.parseTime(this.sunSetTime);\n\n        if (currentSeconds >= sunRiseSeconds && currentSeconds < sunSetSeconds) {\n            // Sonnenaufgang: Duty-Cycle von minDuty auf maxDuty erhöhen\n            const sunriseDuration = sunSetSeconds - sunRiseSeconds;\n            const elapsed = currentSeconds - sunRiseSeconds;\n            const dutyIncrement = (elapsed / sunriseDuration) * (this.maxDuty - this.minDuty);\n            const newDuty = Math.min(this.maxDuty, this.minDuty + dutyIncrement);\n            this.changeDuty(newDuty);\n        } else if (currentSeconds >= sunSetSeconds || currentSeconds < sunRiseSeconds) {\n            // Sonnenuntergang: Duty-Cycle von maxDuty auf minDuty reduzieren\n            const sunsetDuration = (24 * 3600 - sunSetSeconds) + sunRiseSeconds; // Über Mitternacht\n            const elapsed = currentSeconds >= sunSetSeconds\n                ? currentSeconds - sunSetSeconds\n                : 24 * 3600 - sunSetSeconds + currentSeconds;\n            const dutyDecrement = (elapsed / sunsetDuration) * (this.maxDuty - this.minDuty);\n            const newDuty = Math.max(this.minDuty, this.maxDuty - dutyDecrement);\n            this.changeDuty(newDuty);\n        }\n\n        // Lichtsteuerung basierend auf Zeitplan\n        const startTime = this.parseTime(this.lightOnTime);\n        const endTime = this.parseTime(this.lightOffTime);\n\n        let isLightOn;\n        if (endTime < startTime) {\n            isLightOn = currentSeconds >= startTime || currentSeconds <= endTime;\n        } else {\n            isLightOn = currentSeconds >= startTime && currentSeconds <= endTime;\n        }\n\n        if (isLightOn !== this.isRunning) {\n            this.isRunning = isLightOn;\n            this.action = isLightOn ? \"on\" : \"off\";\n        } else {\n            this.action = \"unchanged\";\n        }\n\n        switch (this.action) {\n            case \"on\":\n                return this.turnON();\n\n            case \"off\":\n                return this.turnOFF();\n\n            case \"unchanged\":\n                //node.warn(`${this.name}: Keine Änderung erforderlich, Lichtstatus bleibt ${this.isRunning ? \"AN\" : \"AUS\"} in ${this.inRoomName}.`);\n                return { Light: `${this.switches[0]}`, Action: \"NoChange\", Status: this.isRunning };\n\n            case \"increased\":\n                if (this.hasDuty && this.isRunning) {\n                    const newDuty = Math.min(this.maxDuty, this.dutyCycle + this.stepSize);\n                    return this.changeDuty(newDuty);\n                }\n                break;\n\n            case \"reduced\":\n                if (this.hasDuty && this.isRunning) {\n                    const newDuty = Math.max(this.minDuty, this.dutyCycle - this.stepSize);\n                    return this.changeDuty(newDuty);\n                }\n                break;\n\n            case \"minimum\":\n                if (this.hasDuty && this.isRunning) {\n                    return this.changeDuty(this.minDuty);\n                }\n                break;\n\n            case \"maximum\":\n                if (this.hasDuty && this.isRunning) {\n                    return this.changeDuty(this.maxDuty);\n                }\n                break;\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Light: `${this.switches[0]}`, Action: \"UnknownAction\", Status: this.isRunning };\n        }\n    }\n\n    changeDuty(newDuty) {\n        if (this.hasDuty === false) return { entity_id: this.switches[0], action: \"NoDutyCycle\" };\n        const clampedDuty = Math.max(this.minDuty, Math.min(this.maxDuty, newDuty));\n        this.dutyCycle = clampedDuty;\n        const entity = this.switches[0];\n        node.warn(`${this.name}: Duty-Cycle geändert auf ${clampedDuty}%.`);\n        return { entity_id: entity, action: \"dutycycle\", dutycycle: clampedDuty };\n    }\n\n    turnON() {\n        const entity = this.switches[0];\n        this.isRunning = true;\n        node.warn(`${this.name}: Licht wurde eingeschaltet.`);\n        return { entity_id: entity, action: \"on\" };\n    }\n\n    turnOFF() {\n        const entity = this.switches[0];\n        this.isRunning = false;\n        node.warn(`${this.name}: Licht wurde ausgeschaltet.`);\n        return { entity_id: entity, action: \"off\" };\n    }\n}\n\n//NEED TO TEST THIS \nclass Humidifier extends Device {\n    constructor(name) {\n        super(name, \"humidifier\");\n        this.isRunning = false; // Status des Befeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n    }\n\n    init() {\n        this.identifySwitchesAndSensors();\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data }; // Aktualisiere die Gerätedaten\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n    }\n\n    evalAction() {\n        return this.action !== \"unchanged\"; // Nur Änderung erforderlich, wenn Aktion nicht \"unchanged\" ist\n    }\n\n    runAction(context) {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF(context);\n            case \"on\":\n                return this.turnON(context);\n            case \"maximum\":\n                return this.setHumidityLevel(context, this.maxHumidity);\n            case \"minimum\":\n                return this.setHumidityLevel(context, this.minHumidity);\n            case \"increased\":\n                return this.changeHumidity(context, this.stepSize);\n            case \"reduced\":\n                return this.changeHumidity(context, -this.stepSize);\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON(context) {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftbefeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF(context) {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftbefeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    setHumidityLevel(context, level) {\n        const entity = this.switches[0];\n        this.currentHumidity = level;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${level}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: level };\n    }\n\n    changeHumidity(context, delta) {\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            node.warn(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        node.warn(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: newHumidity };\n    }\n}\n\nclass Dehumidifier extends Device {\n    constructor(name) {\n        super(name, \"dehumidifier\");\n        this.isRunning = false; // Status des Luftentfeuchters\n        this.currentHumidity = 0; // Aktueller Feuchtigkeitswert\n        this.minHumidity = 30; // Standard-Mindestfeuchtigkeit\n        this.maxHumidity = 70; // Standard-Maximalfeuchtigkeit\n        this.stepSize = 5; // Schrittweite für Änderungen\n    }\n\n    init() {\n        this.identifySwitchesAndSensors();\n    }\n\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data }; // Aktualisiere die Gerätedaten\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n    }\n\n    evalAction() {\n        return this.action !== \"unchanged\"; // Nur Änderung erforderlich, wenn Aktion nicht \"unchanged\" ist\n    }\n\n    runAction(context) {\n        if (!this.needChange) {\n            return { entity_id: this.switches[0], action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"off\":\n                return this.turnOFF(context);\n            case \"on\":\n                return this.turnON(context);\n            case \"maximum\":\n                return this.setHumidityLevel(context, this.maxHumidity);\n            case \"minimum\":\n                return this.setHumidityLevel(context, this.minHumidity);\n            case \"increased\":\n                return this.changeHumidity(context, this.stepSize);\n            case \"reduced\":\n                return this.changeHumidity(context, -this.stepSize);\n            case \"unchanged\":\n                return { entity_id: this.switches[0], action: \"UNCHANGED\" };\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion \"${this.action}\".`);\n                return { entity_id: this.switches[0], action: \"Unknown Action\" };\n        }\n    }\n\n    turnON(context) {\n        const entity = this.switches[0];\n        if (!this.isRunning) {\n            this.isRunning = true;\n            node.warn(`${this.name}: Luftentfeuchter eingeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"on\" };\n        }\n        return { entity_id: entity, action: \"Already ON\" };\n    }\n\n    turnOFF(context) {\n        const entity = this.switches[0];\n        if (this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Luftentfeuchter ausgeschaltet in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"off\" };\n        }\n        return { entity_id: entity, action: \"Already OFF\" };\n    }\n\n    setHumidityLevel(context, level) {\n        const entity = this.switches[0];\n        this.currentHumidity = level;\n        node.warn(`${this.name}: Luftfeuchtigkeit auf ${level}% gesetzt in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: level };\n    }\n\n    changeHumidity(context, delta) {\n        const entity = this.switches[0];\n        const newHumidity = Math.max(\n            this.minHumidity,\n            Math.min(this.maxHumidity, this.currentHumidity + delta)\n        );\n        if (newHumidity === this.currentHumidity) {\n            node.warn(`${this.name}: Luftfeuchtigkeit ist bereits auf Grenzwert (${this.currentHumidity}%) in ${this.inRoomName}`);\n            return { entity_id: entity, action: \"No Change\" };\n        }\n        this.currentHumidity = newHumidity;\n        node.warn(`${this.name}: Luftfeuchtigkeit geändert auf ${newHumidity}% in ${this.inRoomName}`);\n        return { entity_id: entity, action: \"setHumidity\", value: newHumidity };\n    }\n}\n\nclass Heater extends Device {\n    constructor(name) {\n        super(name, \"heater\");\n        this.minTemp = 0; // Minimale Temperatur\n        this.maxTemp = 0; // Maximale Temperatur\n        this.currentTemp = null; // Aktuelle Temperatur\n    }\n\n    init() {\n        // Initialisierungslogik, falls erforderlich\n    }\n\n    setTemps(minTemp, maxTemp) {\n        this.minTemp = minTemp;\n        this.maxTemp = maxTemp;\n        node.warn(`${this.name}: Temperaturbereich gesetzt auf ${minTemp}°C - ${maxTemp}°C.`);\n    }\n\n    getTemperatureRange() {\n        return { minTemp: this.minTemp, maxTemp: this.maxTemp };\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Heater: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                node.warn(`${this.name}: Heizung wird eingeschaltet.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: Heizung wird ausgeschaltet.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"maximum\":\n                node.warn(`${this.name}: Heizung wird auf maximale Temperatur ${this.maxTemp}°C eingestellt.`);\n                return { entity_id: this.switches[0], action: \"setTemp\", temperature: this.maxTemp };\n\n            case \"minimum\":\n                node.warn(`${this.name}: Heizung wird auf minimale Temperatur ${this.minTemp}°C eingestellt.`);\n                return { entity_id: this.switches[0], action: \"setTemp\", temperature: this.minTemp };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Heater: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass Cooler extends Device {\n    constructor(name) {\n        super(name, \"cooler\");\n        this.minTemp = 0; // Minimale Temperatur\n        this.maxTemp = 0; // Maximale Temperatur\n        this.currentTemp = null; // Aktuelle Temperatur\n    }\n\n    init() {\n        // Initialisierungslogik, falls erforderlich\n    }\n\n    setTemps(minTemp, maxTemp) {\n        this.minTemp = minTemp;\n        this.maxTemp = maxTemp;\n        node.warn(`${this.name}: Temperaturbereich gesetzt auf ${minTemp}°C - ${maxTemp}°C.`);\n    }\n\n    getTemperatureRange() {\n        return { minTemp: this.minTemp, maxTemp: this.maxTemp };\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Cooler: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                node.warn(`${this.name}: Kühlung wird eingeschaltet.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: Kühlung wird ausgeschaltet.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"maximum\":\n                node.warn(`${this.name}: Kühlung wird auf maximale Temperatur ${this.maxTemp}°C eingestellt.`);\n                return { entity_id: this.switches[0], action: \"setTemp\", temperature: this.maxTemp };\n\n            case \"minimum\":\n                node.warn(`${this.name}: Kühlung wird auf minimale Temperatur ${this.minTemp}°C eingestellt.`);\n                return { entity_id: this.switches[0], action: \"setTemp\", temperature: this.minTemp };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Cooler: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\n//// UNTIL HERE\n\nclass Pump extends Device {\n    constructor(name) {\n        super(name, \"pump\");\n        this.pumpInterval = 3600; // Mindestintervall zwischen Pumpzyklen (in Sekunden)\n        this.pumpDuration = 10; // Pumpdauer in Sekunden\n        this.isAutoRun = false; // Automatikmodus\n        this.OGBAutoMODE = false; // OpenGrowBox Steuerung\n        this.lastPumpTime = null; // Zeitpunkt des letzten Pumpvorgangs\n        this.soilMoisture = 0; // Bodenfeuchtigkeit\n        this.soilEC = 0; // Elektrische Leitfähigkeit\n        this.minSoilMoisture = 25; // Mindestbodenfeuchte\n        this.maxSoilEC = 2.5; // Maximaler EC-Wert\n    }\n\n    // Gerätedaten setzen und Bodenwerte aktualisieren\n    setData(data, context) {\n        this.setFromtent(context.tentName);\n        this.identifyIfFromAmbient();\n        this.data = { ...this.data, ...data };\n        this.identifySwitchesAndSensors();\n        this.updateIsRunningState();\n        this.evaluateStateFromData();\n        this.identifyIfOGBControlled(context);\n\n        // Aktualisiere Sensorwerte\n        if (data.soilmoisture) this.soilMoisture = parseFloat(data.soilmoisture);\n        if (data.soilec) this.soilEC = parseFloat(data.soilec);\n    }\n\n    // Prüfe OpenGrowBox Steuerung\n    identifyIfOGBControlled(context) {\n        this.OGBAutoMODE = !!context.controls.co2Control;\n    }\n\n    // Status aus Gerätedaten evaluieren\n    evaluateStateFromData() {\n        if (this.data) {\n            const pumpOnKey = Object.keys(this.data).find(key => key.includes(\"pump_on\"));\n            if (pumpOnKey) this.isRunning = this.data[pumpOnKey] === \"on\";\n\n            const autoRunKey = Object.keys(this.data).find(key => key.includes(\"pump_autorun\"));\n            if (autoRunKey) this.isAutoRun = this.data[autoRunKey] === \"on\";\n        }\n    }\n\n    // Mindestintervall prüfen\n    canPumpNow() {\n        const now = new Date();\n        const elapsedTime = this.lastPumpTime\n            ? (now.getTime() - this.lastPumpTime.getTime()) / 1000\n            : this.pumpInterval;\n\n        return elapsedTime >= this.pumpInterval;\n    }\n\n    // Prüfe, ob Bewässerung notwendig ist\n    needsWatering() {\n        return this.soilMoisture < this.minSoilMoisture && this.soilEC < this.maxSoilEC;\n    }\n\n    // Geräteaktionen ausführen\n    runAction(context) {\n        // Prüfe ob AutoModus aktiv ist\n        if (this.isAutoRun) {\n            return this.runAutoMode();\n        }\n\n        switch (this.action) {\n            case \"on\":\n                return this.runPump(\"on\");\n            case \"off\":\n                return this.runPump(\"off\");\n            case \"autorun-on\":\n                return this.setAutoMode(true);\n            case \"autorun-off\":\n                return this.setAutoMode(false);\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { entity_id: this.switches[0], action: \"UnknownAction\" };\n        }\n    }\n\n    // Automatische Steuerung der Pumpe\n    runAutoMode() {\n        if (!this.canPumpNow()) {\n            node.warn(`${this.name}: Intervall nicht erreicht.`);\n            return { entity_id: this.switches[0], action: \"wait_interval\" };\n        }\n\n        if (!this.needsWatering()) {\n            node.warn(`${this.name}: Keine Bewässerung notwendig (Moisture: ${this.soilMoisture}, EC: ${this.soilEC}).`);\n            return { entity_id: this.switches[0], action: \"no_water_needed\" };\n        }\n\n        this.lastPumpTime = new Date();\n        this.isRunning = true;\n\n        node.warn(`${this.name}: Starte automatische Bewässerung.`);\n        return { entity_id: this.switches[0], action: \"on\", duration: this.pumpDuration };\n    }\n\n    // Manuelle Pumpaktion ausführen\n    runPump(state) {\n        if (state === \"on\" && !this.isRunning) {\n            this.isRunning = true;\n            this.lastPumpTime = new Date();\n            node.warn(`${this.name}: Pumpe manuell eingeschaltet.`);\n            return { entity_id: this.switches[0], action: \"on\" };\n        } else if (state === \"off\" && this.isRunning) {\n            this.isRunning = false;\n            node.warn(`${this.name}: Pumpe manuell ausgeschaltet.`);\n            return { entity_id: this.switches[0], action: \"off\" };\n        } else {\n            return { entity_id: this.switches[0], action: `Already ${state.toUpperCase()}` };\n        }\n    }\n\n    // AutoModus setzen\n    setAutoMode(state) {\n        this.isAutoRun = state;\n        const action = state ? \"on\" : \"off\";\n        node.warn(`${this.name}: Automatikmodus ${state ? \"aktiviert\" : \"deaktiviert\"}.`);\n        return { entity_id: this.switches[1], action: action };\n    }\n}\n\n\nclass CO2 extends Device {\n    constructor(name) {\n        super(name, \"co2\"); // Setze den Gerätetyp auf \"co2\"\n        this.targetCO2 = 0; // Zielwert für CO2 (ppm)\n        this.currentCO2 = 0; // Aktueller CO2-Wert (ppm)\n        this.autoRegulate = false; // Automatische Steuerung\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    setTargetCO2(target) {\n        if(target !== this.targetCO2){\n            this.targetCO2 = target;\n        }\n    }\n\n    enableAutoRegulation() {\n        if(!this.enableAutoRegulation){\n            this.autoRegulate = true;\n        }\n    }\n\n    disableAutoRegulation() {\n        if (this.enableAutoRegulation) {\n            this.autoRegulate = false;\n        }\n    }\n\n    updateCurrentCO2(value) {\n        if(value !== this.currentCO2){\n            this.currentCO2 = value;\n        }\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") return false;\n\n        if (this.autoRegulate && this.currentCO2 < this.targetCO2) {\n            this.action = \"increased\";\n            return true;\n        } else if (this.autoRegulate && this.currentCO2 > this.targetCO2) {\n            this.action = \"reduced\";\n            return true;\n        }\n\n        return this.action !== \"unchanged\";\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { CO2: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"increased\":\n                node.warn(`${this.name}: CO2-Zufuhr wird erhöht.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"reduced\":\n                node.warn(`${this.name}: CO2-Zufuhr wird gestoppt.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            case \"on\":\n                node.warn(`${this.name}: CO2-Zufuhr wird aktiviert.`);\n                return { entity_id: this.switches[0], action: \"on\" };\n\n            case \"off\":\n                node.warn(`${this.name}: CO2-Zufuhr wird deaktiviert.`);\n                return { entity_id: this.switches[0], action: \"off\" };\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { CO2: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass GenericSwitch extends Device {\n    constructor(name) {\n        super(name, \"switch\"); // Setze den Gerätetyp auf \"switch\"\n        this.isRunning = false; // Status des Schalters\n    }\n\n    init() {\n        // Initialisierungen, falls notwendig\n    }\n\n    evalAction(context) {\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n        return true; // Standardmäßig erlauben\n    }\n\n    runAction(context) {\n        if (!this.evalAction(context)) {\n            return { Switch: `${this.name}`, Action: \"noChangesNeeded\" };\n        }\n\n        switch (this.action) {\n            case \"on\":\n                if (!this.isRunning) {\n                    this.isRunning = true;\n                    node.warn(`${this.name}: Switch wird eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"on\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits eingeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already ON\" };\n                }\n\n            case \"off\":\n                if (this.isRunning) {\n                    this.isRunning = false;\n                    node.warn(`${this.name}: Switch wird ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"off\" };\n                } else {\n                    node.warn(`${this.name}: Switch ist bereits ausgeschaltet.`);\n                    return { entity_id: this.switches[0], action: \"Already OFF\" };\n                }\n\n            default:\n                node.warn(`${this.name}: Unbekannte Aktion.`);\n                return { Switch: `${this.name}`, Action: \"UnknownAction\" };\n        }\n    }\n}\n\nclass Sensor extends Device {\n    constructor(name) {\n        super(name, \"sensor\");\n        this.readings = []; // Speichert Sensordaten\n    }\n\n    init() { }\n    evalAction(context) {\n        // Generische Prüfungen für alle Geräte\n        if (this.action === \"unchanged\") {\n            return false; // Keine Aktion erforderlich\n        }\n\n        return true; // Standardmäßig erlauben\n    }\n    addReading(reading) {\n        this.readings.push(reading);\n        return this.readings;\n    }\n\n    getLastReading() {\n        return this.readings.length > 0 ? this.readings[this.readings.length - 1] : null;\n    }\n\n    clearReadings() {\n        this.readings = [];\n    }\n}\n\n// Instanziiere die VPDControl-Klasse und speichere sie in der globalen Node-RED-Variablen\nglobal.set(\"OpenGrowBox\", OpenGrowBox);\nnode.status({fill:\"green\",shape:\"ring\",text:\"OpenGrowBox Started\"});\nmsg.topic = \"Init\"\nreturn msg\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":260,"y":80,"wires":[[]]},{"id":"e87f8899a673c36a","type":"debug","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"event","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":310,"y":560,"wires":[]},{"id":"c82af6bc5bdd07e6","type":"function","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"Manager","func":"// Hole oder initialisiere die globale Variable für Räume\nif (msg.topic === \"all_rooms\") return null;\n\n// Prüfen, ob die Klasse OpenGrowBox im globalen Kontext verfügbar ist\nconst OpenGrowBox = global.get(\"OpenGrowBox\");\nif (!OpenGrowBox) {\n    node.error(\"OpenGrowBox class not found in global context\");\n    return null;\n}\n\nconst room = msg.topic;\n\n// Hole die aktuelle Instanz des Raums\nlet roomInstance = global.get(room);\n\n// Instanz für den Raum erstellen, falls sie nicht existiert\nif (!roomInstance) {\n    roomInstance = new OpenGrowBox(room);\n    global.set(room, roomInstance);\n    node.warn(`Created new room instance for: ${room}`);\n}\n\n// Prüfen, ob Payload-Daten vorhanden sind\nif (msg.payload && typeof msg.payload === \"object\") {\n    const data = msg.payload;\n\n    // Iteriere über die Räume (Gruppen) und Geräte\n    for (const roomKey in data) {\n        const group = data[roomKey];\n\n        // Iteration über die Geräte in der Gruppe\n        for (const deviceName in group) {\n            const deviceData = group[deviceName];\n            const currentRoomDevs = roomInstance.devices || []; // Geräte aus der Instanz abrufen oder leeres Array initialisieren\n\n            // Überprüfen, ob das Gerät bereits existiert\n            const existingDevice = currentRoomDevs.find((device) => device.name === deviceName);\n\n            if (existingDevice) {\n                // Gerät existiert: Aktualisieren\n                existingDevice.setData(deviceData, roomInstance);\n            } else {\n                // Gerät existiert nicht: Neues Gerät hinzufügen\n                roomInstance.addDevice(deviceName, deviceData, roomInstance);\n                node.warn(`Added new device: ${deviceName}`);\n            }\n\n            // Iteration über die inneren Daten des Geräts für weitere Verarbeitung\n            for (const entity in deviceData) {\n                try {\n                    let currentValue = deviceData[entity];\n                    updateTentEnvs(entity, currentValue, roomInstance);\n                } catch (err) {\n                    node.error(`Error processing entity: ${entity} - ${err.message}`);\n                }\n            }\n        }\n    }\n\n    // Nach Verarbeitung die aktualisierte Instanz in den globalen Kontext zurückschreiben\n    global.set(room, roomInstance);\n}\n\n// Hilfsfunktion zur Normalisierung von Werten\nfunction normalizeValue(val) {\n    if (typeof val === \"string\") return val.trim(); // Trimme Strings\n    if (!isNaN(val)) return parseFloat(val);        // Konvertiere Zahlen\n    return val;                                     // Sonstige Werte unverändert\n}\n\n// Update-Funktion für TentEnvs\nfunction updateTentEnvs(entity, value, roomInstance) {\n    if (!roomInstance) return;\n\n    value = normalizeValue(value); // Eingehenden Wert normalisieren\n\n    if (entity.toLowerCase().includes(\"ogb_dryingmodes\")) {\n        if(roomInstance.tentMode !== \"Drying\")return\n        let currentObjState = roomInstance.getDryingMode ? normalizeValue(roomInstance.getDryingMode()) : \"\";\n        if (currentObjState !== value) {\n            node.warn(`DryingMode geändert: ${currentObjState} -> ${value}`);\n            roomInstance.setDryingMode(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_plantstage\")) {\n        let currentObjState = roomInstance.getPlantStageValue ? normalizeValue(roomInstance.getPlantStageValue()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setPlantStageValue(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_tentmode\")) {\n        let currentObjState = roomInstance.getTentMode ? normalizeValue(roomInstance.getTentMode()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setTentMode(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_holdvpdnight\")) {\n        let currentObjState = roomInstance.getVPDNightHold ? normalizeValue(roomInstance.getVPDNightHold()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setVPDNightHold(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_controlset\")) {\n        let currentObjState = roomInstance.getControlSet ? normalizeValue(roomInstance.getControlSet()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setControlSet(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_lightontime\")) {\n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n        if (currentObjState !== value) {\n            let stopTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n            roomInstance.setLightTimes(value, stopTime);\n        }\n        roomInstance.updateLightState();\n    }\n    if (entity.toLowerCase().includes(\"ogb_lightofftime\")) {\n        let currentObjState = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOffTime : \"\";\n        if (currentObjState !== value) {\n            let startTime = roomInstance.isPlantDay ? roomInstance.isPlantDay.lightOnTime : \"\";\n            roomInstance.setLightTimes(startTime, value);\n        }\n        roomInstance.updateLightState();\n    }\n    if (entity.toLowerCase().includes(\"ogb_vpdtarget\")) {\n        let currentObjState = roomInstance.getTargetedVPD ? normalizeValue(roomInstance.getTargetedVPD()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setTargetedVPD(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_leaftemp\")) {\n        let currentObjState = roomInstance.getLeafOffset ? normalizeValue(roomInstance.getLeafOffset()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setLeafOffset(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_co2_control\")) {\n        let currentObjState = roomInstance.getCO2Control ? normalizeValue(roomInstance.getCO2Control()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setCO2Control(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_lightcontrol\")) {\n        let currentObjState = roomInstance.getLightControlByOGB ? normalizeValue(roomInstance.getLightControlByOGB()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.setLightControlByOGB(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_ownweights\")) {\n        let currentObjState = roomInstance.getifOwnWeightsActive ? normalizeValue(roomInstance.getifOwnWeightsActive()) : \"\";\n        if (currentObjState !== value) {\n            roomInstance.activateOwnWeights(value);\n        }\n    }\n    if (entity.toLowerCase().includes(\"ogb_temperatureweight\") || entity.toLowerCase().includes(\"ogb_humidityweight\")) {\n        let currentObjState = roomInstance.getOwnWeights ? normalizeValue(roomInstance.getOwnWeights()) : \"\";\n\n        if (currentObjState !== value) {\n            roomInstance.setOwnWeights(entity, value);\n        }\n    }\n}\n\n// Rückgabe der aktualisierten Rauminstanz\nglobal.set(`${room}`, roomInstance);\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":820,"y":600,"wires":[["efb43912e7a2eb98","05fdf37a0dfc53e5","7eea3c825b6deed0"]]},{"id":"7eea3c825b6deed0","type":"debug","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"Manager","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":780,"y":560,"wires":[]},{"id":"2ca40f0181e36b3b","type":"debug","z":"7dbb001f4a12c33e","g":"f909d81ee941efae","name":"debug 477","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":590,"y":560,"wires":[]},{"id":"5772bf4c.b461d","type":"server","name":"OpenGrowBox","version":5,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":true,"cacheJson":true,"heartbeat":false,"heartbeatInterval":"30","areaSelector":"friendlyName","deviceSelector":"friendlyName","entitySelector":"friendlyName","statusSeparator":"at: ","statusYear":"hidden","statusMonth":"short","statusDay":"numeric","statusHourCycle":"h23","statusTimeFormat":"h:m","enableGlobalContextStore":true},{"id":"home-assistant-server","type":"server","name":"Home Assistant","addon":true}]